---
title: "EDA-Combat"
author: "Karina Roitman"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

# Objetivos

# 1. Cargar librerias.

rmarkdown como estrategia sintáctica. (En bibliografia hay 2 archivos)

```{r}
library(rmarkdown)
```

```{r}

library(stringr)
?stringr
library(tidyr)
?tidyr
library(dplyr)
library(openxlsx)
library(purrr)
library(broom)
library(ggplot2)
library(MALDIquant)
?MALDIquant
library(MALDIquantForeign)
?MALDIquantForeign
```

```{r}
getwd()  # Verifica el directorio de trabajo actual

```

```{r}
setwd("C:/Users/karin/Desktop/MCD/TESIS")
```

# 2. Cargar datos

```{r}
load("./Data_Kari/EspectrosINB/Average_ciego.INBIRS.1.rda")
load("./Data_Kari/EspectrosINB/Average_ciego.INBIRS.2.rda")
load("./Data_Kari/EspectrosINB/Average_ciego.INBIRS.3.rda")
load("./Data_Kari/EspectrosINB/Average_ciego.INBIRS.4.rda")
load("./Data_Kari/EspectrosHC/Average_HC_1.rda")
load("./Data_Kari/EspectrosHC/Average_HC_2.rda")
load("./Data_Kari/EspectrosHC/Average_HC_3.rda")
load("./Data_Kari/EspectrosHC/Average_HC_4.rda")
load("./Data_Kari/EspectrosHC/Average_HC_5.rda")
load("./Data_Kari/EspectrosHC/Average_HC_6.rda")
load("./Data_Kari/Espectros.Malb/Average_ciego.Malbran.1.rda")
load("./Data_Kari/Espectros.Malb/Average_ciego.Malbran.2.rda")
load("./Data_Kari/Espectros.Malb/Average_ciego.Malbran.3.rda")
load("./Data_Kari/EspectrosCR/Average_ciego.Costa.Rica.1.rda")
load("./Data_Kari/EspectrosCR/Average_ciego.Costa.Rica.3.rda")
```


#Ciego
 
```{r}
# load("./Data_Kari/ciego/Average_ciego.Costa.Rica.4.rda")
# load("./Data_Kari/ciego/Average_ciego.Costa.Rica.5.rda")
# load("./Data_Kari/ciego/Average_ciego.Costa.Rica.6.rda")
# load("./Data_Kari/ciego/Average_ciego.Malbran.4.rda")

```


# 3. Asigno batch, institucion y equipo

```{r}
# Listado de tus dataframes
dataframes <- list(INBIRS.1.df.f.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "16_7i"
  df$institucion <- "inbirs"
  df$equipo <- "HC"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

INBIRS.1.df.f.1 <- dataframes[[1]]
```

```{r}
# Listado de tus dataframes
dataframes <- list(INBIRS.df.2.f)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "17_7i"
  df$institucion <- "inbirs"
  df$equipo <- "HC"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

INBIRS.df.2.f <- dataframes[[1]]
```

```{r}
# Listado de tus dataframes
dataframes <- list(INBIRS.df.3.f)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "13_8i"
  df$institucion <- "inbirs"
  df$equipo <- "HC"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

INBIRS.df.3.f <- dataframes[[1]]
```

```{r}
# Listado de tus dataframes
dataframes <- list(Espectros.INBIRS.4.f)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "18_8i"
  df$institucion <- "inbirs"
  df$equipo <- "HC"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales
Espectros.INBIRS.4.f<-dataframes[[1]]

```

HC1

```{r}
# Listado de tus dataframes
dataframes <- list(Categ.Hospi.1.Neg, Categ.Hospi.1.Pos, Categ.Hospi.2.Cnt, Categ.Hospi.2.Neg, Categ.Hospi.2.No.Covid, Categ.Hospi.2.Pos, Categ.Hospi.3.Neg, Categ.Hospi.3.No.Covid, Categ.Hospi.3.Pos)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia1hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

Categ.Hospi.1.Neg<- dataframes[[1]]
Categ.Hospi.1.Pos<- dataframes[[2]]
Categ.Hospi.2.Cnt<- dataframes[[3]]
Categ.Hospi.2.Neg<- dataframes[[4]]
Categ.Hospi.2.No.Covid<- dataframes[[5]]
Categ.Hospi.2.Pos<- dataframes[[6]]
Categ.Hospi.3.Neg<- dataframes[[7]]
Categ.Hospi.3.No.Covid<- dataframes[[8]]
Categ.Hospi.3.Pos<- dataframes[[9]]

```

HC2

```{r}
dataframes <- list(Categ.Ciego.clin.1.Exp1.covid, Categ.Ciego.clin.1.Exp1.flu)

dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia2hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

Categ.Ciego.clin.1.Exp1.covid<-dataframes[[1]]
Categ.Ciego.clin.1.Exp1.flu<-dataframes[[2]]
```

HC3

```{r}
dataframes <- list(Categ.Neg.New.clin.1, Categ.Pos.New.clin.1)

dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia3hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

Categ.Neg.New.clin.1<-dataframes[[1]]
Categ.Pos.New.clin.1<-dataframes[[2]]
```

HC4

```{r}
dataframes <- list(Categ.Ciego.clin25.6.2.covid, Categ.Ciego25.6.clin.2.flu)

dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia4hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

Categ.Ciego.clin25.6.2.covid<-dataframes[[1]]
Categ.Ciego25.6.clin.2.flu<-dataframes[[2]]
```

HC5

```{r}
dataframes <- list(Categ.Ciego_3_7.4)

dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia5hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

Categ.Ciego_3_7.4<-dataframes[[1]]
```

HC6

```{r}
dataframes <- list(Categ.Ciego_8_7.4)

dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia2hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

Categ.Ciego_8_7.4<-dataframes[[1]]

```

MALBRAN 1

```{r}
# Listado de tus dataframes
dataframes <- list(Categ.Malbran.1.1.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "1Malbran"
  df$institucion <- "Malbran"
  df$equipo <- "Malbran"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

Categ.Malbran.1.1.1 <- dataframes[[1]]
```

MALBRAN2

```{r}
# Listado de tus dataframes
dataframes <- list(Categ.Malbran.2.1.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "2Malbran"
  df$institucion <- "Malbran"
  df$equipo <- "Malbran"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

Categ.Malbran.2.1.1 <- dataframes[[1]]
```

MALBRAN3

```{r}
# Listado de tus dataframes
dataframes <- list(Malbran_3_4.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "3Malbran"
  df$institucion <- "Malbran"
  df$equipo <- "Malbran"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

Malbran_3_4.1 <- dataframes[[1]]
```

CR1

```{r}
# Listado de tus dataframes
dataframes <- list(CostaRica.1.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "1CR"
  df$institucion <- "CR"
  df$equipo <- "CR"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

CostaRica.1.1 <- dataframes[[1]]
```

CR2

```{r}
# Listado de tus dataframes
dataframes <- list(CostaRica.3.1.1.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "2CR"
  df$institucion <- "CR"
  df$equipo <- "CR"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

CostaRica.3.1.1.1<- dataframes[[1]]


CostaRica.3.1.1.1$PCR.Cov <- CostaRica.3.1.1.1$Virus
```




#ciego costa rica 4

```{r}
# # Listado de tus dataframes
# dataframes <- list(CostaRica.4.1.1)
# 
# # Usas lapply para agregar las columnas a cada dataframe
# dataframes <- lapply(dataframes, function(df) {
#   df$institucion <- "CR"
#   df$equipo <- "CR"
#   return(df)
# })
# 
# CostaRica.4.1.1 <- dataframes[[1]]
```



CR5


```{r}
# # Listado de tus dataframes
# dataframes <- list(CostaRica.5.1)
# 
# # Usas lapply para agregar las columnas a cada dataframe
# dataframes <- lapply(dataframes, function(df) {
#   df$institucion <- "CR"
#   df$equipo <- "CR"
#   return(df)
# })
# 
# # Asignas los dataframes modificados de vuelta a sus nombres originales
# 
# CostaRica.5.1 <- dataframes[[1]]
```



#ciego costa rica 6

CR6


```{r}
# # Listado de tus dataframes
# dataframes <- list(CostaRica.6.1)
# 
# # Usas lapply para agregar las columnas a cada dataframe
# dataframes <- lapply(dataframes, function(df) {
#   df$institucion <- "CR"
#   df$equipo <- "CR"
#   return(df)
# })
# 
# # Asignas los dataframes modificados de vuelta a sus nombres originales
# 
# CostaRica.6.1 <- dataframes[[1]]
```


# ciego MALBRAN 4

```{r}
# # Listado de tus dataframes
# dataframes <- list(Malbran_5_6.1)
# 
# # Usas lapply para agregar las columnas a cada dataframe
# dataframes <- lapply(dataframes, function(df) {
#   df$institucion <- "Malbran"
#   df$equipo <- "Malbran"
#   return(df)
# })
# 
# # Asignas los dataframes modificados de vuelta a sus nombres originales
# 
# Malbran_5_6.1 <- dataframes[[1]]
```


# 4. Listado de todos los dataframes

```{r}
# dataframes <- list(INBIRS.1.df.f.1,
# INBIRS.df.2.f,
# INBIRS.df.3.f,
# Espectros.INBIRS.4.f,
# Categ.Hospi.1.Neg,
# Categ.Hospi.1.Pos,
# Categ.Hospi.2.Cnt,
# Categ.Hospi.2.Neg,
# Categ.Hospi.2.No.Covid,
# Categ.Hospi.2.Pos,
# Categ.Hospi.3.Neg,
# Categ.Hospi.3.No.Covid,
# Categ.Hospi.3.Pos,
# Categ.Ciego.clin.1.Exp1.covid,
# Categ.Ciego.clin.1.Exp1.flu,
# Categ.Neg.New.clin.1,
# Categ.Pos.New.clin.1,
# Categ.Ciego.clin25.6.2.covid,
# Categ.Ciego25.6.clin.2.flu,
# Categ.Ciego_3_7.4,
# Categ.Ciego_8_7.4,
# Categ.Malbran.1.1.1,
# Categ.Malbran.2.1.1,
# Malbran_3_4.1,
# CostaRica.1.1,
# CostaRica.3.1.1.1)
# 
# 
# 
# 
# # Contar filas para cada dataframe
# filas_count <- sapply(dataframes, nrow)
# 
# # Mostrar los resultados
# print(filas_count)
# sum(filas_count)
```

# 5. Union de todos los espectros

```{r , message=FALSE, echo=FALSE, warning=FALSE, out.width="100%"}

Espec.Union.Clin.Pos.Neg <- c(
                            Espectros.INBIRS.1,
                            Espectros.INBIRS.2,
                            Espectros.INBIRS.3,
                            Espectros.INBIRS.4,
                            Espectros.HC.1.Neg,
                            Espectros.HC.1.HighPos,
                            Espectros.HC.2.Cnt,
                            Espectros.HC.2.Neg,
                            Espectros.HC.2.No.covid,
                            Espectros.HC.2.IntPos,
                            Espectros.HC.3.Neg,
                            Espectros.HC.3.No.covid,
                            Espectros.HC.3.LowPos,
                            Espectros.Ciego.Exp1.covid,
                            Espectros.Ciego.Exp1.flu,
                            Espectros.Neg.New.Clin,
                            Espectros.Pos.New.Clin, 
                            Espectros.Ciego.25.6.covid,
                            Espectros.Ciego.25.6.flu,
                            Espectros.Ciego.4.2,
                            Espectros.Ciego.5,
                            Espectros.Malbran.24,
                            Espectros.Malb.2.24,
                            Espectros.Malb.3_4,
                            Espectros.CR1,
                            Espectros.CR3
                            # Espectros.CR4, #ciego
                            # Espectros.CR5,#ciego
                            # Espectros.CR6,#ciego
                            # Espectros.Malb.5_6#ciego
                            )

Espectra.1 <- alignSpectra(Espec.Union.Clin.Pos.Neg, halfWindowSize=50, SNR=3, 
                    tolerance=0.5, warpingMethod="quadratic")
```

```{r}
library(purrr)
```

```{r}
INBIRS.1.df.f.1<-INBIRS.1.df.f.1[,c(1,6:10)]
INBIRS.1.df.f.1<-data.frame(purrr::map(INBIRS.1.df.f.1, as.character),
                               stringsAsFactors = FALSE)

INBIRS.df.2.f<-INBIRS.df.2.f[,c(1,6:10)]
INBIRS.df.2.f<-data.frame(purrr::map(INBIRS.df.2.f, as.character ),
                               stringsAsFactors = FALSE)

INBIRS.df.3.f<-INBIRS.df.3.f[,c(1,6:10)]
INBIRS.df.3.f<-data.frame(purrr::map(INBIRS.df.3.f, as.character ),
                               stringsAsFactors = FALSE)


Espectros.INBIRS.4.f<-Espectros.INBIRS.4.f[,c(1,6:10)]
Espectros.INBIRS.4.f<-data.frame(purrr::map(Espectros.INBIRS.4.f, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.1.Neg<- Categ.Hospi.1.Neg[,c(1,5,7,10:12)]
#Categ.Hospi.1.Neg<- data.frame(map(Categ.Hospi.1.Neg, as.character),
 #                              stringsAsFactors = FALSE)
Categ.Hospi.1.Neg<-data.frame(purrr::map(Categ.Hospi.1.Neg, as.character ),
                              stringsAsFactors = FALSE)

Categ.Hospi.1.Pos<- Categ.Hospi.1.Pos[,c(1,5,7,10:12)]
Categ.Hospi.1.Pos<-data.frame(purrr::map(Categ.Hospi.1.Pos, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.2.Cnt<- Categ.Hospi.2.Cnt[,c(1,5,8,11:13)]
Categ.Hospi.2.Cnt<-data.frame(purrr::map(Categ.Hospi.2.Cnt, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.2.Neg<- Categ.Hospi.2.Neg[,c(1,5,8,11:13)]
Categ.Hospi.2.Neg<-data.frame(purrr::map(Categ.Hospi.2.Neg, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.2.No.Covid<- Categ.Hospi.2.No.Covid[,c(1,5,8,11:13)]
Categ.Hospi.2.No.Covid<-data.frame(purrr::map(Categ.Hospi.2.No.Covid, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.2.Pos<- Categ.Hospi.2.Pos[,c(1,5,8,11:13)]
Categ.Hospi.2.Pos<-data.frame(purrr::map(Categ.Hospi.2.Pos, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.3.Neg<- Categ.Hospi.3.Neg[,c(1,5,8,11:13)]
Categ.Hospi.3.Neg<-data.frame(purrr::map(Categ.Hospi.3.Neg, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.3.No.Covid<- Categ.Hospi.3.No.Covid[,c(1,5,8,11:13)]
Categ.Hospi.3.No.Covid<-data.frame(purrr::map(Categ.Hospi.3.No.Covid, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.3.Pos<- Categ.Hospi.3.Pos[,c(1,5,8,11:13)]
Categ.Hospi.3.Pos<-data.frame(purrr::map(Categ.Hospi.3.Pos, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego.clin.1.Exp1.covid<-Categ.Ciego.clin.1.Exp1.covid[,c(1,6,7,9:11)]
Categ.Ciego.clin.1.Exp1.covid<-data.frame(purrr::map(Categ.Ciego.clin.1.Exp1.covid, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego.clin.1.Exp1.flu<-Categ.Ciego.clin.1.Exp1.flu[,c(1,6,7,9:11)]
Categ.Ciego.clin.1.Exp1.flu<-data.frame(purrr::map(Categ.Ciego.clin.1.Exp1.flu, as.character ),
                               stringsAsFactors = FALSE)

Categ.Neg.New.clin.1<-Categ.Neg.New.clin.1[,c(1,6:10)]
Categ.Neg.New.clin.1<-data.frame(purrr::map(Categ.Neg.New.clin.1, as.character ),
                               stringsAsFactors = FALSE)

Categ.Pos.New.clin.1<-Categ.Pos.New.clin.1[,c(1,6:10)]
Categ.Pos.New.clin.1<-data.frame(purrr::map(Categ.Pos.New.clin.1, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego.clin25.6.2.covid<-Categ.Ciego.clin25.6.2.covid[,c(1,6,7, 9:11)]
Categ.Ciego.clin25.6.2.covid<-data.frame(purrr::map(Categ.Ciego.clin25.6.2.covid, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego25.6.clin.2.flu<-Categ.Ciego25.6.clin.2.flu[,c(1,6,7, 9:11)]
Categ.Ciego25.6.clin.2.flu<-data.frame(purrr::map(Categ.Ciego25.6.clin.2.flu, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego_3_7.4<-Categ.Ciego_3_7.4[,c(1,6:10)]
Categ.Ciego_3_7.4<-data.frame(purrr::map(Categ.Ciego_3_7.4, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego_8_7.4<-Categ.Ciego_8_7.4[,c(1,6:10)]
Categ.Ciego_8_7.4<-data.frame(purrr::map(Categ.Ciego_8_7.4, as.character ),
                               stringsAsFactors = FALSE)


Categ.Malbran.1.1.1<-Categ.Malbran.1.1.1[,c(1,5:9)]
Categ.Malbran.1.1.1<-data.frame(purrr::map(Categ.Malbran.1.1.1, as.character ),
                               stringsAsFactors = FALSE)

Categ.Malbran.2.1.1<-Categ.Malbran.2.1.1[,c(1,5:9)]
Categ.Malbran.2.1.1<-data.frame(purrr::map(Categ.Malbran.2.1.1, as.character ),
                               stringsAsFactors = FALSE)

Malbran_3_4.1<-Malbran_3_4.1[,c(1,6:10)]
Malbran_3_4.1<-data.frame(purrr::map(Malbran_3_4.1, as.character ),
                               stringsAsFactors = FALSE)

CostaRica.1.1<-CostaRica.1.1[,c(1,6:10)]
CostaRica.1.1<-data.frame(purrr::map(CostaRica.1.1, as.character ),
                               stringsAsFactors = FALSE)

CostaRica.1.1$Carga<-as.character(CostaRica.1.1$Carga)

CostaRica.3.1.1.1<-CostaRica.3.1.1.1[,c(1,6:10)]
CostaRica.3.1.1.1<-data.frame(purrr::map(CostaRica.3.1.1.1, as.character),
                               stringsAsFactors = FALSE)
CostaRica.3.1.1.1$Carga<-as.character(CostaRica.3.1.1.1$Carga)

```




#ciego costa rica 4



<!-- ```{r} -->
<!-- CostaRica.4.1.1<-CostaRica.4.1.1[,c(1,3,5,6,8,9)] -->
<!-- CostaRica.4.1.1<-data.frame(purrr::map(CostaRica.4.1.1, as.character ), -->
<!--                                stringsAsFactors = FALSE) -->
<!-- ``` -->

<!-- ```{r} -->

<!-- library(dplyr) -->

<!-- CostaRica.4.1.1 <- CostaRica.4.1.1 %>% rename(PCR.Cov = Virus) -->
<!-- CostaRica.4.1.1 <- CostaRica.4.1.1 %>% rename(fecha = protocolo) -->
<!-- library(dplyr) -->

<!-- CostaRica.4.1.1 <- CostaRica.4.1.1 %>% dplyr::select(spot.a.1, Carga, PCR.Cov, fecha, institucion, equipo) -->


<!-- CostaRica.4.1.1<-CostaRica.4.1.1[-1,] -->
<!-- ``` -->

<!-- #ciego costa rica 5 -->



<!-- ```{r} -->
<!-- CostaRica.5.1<-CostaRica.5.1[,c(1,3,5,6,8,9)] -->
<!-- CostaRica.5.1<-data.frame(purrr::map(CostaRica.5.1, as.character ), -->
<!--                                stringsAsFactors = FALSE) -->
<!-- ``` -->

<!-- ```{r} -->

<!-- library(dplyr) -->

<!-- CostaRica.5.1 <- CostaRica.5.1 %>% rename(PCR.Cov = Virus) -->
<!-- CostaRica.5.1 <- CostaRica.5.1 %>% rename(fecha = protocolo) -->
<!-- library(dplyr) -->

<!-- CostaRica.5.1 <- CostaRica.5.1 %>% dplyr::select(spot.a.1, Carga, PCR.Cov, fecha, institucion, equipo) -->

<!-- ``` -->



<!-- ```{r} -->
<!-- CostaRica.6.1<-CostaRica.6.1[,c(1,3,5,6,8,9)] -->
<!-- CostaRica.6.1<-data.frame(purrr::map(CostaRica.6.1, as.character ), -->
<!--                                stringsAsFactors = FALSE) -->
<!-- ``` -->

<!-- ```{r} -->

<!-- library(dplyr) -->

<!-- CostaRica.6.1 <- CostaRica.6.1 %>% rename(PCR.Cov = Virus) -->
<!-- CostaRica.6.1 <- CostaRica.6.1 %>% rename(fecha = protocolo) -->
<!-- library(dplyr) -->

<!-- CostaRica.6.1 <- CostaRica.6.1 %>% dplyr::select(spot.a.1, Carga, PCR.Cov, fecha, institucion, equipo) -->

<!-- ``` -->





<!-- ```{r} -->
<!-- Malbran_5_6.1<-Malbran_5_6.1[,c(1,3,6,7,8,9)] -->
<!-- Malbran_5_6.1<-data.frame(purrr::map(Malbran_5_6.1, as.character ), -->
<!--                                stringsAsFactors = FALSE) -->



<!-- #Malbran_5_6.1 <- Malbran_5_6.1 %>% rename(PCR.Cov = Virus) -->
<!-- Malbran_5_6.1 <- Malbran_5_6.1 %>% rename(fecha = protocolo) -->
<!-- library(dplyr) -->

<!-- Malbran_5_6.1<-Malbran_5_6.1 %>% dplyr::select(spot.a.1, Carga, PCR.Cov, fecha, institucion, equipo) -->
<!-- ``` -->




```{r}
dataframes <- list(INBIRS.1.df.f.1,
INBIRS.df.2.f,
INBIRS.df.3.f,
Espectros.INBIRS.4.f,
Categ.Hospi.1.Neg,
Categ.Hospi.1.Pos,
Categ.Hospi.2.Cnt,
Categ.Hospi.2.Neg,
Categ.Hospi.2.No.Covid,
Categ.Hospi.2.Pos,
Categ.Hospi.3.Neg,
Categ.Hospi.3.No.Covid,
Categ.Hospi.3.Pos,
Categ.Ciego.clin.1.Exp1.covid,
Categ.Ciego.clin.1.Exp1.flu,
Categ.Neg.New.clin.1,
Categ.Pos.New.clin.1,
Categ.Ciego.clin25.6.2.covid,
Categ.Ciego25.6.clin.2.flu,
Categ.Ciego_3_7.4,
Categ.Ciego_8_7.4,
Categ.Malbran.1.1.1,
Categ.Malbran.2.1.1,
Malbran_3_4.1,
CostaRica.1.1,
CostaRica.3.1.1.1)
# CostaRica.4.1.1,#ciego
# CostaRica.5.1,#ciego
# CostaRica.6.1, #ciego
# Malbran_5_6.1)




# Contar filas para cada dataframe
filas_count <- sapply(dataframes, nrow)

# Mostrar los resultados
print(filas_count)
sum(filas_count)
```

# 6. Union de todos los dataframes

```{r}
Base.Union.Clinc.Covid <- INBIRS.1.df.f.1 %>%
  bind_rows(INBIRS.df.2.f) %>%
  bind_rows(INBIRS.df.3.f) %>%
  bind_rows(Espectros.INBIRS.4.f) %>%
bind_rows(Categ.Hospi.1.Neg)%>%
bind_rows(Categ.Hospi.1.Pos)%>%
bind_rows(Categ.Hospi.2.Cnt)%>%
bind_rows(Categ.Hospi.2.Neg)%>%
bind_rows(Categ.Hospi.2.No.Covid)%>%
bind_rows(Categ.Hospi.2.Pos)%>%
bind_rows(Categ.Hospi.3.Neg)%>%
bind_rows(Categ.Hospi.3.No.Covid)%>%
bind_rows(Categ.Hospi.3.Pos)%>%
bind_rows(Categ.Ciego.clin.1.Exp1.covid)%>%
bind_rows(Categ.Ciego.clin.1.Exp1.flu)%>%
bind_rows(Categ.Neg.New.clin.1)%>%
bind_rows(Categ.Pos.New.clin.1)%>%
bind_rows(Categ.Ciego.clin25.6.2.covid)%>%
bind_rows(Categ.Ciego25.6.clin.2.flu)%>%
bind_rows(Categ.Ciego_3_7.4)%>%
bind_rows(Categ.Ciego_8_7.4)%>%
bind_rows(Categ.Malbran.1.1.1)%>%
bind_rows(Categ.Malbran.2.1.1)%>%
bind_rows(Malbran_3_4.1)%>%
bind_rows(CostaRica.1.1)%>%
bind_rows(CostaRica.3.1.1.1)
# bind_rows(CostaRica.4.1.1)%>%
# bind_rows(CostaRica.5.1)%>%
# bind_rows(CostaRica.6.1)%>%
# bind_rows(Malbran_5_6.1)
```

```{r}
Espectra.Orig <- data.frame(names(Espectra.1),
                                  stringsAsFactors = FALSE)
names(Espectra.Orig)<- c("spot.a.1")

Datos_actualizados<-  Espectra.Orig %>%
  left_join( Base.Union.Clinc.Covid, by="spot.a.1")
```




```{r}
save(Datos_actualizados, file = "metadata.rda")

```


```{r}
# dev.new()
# 
# # Inicializar el gráfico con el primer espectro
# plot(Espectra.1[[1]], main = "Espectros Superpuestos", col = "blue", type = "l")
# 
# # Iterar sobre los espectros restantes y agregarlos al gráfico
# for (i in 2:length(Espectra.1)) {
#   lines(Espectra.1[[i]], col = i)  # Añadir líneas para cada espectro, con diferentes colores
# }
# 
# # Añadir una leyenda para indicar los colores de cada espectro
# legend("topright", legend = 1:length(Espectra.1), col = 1:length(Espectra.1),
#        title = "Espectros", cex = 0.8)
```

# 7. Deteccion y filtrado de picos

```{r , message=FALSE, echo=FALSE, warning=FALSE}

peaks <- detectPeaks(Espectra.1, SNR = 3, 
                     method="MAD", halfWindowSize=50)
peaks <- binPeaks(peaks,tolerance=0.5)

species.Ave<-factor(Datos_actualizados$PCR.Cov) 
spot.factor.Avera<-factor(Datos_actualizados$spot.a.1) 

peaks <- filterPeaks(peaks, minFrequency=c(0.2, 0.2),
                     labels = species.Ave,
                     mergeWhitelists=TRUE)

featureMatrix <- intensityMatrix(peaks, Espectra.1)
```


dejo tres decimales

```{r}
featureMatrix <- apply(featureMatrix, c(1, 2), function(x) signif(x, digits = 3))

```

```{r}
save(featureMatrix, file = "feature_matrix.rda")

```


```{r}
num_peaks <- sapply(peaks, length)
freq_table <- table(num_peaks)

# Mostrar la tabla
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Num_Peaks", "Frequency")

# Mostrar la tabla con cantidad de espectros con x cantidad de picos
print(freq_df)
```


```{r}
featureMatrix<- cbind(featureMatrix, label=Datos_actualizados$spot.a.1, covid=Datos_actualizados$PCR.Cov, carga=Datos_actualizados$Carga, dia=Datos_actualizados$batch, equipo=Datos_actualizados$equipo, fecha=Datos_actualizados$fecha, institucion=Datos_actualizados$institucion)
```


```{r}
featureMatrix <- as.data.frame(featureMatrix)
sum(is.na(featureMatrix$carga))


table(featureMatrix$carga, useNA = "ifany")
```


```{r}
subset(featureMatrix, carga %in% c("Cov.Pos", "Cov.Neg"))
```


```{r}
# 1️⃣ Paso previo: convierto featureMatrix a data.frame
featureMatrix <- as.data.frame(featureMatrix)

# 2️⃣ Creo vector auxiliar con los números (los que no son número quedarán NA en num, PERO no toco carga)
num <- suppressWarnings(as.numeric(as.character(featureMatrix$carga)))

# 3️⃣ Recategorizo SOLO los que son números
featureMatrix$carga[!is.na(num) & num < 24]              <- "High"
featureMatrix$carga[!is.na(num) & num >= 24 & num <= 28] <- "Int"
featureMatrix$carga[!is.na(num) & num > 28]              <- "Low"


featureMatrix <- featureMatrix %>%
  filter(carga %in% c("High", "Int", "Neg"))


#esto es lo que perdimos:
#Cov.Neg Cov.Pos    High     Int     Low     Neg      SD    <NA> 
#  26      24      38      58      49     133     201      34 

```





Quedan 296 espectros con cargas HIGH INT y NEG. Aclaracion: como costa rica no coloco el dato, en carga solo dice Cov.Pos o neg, no se incluyen en el análisis

```{r}
featureMatrix
```


# 8. EDA

```{r}


# Crear tabla de frecuencias
data_freq <- as.data.frame(table(Datos_actualizados$institucion, Datos_actualizados$PCR.Cov))
colnames(data_freq) <- c("institucion", "covid_status", "frecuencia")


# Gráfico de barras superpuestas
ggplot(data_freq, aes(x = institucion, y = frecuencia, fill = covid_status)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Frecuencia por Institución",
       x = "Institución",
       y = "Frecuencia") +
  scale_fill_manual(values = c("Cov.Neg" = "blue", "Cov.Pos" = "red")) +
  theme_minimal()
```

```{r}

print(data_freq)
```


```{r}


# Cargar la librería
#library(writexl)

# Exportar a Excel
#write.xlsx(data_freq, "C:/Users/karin/Desktop/MCD/TESIS/datafreq.xlsx")
```

```{r}
Datos_actualizados<- Datos_actualizados[ , -10]

Datos_actualizados$id <- 1:nrow(Datos_actualizados)
Datos_actualizados <- Datos_actualizados[ , c("id", names(Datos_actualizados)[-ncol(Datos_actualizados)])]
```

# 9 Matrices
## Matriz de intensidades con label

```{r}

# # Crear una nueva columna con secuencia del 1 hasta el número de filas
# featureMatrix<- cbind(id=Datos_actualizados$id, featureMatrix) 
```

## Matriz numerica

```{r}
# Exclude non-numerical columns 
featureMatrix_num <- featureMatrix[, -c(1, (ncol(featureMatrix)-5):ncol(featureMatrix))]
```

```{r}
featureMatrix_num <- apply(featureMatrix_num, 2, function(x) as.numeric(as.character(x)))

```

```{r}
sapply(featureMatrix_num, class)
```

```{r}
class(featureMatrix_num)
```


```{r}
# Calcular estadísticas por pico con conversión numérica
pico_stats <- function(featureMatrix_num) {
  # Convertimos la matriz a numérica, preservando los nombres de las columnas
  nombres_picos <- colnames(featureMatrix_num)
  
  # Convertimos la matriz a numérica
  featureMatrix_num <- apply(featureMatrix_num, 2, function(x) as.numeric(as.character(x)))
  colnames(featureMatrix_num) <- nombres_picos
  
  # Calculamos las estadísticas
  stats <- data.frame(
    nombre_pico = nombres_picos,
    promedio = colMeans(featureMatrix_num, na.rm = TRUE),
    minimo = apply(featureMatrix_num, 2, min, na.rm = TRUE),
    maximo = apply(featureMatrix_num, 2, max, na.rm = TRUE),
    desv_std = apply(featureMatrix_num, 2, sd, na.rm = TRUE)
  )
  
  # Añadimos el número de pico
  stats$pico_numero <- 1:nrow(stats)
  
  # Reordenamos las columnas
  stats <- stats[, c("pico_numero", "nombre_pico", "promedio", "minimo", "maximo", "desv_std")]
  
  return(stats)
}

# Para usar la función:
resultados <- pico_stats(featureMatrix_num)

# Ver los primeros resultados
head(resultados)

```



# 10. PCA mixOmics


```{r}
library(mixOmics)

#Performs a principal components analysis on the given data matrix that can contain missing values. If data are complete 'pca' uses Singular Value Decomposition, if there are some missing values, it uses the NIPALS algorithm.
```

```{r}
featureMatrix_num <- apply(featureMatrix_num, 2, as.numeric)

str(featureMatrix_num)
```

```{r}
?pca
```

```{r}

pca.before <- pca(featureMatrix_num, ncomp = 10)   #ncomp=	Integer, if data is complete ncomp decides the number of components and associated eigenvalues to display from the pcasvd algorithm and if the data has missing values, ncomp gives the number of components to keep to perform the reconstitution of the data using the NIPALS algorithm. If NULL, function sets ncomp = min(nrow(X), ncol(X))

```

```{r}
#pca.before$institucion <- Datos_actualizados$institucion
pca.before$fecha <- featureMatrix$fecha
pca.before$equipo <-featureMatrix$equipo
pca.before$covid<- featureMatrix$covid
```

```{r}
pca_coor<-as.data.frame(pca.before$variates$X) # Coordenadas principales obtenidas del PCA
pca.before$X

```

```{r}
dim(pca_coor)
```

```{r}
colnames(pca.before$variates$X) <- paste0("PC", 1:ncol((pca.before$variates$X)))
```

```{r}
library(ggExtra)
#expl_var <- pca.before$sdev^2 / sum(pca.before$sdev^2)  # Varianza explicada por cada componente

# Crear un gráfico de dispersión con ggplot2
p <- ggplot(pca_coor, aes(x = PC1, y = PC2, color = pca.before$equipo, shape = pca.before$covid)) +
  geom_point(size = 2) +  # Tamaño de los puntos
  labs(title = 'PCA con mixOmics',
       x = 'Componente principal 1',
       y = 'Componente principal 2',
       color = 'Batch', shape = 'Tratamiento') +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12,),  # Reducir tamaño del título
    axis.title.x = element_text(size = 12),  # Reducir tamaño del título del eje X
    axis.title.y = element_text(size = 12),  # Reducir tamaño del título del eje Y
    axis.text = element_text(size = 1),  # Reducir tamaño de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tamaño del título de la leyenda
    legend.text = element_text(size = 12)  # Reducir tamaño del texto de la leyenda
  )


# Añadir gráficos de densidad marginal con ggExtra
p_with_density <- ggMarginal(p, type = "density", margins = "both", groupColour = TRUE, groupFill = TRUE)

# Mostrar el gráfico final
print(p_with_density)
```

```{r}
nrow(pca_coor)        # debería dar 327
length(pca.before$equipo)  # ¿también 327?
length(pca.before$covid)   # igual que los demás

```


```{r}
library(ggExtra)
#expl_var <- pca.before$sdev^2 / sum(pca.before$sdev^2)  # Varianza explicada por cada componente

# Crear un gráfico de dispersión con ggplot2
p <- ggplot(pca_coor, aes(x = PC2, y = PC3, color = pca.before$equipo, shape = pca.before$covid)) +
  geom_point(size = 2) +  # Tamaño de los puntos
  labs(title = 'PCA con mixOmics',
       x = 'Componente principal 2',
       y = 'Componente principal 3',
       color = 'Batch', shape = 'Tratamiento') +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12,),  # Reducir tamaño del título
    axis.title.x = element_text(size = 12),  # Reducir tamaño del título del eje X
    axis.title.y = element_text(size = 12),  # Reducir tamaño del título del eje Y
    axis.text = element_text(size = 1),  # Reducir tamaño de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tamaño del título de la leyenda
    legend.text = element_text(size = 12)  # Reducir tamaño del texto de la leyenda
  )


# Añadir gráficos de densidad marginal con ggExtra
p_with_density2 <- ggMarginal(p, type = "density", margins = "both", groupColour = TRUE, groupFill = TRUE)

# Mostrar el gráfico final
print(p_with_density2)
```


```{r}
library(ggExtra)
#expl_var <- pca.before$sdev^2 / sum(pca.before$sdev^2)  # Varianza explicada por cada componente

# Crear un gráfico de dispersión con ggplot2
p <- ggplot(pca_coor, aes(x = PC1, y = PC2, color = pca.before$covid)) +
  geom_point(size = 2) +  # Tamaño de los puntos
  labs(title = 'PCA con mixOmics',
       x = 'Componente principal 1',
       y = 'Componente principal 2',
       color = 'Batch') +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12,),  # Reducir tamaño del título
    axis.title.x = element_text(size = 10),  # Reducir tamaño del título del eje X
    axis.title.y = element_text(size = 10),  # Reducir tamaño del título del eje Y
    axis.text = element_text(size = 1),  # Reducir tamaño de los textos de los ejes
    legend.title = element_text(size = 10),  # Reducir tamaño del título de la leyenda
    legend.text = element_text(size = 10)  # Reducir tamaño del texto de la leyenda
  )


# Añadir gráficos de densidad marginal con ggExtra
p_with_density3 <- ggMarginal(p, type = "density", margins = "both", groupColour = TRUE, groupFill = TRUE)

# Mostrar el gráfico final
print(p_with_density3)
```

```{r}
# Extraer la varianza explicada
explained_var <- pca.before$prop_expl_var$X * 100  # Convertir a porcentaje
components <- seq_along(explained_var)  # Crear un índice para los componentes

# Crear un data frame para el gráfico
var_df <- data.frame(
  Component = components,
  ExplainedVariance = explained_var
)

# Graficar usando ggplot2
library(ggplot2)
explained_var_plot_MixOmics<- ggplot(var_df, aes(x = Component, y = ExplainedVariance)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes(label = round(ExplainedVariance, 1)), vjust = -0.5, size = 3) +

  labs(
    title = "Varianza explicada -MixOmics",
    x = "Componente Principal",
    y = "Varianza Explicada (%)"
  ) +
  theme_minimal()+
  theme(
    plot.title = element_text(size = 12,),  # Reducir tamaño del título
    axis.title.x = element_text(size = 12),  # Reducir tamaño del título del eje X
    axis.title.y = element_text(size = 12),  # Reducir tamaño del título del eje Y
    axis.text = element_text(size = 1),  # Reducir tamaño de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tamaño del título de la leyenda
    legend.text = element_text(size = 12)  # Reducir tamaño del texto de la leyenda
  )

print(explained_var_plot_MixOmics)

```






# 11. PCA con prcomp

```{r}
# Perform PCA on numerical columns only
pca_res <- prcomp(featureMatrix_num, scale. = TRUE)

```




```{r}


porcentaje_varianza_explicada <- (pca_res$sdev^2 / sum(pca_res$sdev^2)) * 100
components <- seq_along(porcentaje_varianza_explicada) 


# Crear un data frame para el gráfico
var_df <- data.frame(
  Component = components,
  ExplainedVariance = porcentaje_varianza_explicada
)
 # Crear un índice para los componentes



var_df_10 <- var_df[1:10, ]

# Graficar usando ggplot2
library(ggplot2)
exaplained_var_plot_rbase<- ggplot(var_df_10, aes(x = Component, y = ExplainedVariance)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes(label = round(ExplainedVariance, 1)), vjust = -0.5, size = 3) +
    ylim(0, max(var_df_10$ExplainedVariance) * 1.1) +
  labs(
    title = "Varianza explicada",
    x = "Componente Principal",
    y = "Varianza Explicada (%)"
  ) +
  theme_minimal()+
    theme(
    plot.title = element_text(size = 12, face = "bold"),  # Reducir tamaño del título
    axis.title.x = element_text(size = 12),  # Reducir tamaño del título del eje X
    axis.title.y = element_text(size = 12),  # Reducir tamaño del título del eje Y
    axis.text = element_text(size = 10),  # Reducir tamaño de los textos de los ejes
    legend.title = element_text(size = 10),  # Reducir tamaño del título de la leyenda
    legend.text = element_text(size = 10)  # Reducir tamaño del texto de la leyenda
  )


print(exaplained_var_plot_rbase)
```






```{r}
summary(pca_res)
```

```{r}

# Now you can add back the categorical data for plotting purposes
pca_data <- as.data.frame(pca_res$x)
#pca_data$institucion <- Datos_actualizados$institucion
pca_data$fecha <- featureMatrix$fecha
pca_data$equipo <- featureMatrix$equipo
pca_data$covid<- featureMatrix$covid

```

```{r}
# pca_prcomp<- ggplot(pca_data, aes(x = PC1, y = PC2, color = equipo, shape = covid)) +
#   geom_point(size = 2) + # Tamaño de los puntos
#   labs(title = "PCA - PC1 y PC2 R base",
#        x = "Componente Principal 1",
#        y = "Componente Principal 2") +
#   scale_color_manual(values = c( "blue", "green", "purple")) + # Personaliza los colores si es necesario
#   scale_shape_manual(values = c(16, 17)) + # Personaliza las formas si es necesario
#   theme_minimal()+
#   theme_minimal()+
#     theme(
#     plot.title = element_text(size = 12, face = "bold"),  # Reducir tamaño del título
#     axis.title.x = element_text(size = 12),  # Reducir tamaño del título del eje X
#     axis.title.y = element_text(size = 12),  # Reducir tamaño del título del eje Y
#     axis.text = element_text(size = 1),  # Reducir tamaño de los textos de los ejes
#     legend.title = element_text(size = 12),  # Reducir tamaño del título de la leyenda
#     legend.text = element_text(size = 12)  # Reducir tamaño del texto de la leyenda
#   )
# print(pca_prcomp)
plot_pca <- function(data, x, y, color_by = NULL, shape_by = NULL,
                     title = "PCA", shape_manual = c(16,17),
                     size = 2, usar_paleta_auto = FALSE) {
  
  aes_base <- aes(x = {{ x }}, y = {{ y }})
  
  if (!is.null(color_by)) aes_base <- modifyList(aes_base, aes(color = .data[[color_by]]))
  if (!is.null(shape_by)) aes_base <- modifyList(aes_base, aes(shape = .data[[shape_by]]))
  
  p <- ggplot(data, aes_base) +
    geom_point(size = size) +
    labs(title = title,
         x = paste("Componente Principal", gsub("PC", "", deparse(substitute(x)))),
         y = paste("Componente Principal", gsub("PC", "", deparse(substitute(y))))) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 12, face = "bold"),
      axis.title.x = element_text(size = 12),
      axis.title.y = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 12)
    )
  
  if (!is.null(color_by) && usar_paleta_auto) {
    n_colors <- length(unique(data[[color_by]]))
    if (n_colors <= 8) {
      p <- p + scale_color_brewer(palette = "Dark2")  # Cambia si querés otra
    } else {
      p <- p + scale_color_viridis_d(option = "turbo")
    }
  }
  
  if (!is.null(shape_by)) {
    p <- p + scale_shape_manual(values = shape_manual)
  }
  
  return(p)
}

```

```{r}
# Gráficos PCA usando la función
plot_pca(pca_data, PC1, PC2, color_by = "equipo", shape_by = "covid",
         title = "PCA - PC1 y PC2 por equipo", usar_paleta_auto = TRUE)

```

```{r}
plot_pca(pca_data, PC2, PC3, color_by = "equipo", shape_by = "covid", 
         title = "PCA - PC2 vs PC3 por equipo y pos/neg", usar_paleta_auto = TRUE)
```

```{r}
plot_pca(pca_data, PC1, PC2, color_by = "fecha", shape_by = "covid",
         title = "PCA - PC1 vs PC2 por fecha",
         usar_paleta_auto = TRUE)

```

```{r}
plot_pca(pca_data, PC1, PC2, color_by = "covid", shape_by = "covid", 
         title = "PCA - PC1 vs PC2 COV POS/NEG", usar_paleta_auto = TRUE)
```


```{r}
plot_pca(pca_data, PC1, PC3, color_by = "covid", shape_by = "covid", 
         title = "PCA - PC1 vs PC3 COV POS/NEG", usar_paleta_auto = TRUE)
```

```{r}
# pca_prcomp2<-ggplot(pca_data, aes(x = PC2, y = PC3, color = equipo, shape = covid)) +
#   geom_point(size = 2) + # Tamaño de los puntos
#   labs(title = "PCA - PC2 y PC3- R base",
#        x = "Componente Principal 2",
#        y = "Componente Principal 3") +
#   scale_color_manual(values = c( "blue", "green", "purple")) + # Personaliza los colores si es necesario
#   scale_shape_manual(values = c(16, 17)) + # Personaliza las formas si es necesario
#   theme_minimal()+
#   theme_minimal()+
#     theme(
#     plot.title = element_text(size = 12, face = "bold"),  # Reducir tamaño del título
#     axis.title.x = element_text(size = 12),  # Reducir tamaño del título del eje X
#     axis.title.y = element_text(size = 12),  # Reducir tamaño del título del eje Y
#     axis.text = element_text(size = 1),  # Reducir tamaño de los textos de los ejes
#     legend.title = element_text(size = 12),  # Reducir tamaño del título de la leyenda
#     legend.text = element_text(size = 12)  # Reducir tamaño del texto de la leyenda
#   )
# 
# print(pca_prcomp2)
```

```{r}
# ggplot(pca_data, aes(x = PC1, y = PC2, color = institucion, shape = covid)) +
#   geom_point(size = 3) + # Tamaño de los puntos
#   labs(title = "PCA - Componentes Principales",
#        x = "Componente Principal 1",
#        y = "Componente Principal 2") +
#   scale_color_manual(values = c( "red","blue", "green", "purple")) + # Personaliza los colores si es necesario
#   scale_shape_manual(values = c(16, 17)) + # Personaliza las formas si es necesario
#   theme_minimal() # O puedes usar otro tema si prefieres
```

```{r}
# ggplot(pca_data, aes(x = PC1, y = PC2, color = fecha, shape = covid)) +
#   geom_point(size = 3) + # Tamaño de los puntos
#   labs(title = "PCA - Componentes Principales",
#        x = "Componente Principal 1",
#        y = "Componente Principal 2") +
#   scale_color_manual(values = c( "red", "blue", "green", "purple", "orange", "pink", "yellow", "cyan", "brown", "magenta", "gray", "black", "darkgreen", "darkblue")) +
#   scale_shape_manual(values = c(16, 17)) +
#   theme_minimal()

```

```{r}
# valores_unicos_fecha <- unique(featureMatrix[,"fecha"])
# 
# # Mostrar los valores únicos
# print(valores_unicos_fecha)
```

```{r}
# pos_neg<- ggplot(pca_data, aes(x = PC1, y = PC2, color=covid, shape = covid)) +
#   geom_point(size = 2) + # Tamaño de los puntos
#   labs(title = "PCA - COV POS/NEG",
#        x = "Componente Principal 1",
#        y = "Componente Principal 2") +
#  scale_color_manual(values = c( "red","blue"))+
#   scale_shape_manual(values = c(16, 17)) +
#   theme_minimal()+
#     theme(
#     plot.title = element_text(size = 12, face = "bold"),  # Reducir tamaño del título
#     axis.title.x = element_text(size = 12),  # Reducir tamaño del título del eje X
#     axis.title.y = element_text(size = 12),  # Reducir tamaño del título del eje Y
#     axis.text = element_text(size = 1),  # Reducir tamaño de los textos de los ejes
#     legend.title = element_text(size = 12),  # Reducir tamaño del título de la leyenda
#     legend.text = element_text(size = 12)  # Reducir tamaño del texto de la leyenda
#   )
# 
# 
# print(pos_neg)
```

```{r}
# ggplot(pca_data, aes(x = pca_data$PC1, y = pca_data$PC3, color=covid, shape = covid)) +
#   geom_point(size = 3) + # Tamaño de los puntos
#   labs(title = "PCA - Componentes Principales",
#        x = "Componente Principal 1",
#        y = "Componente Principal 3") +
#  scale_color_manual(values = c( "red","blue"))+
#   scale_shape_manual(values = c(16, 17)) +
#   theme_minimal()
```







# 12. UMAP

```{r}
library(umap)
set.seed(42)

```

```{r}

library(uwot)
```

```{r}
set.seed(123)
umap_result <- umap(featureMatrix_num)
```

```{r}
umap_df <- as.data.frame(umap_result)
colnames(umap_df) <- c("V1", "V2")
```

```{r}
#umap_df$institucion <- Datos_actualizados$institucion
umap_df$fecha <- featureMatrix$fecha
umap_df$equipo <- featureMatrix$equipo
umap_df$covid<- featureMatrix$covid
```

```{r}
plot_umap <- function(data, x, y, color_by = NULL, shape_by = NULL,
                      title = "UMAP", shape_manual = c(16, 17), size = 2,
                      usar_paleta_auto = FALSE, color_manual = NULL) {

  aes_base <- aes(x = {{ x }}, y = {{ y }})
  if (!is.null(color_by)) aes_base <- modifyList(aes_base, aes(color = .data[[color_by]]))
  if (!is.null(shape_by)) aes_base <- modifyList(aes_base, aes(shape = .data[[shape_by]]))

  p <- ggplot(data, aes_base) +
    geom_point(size = size) +
    labs(title = title,
         x = deparse(substitute(x)),
         y = deparse(substitute(y))) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 16),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 12)
    )

  if (!is.null(color_manual)) {
    p <- p + scale_color_manual(values = color_manual)
  } else if (!is.null(color_by) && usar_paleta_auto) {
    n_colors <- length(unique(data[[color_by]]))
    if (n_colors <= 8) {
      p <- p + scale_color_brewer(palette = "Dark2")
    } else {
      p <- p + scale_color_viridis_d(option = "turbo")
    }
  }

  if (!is.null(shape_by)) {
    p <- p + scale_shape_manual(values = shape_manual)
  }

  return(p)
}

```



```{r}
plot_umap(umap_df, V1, V2, color_by = "equipo", shape_by = "covid",
          title = "UMAP base", usar_paleta_auto = TRUE)

```


```{r}
plot_umap(umap_df, V1, V2, color_by = "covid", shape_by = "covid",
          title = "UMAP para Detección de Efectos de Batch", usar_paleta_auto = TRUE)

```

```{r}
UMAP_base<-plot_umap(umap_df, V1, V2, color_by = "fecha", shape_by = "covid",
          title = "UMAP por fecha", usar_paleta_auto = TRUE)
UMAP_base
```




```{r}

# UMAP_base<- ggplot(umap_df, aes(x = V1, y = V2, color = equipo, shape=covid)) +
#   geom_point(size = 2) +
#   labs(title = "UMAP base", x = "UMAP1", y = "UMAP2") +
#   theme_minimal()+
#   theme(
#     plot.title = element_text(size = 16),  # Reducir tamaño del título
#     axis.title.x = element_text(size = 14),  # Reducir tamaño del título del eje X
#     axis.title.y = element_text(size = 14),  # Reducir tamaño del título del eje Y
#     axis.text = element_text(size = 10),  # Reducir tamaño de los textos de los ejes
#     legend.title = element_text(size = 12),  # Reducir tamaño del título de la leyenda
#     legend.text = element_text(size = 12)  # Reducir tamaño del texto de la leyenda
#   )
#     
#     
#   
#     print(UMAP_base)
```

```{r}

# ggplot(umap_df, aes(x = V1, y = V2, color = covid, shape=covid)) +
#   geom_point() +
#   labs(title = "UMAP para Detección de Efectos de Batch", x = "UMAP1", y = "UMAP2") +
#     scale_shape_manual(values = c(16, 17)) +
#   theme_minimal()

```

```{r}
# ggplot(umap_df,aes(x = V1, y = V2, color = fecha, shape=covid)) +
#   geom_point(size = 3) + # Tamaño de los puntos
#   labs(title = "UMAP POR FECHA",
#        x = "UMAP 1",
#        y = "UMAP 2") +
#   scale_color_manual(values = c( "red", "blue", "green", "purple", "orange", "pink", "yellow", "cyan", "brown", "magenta", "gray", "black", "darkgreen", "darkblue")) +
#   scale_shape_manual(values = c(16, 17)) +
#   theme_minimal() # O puedes usar otro tema si prefieres
```

```{r}
#UMAP intenta encontrar una representación (no lineal) de pocas dimensiones de los datos que preserve las distancias entre cada puntos y sus vecinos en el espacio multi-dimensional

#Comparison among PCA, t-SNE and UMAP : https://aurigait.com/blog/blog-easy-explanation-of-dimensionality-reduction-and-techniques/



library(umap)


# Ajustar parámetros directamente en la función umap
umap_v2 <- umap(featureMatrix_num, n_neighbors = 15, metric = "euclidean", min_dist = 0.5)

# Verificar la estructura del objeto umap_v2
str(umap_v2) # Esto te mostrará la estructura para asegurarte de que layout es un componente válido.

# Si la estructura es correcta, continuar con la conversión a dataframe
umap_coor2 <- as.data.frame(umap_v2)

# Asignar nombres de columnas
colnames(umap_coor2) <- c("UMAP1", "UMAP2")

# Añadir las columnas con los metadatos (COVID, equipo, etc.)
umap_coor2$covid <- featureMatrix$covid
umap_coor2$equipo <- featureMatrix$equipo

UMAP_ajustado<-plot_umap(umap_coor2, UMAP1, UMAP2, color_by  = "equipo", shape_by = "covid",
          title = "UMAP2 por equipo", usar_paleta_auto = TRUE)
UMAP_ajustado


```



```{r}

library(patchwork)
combined_plot <- (
  UMAP_base + UMAP_ajustado
)

# Agregar títulos a cada gráfico
combined_plot_UMAP <- combined_plot + 
  plot_annotation(
    title = "UMAP",
    tag_levels = "A"  # Etiquetas A, B, C, ...
  ) + 
  plot_layout(guides = "collect")  # Para combinar las leyendas, si hay

# Mostrar el gráfico combinado
print(combined_plot_UMAP)


```
```{r}
ggsave(
  filename = "combined_plot_UMAP.png",
  plot = combined_plot_UMAP,
  width = 12,
  height = 10,
  dpi = 300
)
```



# 13. t-SNE

```{r}
#tsne
library(Rtsne)
library(ggplot2)
library(readxl)
library(RColorBrewer)
```

```{r}
?Rtsne
```

```{r}
set.seed(9)
tsne_model <- Rtsne(featureMatrix_num, check_duplicates=FALSE, 
                      pca=TRUE, perplexity=30, theta=0.5, dims=3)
```

```{r}
#tsne_model$institucion <- Datos_actualizados$institucion
tsne_model$fecha <- Datos_actualizados$fecha
tsne_model$equipo <- Datos_actualizados$equipo
tsne_model$covid<- Datos_actualizados$PCR.Cov
```

```{r}
tsne_data <- as.data.frame(tsne_model$Y)
colnames(tsne_data) <- c("Dim1", "Dim2","Dim3")
```

```{r}
#tsne_data$institucion <- Datos_actualizados$institucion
tsne_data$fecha <- featureMatrix$fecha
tsne_data$equipo <- featureMatrix$equipo
tsne_data$covid<- featureMatrix$covid
```

```{r}
# tSNE<-ggplot(tsne_data, aes(x=Dim1, y=Dim2, color=equipo, shape = covid)) +
#   geom_point(size=2, alpha=0.7) +
#   ggtitle("t-SNE 1 y 2") +
#   theme_minimal(base_size=15) +
#     theme(
#     plot.title = element_text(size = 16),  # Reducir tamaño del título
#     axis.title.x = element_text(size = 14),  # Reducir tamaño del título del eje X
#     axis.title.y = element_text(size = 14),  # Reducir tamaño del título del eje Y
#     axis.text = element_text(size = 10),  # Reducir tamaño de los textos de los ejes
#     legend.title = element_text(size = 12),  # Reducir tamaño del título de la leyenda
#     legend.text = element_text(size = 12)  # Reducir tamaño del texto de la leyenda
#   )
#   scale_color_manual(values=c("#D32F2F", "#1976D2", "#388E3C"))  # Use a color palette
#   print(tSNE)
# ```
# 
# 
# 
# ```{r}
# tSNE2<-ggplot(tsne_data, aes(x=Dim2, y=Dim3, color=equipo, shape=covid)) +
#   geom_point(size=2, alpha=0.7) +
#   ggtitle("t-SNE 2 y 3") +
#   theme_minimal(base_size=15) +
#     theme(
#     plot.title = element_text(size = 16),  # Reducir tamaño del título
#     axis.title.x = element_text(size = 14),  # Reducir tamaño del título del eje X
#     axis.title.y = element_text(size = 14),  # Reducir tamaño del título del eje Y
#     axis.text = element_text(size = 10),  # Reducir tamaño de los textos de los ejes
#     legend.title = element_text(size = 12),  # Reducir tamaño del título de la leyenda
#     legend.text = element_text(size = 12)  # Reducir tamaño del texto de la leyenda
#   )
#   scale_color_manual(values=c("#D32F2F", "#1976D2", "#388E3C"))  # Use a color palette
#   print(tSNE2)
```

```{r}
plot_tsne <- function(data, x, y, color_by = NULL, shape_by = NULL,
                      title = "t-SNE", shape_manual = c(16, 17), size = 2, alpha = 0.7,
                      usar_paleta_auto = FALSE, color_manual = NULL) {
  
  aes_base <- aes(x = {{ x }}, y = {{ y }})
  if (!is.null(color_by)) aes_base <- modifyList(aes_base, aes(color = .data[[color_by]]))
  if (!is.null(shape_by)) aes_base <- modifyList(aes_base, aes(shape = .data[[shape_by]]))
  
  p <- ggplot(data, aes_base) +
    geom_point(size = size, alpha = alpha) +
    ggtitle(title) +
    theme_minimal(base_size = 15) +
    theme(
      plot.title = element_text(size = 16),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 12)
    )
  
  if (!is.null(color_manual)) {
    p <- p + scale_color_manual(values = color_manual)
  } else if (!is.null(color_by) && usar_paleta_auto) {
    n_colors <- length(unique(data[[color_by]]))
    if (n_colors <= 8) {
      p <- p + scale_color_brewer(palette = "Dark2")
    } else {
      p <- p + scale_color_viridis_d(option = "turbo")
    }
  }
  
  if (!is.null(shape_by)) {
    p <- p + scale_shape_manual(values = shape_manual)
  }
  
  return(p)
}

```


```{r}


library(patchwork)

# Crear gráficos con la función
g1 <- plot_tsne(tsne_data, Dim1, Dim2, color_by = "equipo", shape_by = "covid", 
                title = "t-SNE 1 y 2", usar_paleta_auto = TRUE)

g2 <- plot_tsne(tsne_data, Dim2, Dim3, color_by = "equipo", shape_by = "covid", 
                title = "t-SNE 2 y 3", usar_paleta_auto = TRUE)

# Combinarlos con patchwork
combined_plot_tSNE_carga <- (g1 | g2) +
  plot_annotation(
    title = "t-SNE por equipo",
    tag_levels = "A"
  ) +
  plot_layout(guides = "collect")

# Mostrar
print(combined_plot_tSNE_carga)



```




```{r}
ggsave(
  filename = "combined_plot_tSNE_carga.png",
  plot = combined_plot_tSNE_carga,
  width = 12,
  height = 10,
  dpi = 300
)
```

# 14. Imposibilidad de analizar Cts:

```{r}

cantidad_sd_0_na <- sum(Datos_actualizados$Carga %in% c("SD", "0") | is.na(Datos_actualizados$Carga))

# Mostrar el resultado
cantidad_sd_0_na
```

```{r}
valores_unicos <- unique(Datos_actualizados$Carga)
print(valores_unicos)

```
```{r}
frecuencias <- table(Datos_actualizados$Carga)
print(frecuencias)
```



```{r}
library(dplyr)
# Convertir las variables categóricas en factores
Datos_actualizados <- Datos_actualizados[,c(1:7)] %>%
  mutate(across(c(PCR.Cov, fecha, equipo), as.factor))

# Convertir la matriz de datos a una matriz numérica si aún no lo es
featureMatrix_num <- as.matrix(featureMatrix_num)

```

```{r}
# Prueba de normalidad: Propósito: Verificar si las puntuaciones de los componentes principales siguen una distribución normal.
shapiro.test(pca.before$X[, 1])

# Prueba de homocedasticidad: Propósito: Evaluar si las varianzas entre grupos (definidos por un factor como PCR.Cov) son iguales. Algunas pruebas estadísticas (como ANOVA) requieren homogeneidad de varianzas.

library(car)
leveneTest(pca.before$X[, 1] ~ featureMatrix$covid)

```




```{r}
# Inicializar un dataframe para almacenar los resultados
shapiro_results <- data.frame(Componente = integer(), PValue = numeric(), stringsAsFactors = FALSE)

# Iterar sobre cada componente principal
for (i in 1:ncol(pca.before$X)) {
  p_value <- shapiro.test(pca.before$X[, i])$p.value
  shapiro_results <- rbind(shapiro_results, data.frame(Componente = i, PValue = p_value))
}

# Visualizar los resultados
print(shapiro_results)

```

# 15. Kruskal wallis
para detectar el peso de cada factor en el efecto batch. Propósito: Evaluar si las puntuaciones del PCA difieren significativamente entre los niveles de un factor (como PCR.Cov, fecha o equipo).
Kruskal-Wallis es una prueba no paramétrica que no asume normalidad, lo que la hace adecuada si los datos no pasan la prueba de Shapiro-Wilk.

```{r}
# Cargar librerías necesarias
library(ggplot2)
library(dplyr)

# 1. Realizar PCA
pca_result <- prcomp(featureMatrix_num, scale. = TRUE)

# 2. Obtener las puntuaciones de los componentes principales
pca_scores <- pca_result$x

Datos_actualizados <- as.data.frame(Datos_actualizados)

# 2️⃣ Creo vector auxiliar con los números (los que no son número quedarán NA en num, PERO no toco carga)
num <- suppressWarnings(as.numeric(as.character(Datos_actualizados$Carga)))

# 3️⃣ Recategorizo SOLO los que son números
Datos_actualizados$Carga[!is.na(num) & num < 24]              <- "High"
Datos_actualizados$Carga[!is.na(num) & num >= 24 & num <= 28] <- "Int"
Datos_actualizados$Carga[!is.na(num) & num > 28]              <- "Low"

# 4️⃣ Filtro la columna carga para quedarme con lo que quiero:
# High, Int, Low, SD (NO me traigo NA ni otras cosas raras)
featureMatrix <- featureMatrix %>%
  filter(carga %in% c("High", "Int", "Neg"))
datos_filtrados <- Datos_actualizados %>%
  filter(Carga %in% c("High", "Int", "Neg"))

# 3. Agregar los resultados PCA al dataframe de metadatos
metadata_pca <- cbind(datos_filtrados[,c(4:7)], pca_scores)



# 4. Función para realizar Kruskal-Wallis sobre los componentes principales
kruskal_pca <- function(pca_scores, metadata, factor) {
  results <- data.frame()
  for (i in 1:ncol(pca_scores)) {  # Para cada componente principal
    pca_component <- pca_scores[, i]  # Extraer la puntuación del componente
    model <- kruskal.test(pca_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
    factor_effect <- model$p.value  # Obtener el p-valor
    results <- rbind(results, data.frame(PC = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
  }
  return(results)
}

# 5. Lista de factores que quieres analizar

# 5. Lista de factores que quieres analizar
factors <- c("PCR.Cov", "fecha", "equipo")

# Ejecutar la función para cada factor y combinar los resultados
kruskal_results <- do.call(rbind, lapply(factors, function(f) kruskal_pca(pca_scores, datos_filtrados, f)))

# 6. Resumir el p-valor medio para cada factor
factor_summary <- kruskal_results %>%
  group_by(Factor) %>%
  summarise(MeanLogPValue = -log10(mean(PValue)))

pca_kruskal<- ggplot(factor_summary, aes(x = reorder(Factor, MeanLogPValue), y = MeanLogPValue, fill = Factor)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Importancia de los Factores PCA",
       x = "Factor",
       y = "-log10(P-valor Medio)",
       fill = "Factor")
    theme(
    plot.title = element_text(size = 30),  # Reducir tamaño del título
    axis.title.x = element_text(size = 26),  # Reducir tamaño del título del eje X
    axis.title.y = element_text(size = 26),  # Reducir tamaño del título del eje Y
    axis.text = element_text(size = 18),  # Reducir tamaño de los textos de los ejes
    legend.title = element_text(size = 24),  # Reducir tamaño del título de la leyenda
    legend.text = element_text(size = 24)  # Reducir tamaño del texto de la leyenda
  )
print(pca_kruskal)
```

# 16. Kruskal wallis 
para detectar el peso de cada factor en el efecto batch en analisis de UMAP

```{r}
# Prueba de normalidad Shapiro-Wilk en la primera dimensión de UMAP
shapiro.test(umap_v2[, 1])

# Prueba de normalidad Shapiro-Wilk en la segunda dimensión de UMAP
shapiro.test(umap_v2[, 2])


```

```{r}

umap_scores <- umap_v2  # Tomar el resultado de UMAP directamente

# Luego sigues con el mismo análisis
metadata_umap <-cbind(datos_filtrados[,c(4:7)] , umap_scores)
 

# Función para realizar Kruskal-Wallis sobre las dimensiones de UMAP
kruskal_umap <- function(umap_scores, metadata, factor) {
  results <- data.frame()
  for (i in 1:ncol(umap_scores)) {  # Para cada dimensión de UMAP
    umap_component <- umap_scores[, i]  # Extraer la puntuación de la dimensión
    model <- kruskal.test(umap_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
    factor_effect <- model$p.value  # Obtener el p-valor
    results <- rbind(results, data.frame(UMAP_Dim = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
  }
  return(results)
}

# Lista de factores que quieres analizar
factors <- c("PCR.Cov", "fecha", "equipo")



# Ejecutar la función para cada factor y combinar los resultados


kruskal_results_umap <- do.call(rbind, lapply(factors, function(f) kruskal_umap(umap_scores, datos_filtrados, f)))

# Resumir el p-valor medio para cada factor
factor_summary_umap <- kruskal_results_umap %>%
  group_by(Factor) %>%
  summarise(MeanPValue = mean(PValue))

# Visualizar los resultados en un gráfico de barras
factor_summary <- kruskal_results_umap %>%
  group_by(Factor) %>%
  summarise(MeanLogPValue = -log10(mean(PValue)))

UMAP_kruskal<- ggplot(factor_summary, aes(x = reorder(Factor, MeanLogPValue), y = MeanLogPValue, fill = Factor)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Importancia de los Factores-UMAP",
       x = "Factor",
       y = "-log10(P-valor Medio)",
       fill = "Factor")
    theme(
    plot.title = element_text(size = 30),  # Reducir tamaño del título
    axis.title.x = element_text(size = 26),  # Reducir tamaño del título del eje X
    axis.title.y = element_text(size = 26),  # Reducir tamaño del título del eje Y
    axis.text = element_text(size = 18),  # Reducir tamaño de los textos de los ejes
    legend.title = element_text(size = 24),  # Reducir tamaño del título de la leyenda
    legend.text = element_text(size = 24)  # Reducir tamaño del texto de la leyenda
  )
print(UMAP_kruskal)
```



```{r}
library(patchwork)
combined_plot <- (
  pca_kruskal+UMAP_kruskal
)

# Agregar títulos a cada gráfico
combined_plot_kruskal <- combined_plot + 
  plot_annotation(
    title = "Influencia de los factores en los datos",
    tag_levels = "A"  # Etiquetas A, B, C, ...
  ) + 
  plot_layout(guides = "collect")  # Para combinar las leyendas, si hay

# Mostrar el gráfico combinado
print(combined_plot_kruskal)
```


```{r}
ggsave(
  filename = "combined_plot_kruskal.png",
  plot = combined_plot_kruskal,
  width = 12,
  height = 10,
  dpi = 400
)
```



```{r}
dim(featureMatrix_num)
dim(Datos_actualizados)
```





## 17 Clustering



```{r}
library(dendextend)

distancias <- dist(featureMatrix_num)

# Realizar el clustering jerárquico
hc <- hclust(distancias, method = "ward.D2")

# Convierte el dendrograma a un objeto de dendextend
dend <- as.dendrogram(hc)

# Crea un vector de colores basado en PCR.cov
# Cambia "PCR.cov" a la columna adecuada de Datos_actualizados
label_colors <- as.factor(Datos_actualizados$PCR.Cov)
palette <- c("red", "blue") # Cambia los colores si hay más de 2 categorías
label_colors <- palette[label_colors]

# Aplica los colores a las etiquetas
dend <- dend %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.5) # Ajusta el tamaño de las etiquetas

# Dibuja el dendrograma
png("dendrograma_COVID.png", width = 800, height = 600)
plot(dend, main = "Dendrograma por resultado COVID")
legend("topright",
       legend = c("COVID Negativo", "COVID Positivo"),
       fill = c("red", "blue"),
       border = "black",
       bty = "n",
       cex = 0.8)
dev.off() 

COVID_clustering<-plot(dend, main = "Dendrograma por resultado COVID")
legend("topright",           # Posición de la leyenda
       legend = c("COVID Negativo", "COVID Positivo"), # Textos de la leyenda
       fill = c("red", "blue"),                        # Colores de la leyenda
       border = "black",                               # Borde de las cajas de color
       bty = "n",                                      # Sin caja alrededor de la leyenda
       cex = 0.8)    


print(COVID_clustering)
```



```{r}
table(Datos_actualizados$PCR.Cov, label_colors)

```


 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_pos <- datos_filtrados$PCR.Cov == "Cov.Pos"
featureMatrix_cov_pos <- featureMatrix_num[indices_cov_pos, ]
datos_filtrados_cov_pos <- datos_filtrados[indices_cov_pos, ]

# Verificar que los datos estén filtrados correctamente
dim(featureMatrix_cov_pos)
table(datos_filtrados_cov_pos$equipo)


# Realizar el clustering jerárquico
dist_featureMatriz_cov_pos <- dist(featureMatrix_cov_pos)
hc_cov_pos <- hclust(dist_featureMatriz_cov_pos, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_pos <- as.dendrogram(hc_cov_pos)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- factor(datos_filtrados_cov_pos$equipo, levels = c("CR", "HC", "Malbran"))
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]

# Personalizar el dendrograma

dend_cov_pos <- dend_cov_pos %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tamaño de las etiquetas

png("dendrograma_COVID.pos.png", width = 800, height = 600)
plot(dend_cov_pos, main = "Clustering de Positivos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")
dev.off()

# Visualizar el dendrograma
plot(dend_cov_pos, main = "Clustering de Positivos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")

```


 
 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_neg <- datos_filtrados$PCR.Cov == "Cov.Neg"
featureMatrix_cov_neg <- featureMatrix_num[indices_cov_neg, ]
datos_filtrados_cov_neg <- datos_filtrados[indices_cov_neg, ]

# Verificar que los datos estén filtrados correctamente
dim(featureMatrix_cov_neg)
table(datos_filtrados_cov_neg$equipo)

# Realizar el clustering jerárquico
dist_featureMatriz_cov_neg <- dist(featureMatrix_cov_neg)
hc_cov_neg <- hclust(dist_featureMatriz_cov_neg, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_neg <- as.dendrogram(hc_cov_neg)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(datos_filtrados_cov_neg$equipo)
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]

# Personalizar el dendrograma
dend_cov_neg <- dend_cov_neg %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tamaño de las etiquetas


png("dendrograma_COVID.neg.png", width = 800, height = 600)
plot(dend_cov_neg, main = "Clustering de Negativos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")
dev.off()

# Visualizar el dendrograma
plot(dend_cov_neg, main = "Clustering de Negativos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")

```
 



 
```{r}

# Extraer solo las filas que corresponden a los equipos en featureMatrix_num
# Asegúrate de que Datos_actualizados$equipo tenga valores válidos para subindexar.
featureMatrix_equipo <- featureMatrix_num

# Verificar que los datos estén filtrados correctamente
table(datos_filtrados$equipo)

# Calcular la matriz de distancias y realizar el clustering jerárquico
dist_featureMatriz_eq <- dist(featureMatrix_equipo)
hc_eq <- hclust(dist_featureMatriz_eq, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_eq <- as.dendrogram(hc_eq)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(datos_filtrados$equipo)
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]           # Asignar colores por equipo

# Personalizar el dendrograma
dend_eq <- dend_eq %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tamaño de las etiquetas

png("dendrograma_COVID.equipo.png", width = 800, height = 600)
plot(dend_eq, main = "Clustering Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")
dev.off()

# Visualizar el dendrograma
plot(dend_eq, main = "Clustering Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")


```
```{r}


datos_filtrados$fecha <- as.factor(datos_filtrados$fecha)

# Matriz de características (featureMatrix_num)
featureMatrix_fecha <- featureMatrix_num

# Calcular la matriz de distancias y realizar el clustering jerárquico
dist_featureMatriz_fecha <- dist(featureMatrix_fecha)
hc_fecha <- hclust(dist_featureMatriz_fecha, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_fecha <- as.dendrogram(hc_fecha)

# Crear un vector de colores para las etiquetas basado en 'fecha'
fecha_factor <- datos_filtrados$fecha
palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
label_colors <- palette[fecha_factor]           # Asignar colores por fecha

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'fecha'
  set("labels_cex", 0.6)               # Ajusta el tamaño de las etiquetas

# Visualizar el dendrograma
library(RColorBrewer)

# Crear una paleta más contrastante
num_colores <- length(levels(fecha_factor))
palette <- brewer.pal(n = min(num_colores, 12), name = "Paired") # Máx. 12 colores contrastantes
if (num_colores > 12) {
  palette <- colorRampPalette(brewer.pal(12, "Paired"))(num_colores) # Extender paleta si es necesario
}

# Aplicar los nuevos colores
label_colors <- palette[fecha_factor]

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.6)

png("dendrograma_fecha.png", width = 800, height = 600)
plot(dend_fecha, main = "Clustering Diferenciado por Fecha")
legend(
  "topright",
  legend = levels(fecha_factor),
  col = palette,
  pch = 19,
  title = "Fecha",
  cex = 0.7,
  bty = "n"
)
dev.off()

# Dibujar el dendrograma
plot(dend_fecha, main = "Clustering Diferenciado por Fecha")
legend(
  "topright",
  legend = levels(fecha_factor),
  col = palette,
  pch = 19,
  title = "Fecha",
  cex = 0.7,
  bty = "n"
)


```


 
 
```{r}
plot_dendrogram <- function(data_matrix, labels_vector, titulo = "Dendrograma", nombre_png = NULL,
                            colores = NULL, cex = 0.6, method = "ward.D2", titulo_leyenda = NULL,
                            palette_type = c("auto", "brewer")) {

  palette_type <- match.arg(palette_type)

  # Calcular matriz de distancias
  distancias <- dist(data_matrix)

  # Clustering jerárquico
  hc <- hclust(distancias, method = method)
  dend <- as.dendrogram(hc)

  # Preparar factores y colores
  factor_labels <- as.factor(labels_vector)
  n_levels <- length(levels(factor_labels))

  # Selección de paleta de colores
  if (is.null(colores)) {
    if (palette_type == "brewer") {
      if (n_levels <= 9) {
        colores <- RColorBrewer::brewer.pal(n_levels, "Set3")
      } else {
        colores <- colorRampPalette(RColorBrewer::brewer.pal(9, "Set3"))(n_levels)
      }
    } else {
      colores <- rainbow(n_levels)
    }
  }

  label_colors <- colores[factor_labels]

  # Asignar colores y tamaño de etiquetas
  dend <- dend %>%
    set("labels_col", label_colors) %>%
    set("labels_cex", cex)

  # Ajustar márgenes para evitar superposición
  old_par <- par(no.readonly = TRUE)  # guardar config previa
  par(mar = c(10, 4, 4, 2))            # ampliar margen inferior

  # Título de la leyenda
  if (is.null(titulo_leyenda)) {
    titulo_leyenda <- deparse(substitute(labels_vector))
  }

  # Exportar si se especificó archivo PNG
  if (!is.null(nombre_png)) {
    png(nombre_png, width = 1800, height = 1000, res = 150)
    plot(dend, main = titulo, las = 2)
    legend("topright", legend = levels(factor_labels), col = colores, pch = 19,
           title = titulo_leyenda, cex = 0.8, bty = "n")
    dev.off()
  }

  # Mostrar en pantalla
  plot(dend, main = titulo, las = 2)
  legend("topright", legend = levels(factor_labels), col = colores, pch = 19,
         title = titulo_leyenda, cex = 0.8, bty = "n")

  # Restaurar configuración gráfica
  par(old_par)

  invisible(dend)
}

```


# ------------------ USO DE LA FUNCIÓN OPTIMIZADA ------------------

```{r}

# Clustering por resultado COVID
COVID<-datos_filtrados$PCR.Cov
plot_dendrogram(featureMatrix_num, COVID,
                titulo = "Dendrograma por resultado COVID",
                nombre_png = "dendrograma_carga.png")




# Clustering por equipo en positivos
equipo_covidpos <- datos_filtrados$equipo[indices_cov_pos]
indices_cov_pos <- datos_filtrados$PCR.Cov == "Cov.Pos"
plot_dendrogram(featureMatrix_num[indices_cov_pos, ],
                equipo_covidpos,
                titulo = "Clustering Positivos por Equipo",
                nombre_png = "dendrograma_soloCOVID.pos.png")


equipo_covidneg <- datos_filtrados$equipo[indices_cov_neg]
# Clustering por equipo en negativos
indices_cov_neg <- datos_filtrados$PCR.Cov == "Cov.Neg"
plot_dendrogram(featureMatrix_num[indices_cov_neg, ],
                equipo_covidneg,
                titulo = "Clustering Negativos por Equipo",
                nombre_png = "dendrograma_soloCOVID.neg.png")

# Clustering por equipo en toda la base
equipo<-datos_filtrados$equipo
plot_dendrogram(featureMatrix_num, equipo,
                titulo = "Clustering Diferenciado por Equipo",
                nombre_png = "dendrograma_soloCOVID.equipo.png")

# Clustering por fecha
fecha<-datos_filtrados$fecha
plot_dendrogram(featureMatrix_num, fecha,
                titulo = "Clustering Diferenciado por Fecha",
                nombre_png = "dendrograma_fecha_solocovid.png",
                              palette_type = "brewer")


```
# 18.Correcion efecto batch EQUIPO: Combat

```{r}
# Cargar el paquete sva
library(sva)

```

```{r}
# Ejemplo de datos de entrada
data_matrix <- featureMatrix_num  # Tu matriz de datos
metadata <- datos_filtrados    # Dataframe de metadatos con información de batch
batch_info <- metadata$equipo      # Vector con la información de batch

```

```{r}
# Verificar si 'batch_info' es un factor o un vector de caracteres
str(batch_info)

# Si es necesario, convertirlo a un factor
batch_info <- factor(batch_info)


```

```{r}
sum(is.na(data_matrix))  # Revisa si hay valores NA en la matriz

```



```{r}

combat_corrected_equipo <- ComBat(
  dat = t(data_matrix),             
  batch = batch_info,            # Información de batch
  par.prior = TRUE,
  prior.plots = FALSE
)



```



```{r}
# Transponer de vuelta los datos corregidos
combat_corrected_equipo <- t(combat_corrected_equipo)

# Guardar la matriz corregida
write.csv(combat_corrected_equipo, "corrected_featureMatrix.csv")

```



```{r}
save(combat_corrected_equipo, file = "correccion_combat_equipo.rda")

```



```{r}
# Asignar colores manualmente en función de batch_info
batch_colors <- as.factor(batch_info)   # Convertir batch_info a factor
levels(batch_colors)  # Ver los niveles de batch_info

# Definir colores manualmente (puedes cambiar los nombres de niveles y colores)
col_vector <- batch_colors
levels(col_vector) <- c("red", "blue", "green")  # Asigna colores a cada batch
```

```{r}
equipo_colors <- as.factor(metadata$equipo)  # Convertir 'equipo' a factor

# Asignar colores
palette_colors <- rainbow(length(unique(equipo_colors)))  # Colores únicos
col_vector <- palette_colors[equipo_colors]
```

```{r}
pca_after <- prcomp(combat_corrected_equipo, scale. = TRUE)


png("PCA post COMBAT.png", width = 800, height = 600)
# Plot PCA después de la corrección
plot(pca_after$x[,1:2], col = col_vector, main = "PCA base después de la corrección")
legend("topright", 
       legend = levels(batch_colors), 
       col = palette_colors, 
       pch = 16, 
       title = "Batch")
dev.off()


# Plot PCA después de la corrección
plot(pca_after$x[,1:2], col = col_vector, main = "PCA base después de la corrección")
legend("topright", 
       legend = levels(batch_colors), 
       col = palette_colors, 
       pch = 16, 
       title = "Batch")
```


```{r}
# Verifica la consistencia de las dimensiones
stopifnot(nrow(pca_after$x) == nrow(datos_filtrados))

# Define los colores por equipo
palette_colors <- c("red", "blue", "green")  # Cambia según los equipos
col_vector <- palette_colors[as.factor(datos_filtrados$equipo)]

# Define las formas por resultado COVID
pch_vector <- ifelse(Datos_actualizados$PCR.Cov == "Cov.Pos", 16, 17)


png("PCA_combat.png", width = 1200, height = 800)
plot(pca_after$x[, 1:2], 
     col = col_vector, 
     pch = pch_vector, 
     main = "PCA diferenciado por equipo y resultado COVID",
     xlab = "PC1", 
     ylab = "PC2")

# Leyenda por equipo
legend("topright", 
       legend = levels(as.factor(Datos_actualizados$equipo)), 
       col = palette_colors, 
       pch = 16, 
       title = "Equipo")

# Leyenda por resultado COVID
legend("topleft", 
       legend = c("COVID Positivo", "COVID Negativo"), 
       col = "black", 
       pch = c(16, 17), 
       title = "Resultado COVID")
dev.off()



# Grafica el PCA con diferenciación por equipo y COVID
plot(pca_after$x[, 1:2], 
     col = col_vector, 
     pch = pch_vector, 
     main = "PCA diferenciado por equipo y resultado COVID",
     xlab = "PC1", 
     ylab = "PC2")

# Leyenda por equipo
legend("topright", 
       legend = levels(as.factor(Datos_actualizados$equipo)), 
       col = palette_colors, 
       pch = 22, 
       title = "Equipo")

# Leyenda por resultado COVID
legend("topleft", 
       legend = c("COVID Positivo", "COVID Negativo"), 
       col = "black", 
       pch = c(16, 17), 
       title = "Resultado COVID")


```

```{r}
# Verifica la consistencia de las dimensiones
stopifnot(nrow(pca_after$x) == nrow(datos_filtrados))

# Define los colores por equipo
palette_colors <- c("red", "blue", "green")  # Cambia según los equipos
col_vector <- palette_colors[as.factor(datos_filtrados$equipo)]

# Define las formas por resultado COVID
pch_vector <- ifelse(datos_filtrados$PCR.Cov == "Cov.Pos", 16, 17)


png("PCA_combat.png", width = 1200, height = 800)
plot(pca_after$x[, 2:3], 
     col = col_vector, 
     pch = pch_vector, 
     main = "PCA diferenciado por equipo y resultado COVID",
     xlab = "PC2", 
     ylab = "PC3")

# Leyenda por equipo
legend("topright", 
       legend = levels(as.factor(Datos_actualizados$equipo)), 
       col = palette_colors, 
       pch = 16, 
       title = "Equipo")

# Leyenda por resultado COVID
legend("topleft", 
       legend = c("COVID Positivo", "COVID Negativo"), 
       col = "black", 
       pch = c(16, 17), 
       title = "Resultado COVID")
dev.off()



# Grafica el PCA con diferenciación por equipo y COVID
plot(pca_after$x[, 2:3], 
     col = col_vector, 
     pch = pch_vector, 
     main = "PCA diferenciado por equipo y resultado COVID",
     xlab = "PC2", 
     ylab = "PC3")

# Leyenda por equipo
legend("topright", 
       legend = levels(as.factor(Datos_actualizados$equipo)), 
       col = palette_colors, 
       pch = 22, 
       title = "Equipo")

# Leyenda por resultado COVID
legend("topleft", 
       legend = c("COVID Positivo", "COVID Negativo"), 
       col = "black", 
       pch = c(16, 17), 
       title = "Resultado COVID")


```


```{r}
# Cargar librerías necesarias
library(ggplot2)
library(dplyr)


pca_scores <- pca_after$x

# 3. Agregar los resultados PCA al dataframe de metadatos
metadata_pca <- cbind(datos_filtrados[,c(4:7)], pca_scores)

# 4. Función para realizar Kruskal-Wallis sobre los componentes principales
kruskal_pca <- function(pca_scores, metadata, factor) {
  results <- data.frame()
  for (i in 1:ncol(pca_scores)) {  # Para cada componente principal
    pca_component <- pca_scores[, i]  # Extraer la puntuación del componente
    model <- kruskal.test(pca_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
    factor_effect <- model$p.value  # Obtener el p-valor
    results <- rbind(results, data.frame(PC = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
  }
  return(results)
}

# 5. Lista de factores que quieres analizar
factors <- c("PCR.Cov", "fecha", "equipo")


# Ejecutar la función para cada factor y combinar los resultados
kruskal_results <- do.call(rbind, lapply(factors, function(f) kruskal_pca(pca_scores, datos_filtrados, f)))

# 6. Resumir el p-valor medio para cada factor
factor_summary <- kruskal_results %>%
  group_by(Factor) %>%
  summarise(MeanLogPValue = -log10(mean(PValue)))

pca_kruskal_COMBAT<- ggplot(factor_summary, aes(x = reorder(Factor, MeanLogPValue), y = MeanLogPValue, fill = Factor)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Importancia de los Factores PCA",
       x = "Factor",
       y = "-log10(P-valor Medio)",
       fill = "Factor")
    theme(
    plot.title = element_text(size = 35),  # Reducir tamaño del título
    axis.title.x = element_text(size = 30),  # Reducir tamaño del título del eje X
    axis.title.y = element_text(size = 30),  # Reducir tamaño del título del eje Y
    axis.text = element_text(size = 18),  # Reducir tamaño de los textos de los ejes
    legend.title = element_text(size = 28),  # Reducir tamaño del título de la leyenda
    legend.text = element_text(size = 28)  # Reducir tamaño del texto de la leyenda
  )
print(pca_kruskal_COMBAT)
```

```{r}
# 
# pca_kruskal_COMBAT <- ggplot(factor_summary, aes(x = reorder(Factor, MeanLogPValue), y = MeanLogPValue, fill = Factor)) +
#   geom_bar(stat = "identity", width = 0.7) +  # Ajusta el ancho de las barras
#   coord_flip() +
#   labs(
#     title = "Importancia de los Factores PCA",
#     x = "Factor",
#     y = "-log10(P-valor Medio)",
#     fill = "Factor"
#   ) +
#   theme_minimal() +
#   theme(
#     plot.title = element_text(size = 16, face = "bold"),
#     axis.title.x = element_text(size = 14),
#     axis.title.y = element_text(size = 14),
#     axis.text.x = element_text(size = 12),
#     axis.text.y = element_text(size = 12),
#     legend.title = element_text(size = 14),
#     legend.text = element_text(size = 12),
#     panel.background = element_rect(fill = "white", color = NA),
#     plot.background = element_rect(fill = "white", color = NA)
#   )
# 
# # Exportar el gráfico con dimensiones ajustadas
# ggsave(
#   filename = "CombatPCA.png",
#   plot = pca_kruskal_COMBAT,
#   width = 8,    # Ancho ajustado
#   height = 6,   # Altura ajustada
#   dpi = 300,
#   scale = 1.5,  # Escala para aumentar proporcionalmente todo el diseño
#   bg = "white"  # Fondo blanco asegurado
# )
```


UMAP

```{r}
library(umap)


# Ajustar parámetros directamente en la función umap
umap_combat <- umap(combat_corrected_equipo, n_neighbors = 10, metric = "euclidean", min_dist = 0.3)

# Verificar la estructura del objeto umap_v2
str(umap_combat) # Esto te mostrará la estructura para asegurarte de que layout es un componente válido.

# Si la estructura es correcta, continuar con la conversión a dataframe
umap_coor_combat <- as.data.frame(umap_combat)

# Asignar nombres de columnas
colnames(umap_coor_combat) <- c("UMAP1", "UMAP2")

# Añadir las columnas con los metadatos (COVID, equipo, etc.)
umap_coor_combat$covid <- datos_filtrados$PCR.Cov
umap_coor_combat$equipo <- datos_filtrados$equipo

UMAP_postCombat<-plot_umap(umap_coor_combat, UMAP1, UMAP2, color_by  = "equipo", shape_by = "covid",
          title = "UMAP post COMBAT", usar_paleta_auto = TRUE)
UMAP_postCombat
```


```{r}
UMAP_postCombat <- UMAP_postCombat + 
  theme(
    panel.background = element_rect(fill = "white"), # Fondo blanco
    
    panel.grid.minor = element_blank(), # Sin líneas de cuadrícula menores
    plot.background = element_rect(fill = "white") # Fondo del gráfico blanco
  )

```



```{r}

umap_scores <- umap_combat  # Tomar el resultado de UMAP directamente

# Luego sigues con el mismo análisis
metadata_umap <- cbind(datos_filtrados[,c(4,5,7)], umap_scores)

# Función para realizar Kruskal-Wallis sobre las dimensiones de UMAP
kruskal_umap <- function(umap_scores, metadata, factor) {
  results <- data.frame()
  for (i in 1:ncol(umap_scores)) {  # Para cada dimensión de UMAP
    umap_component <- umap_scores[, i]  # Extraer la puntuación de la dimensión
    model <- kruskal.test(umap_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
    factor_effect <- model$p.value  # Obtener el p-valor
    results <- rbind(results, data.frame(UMAP_Dim = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
  }
  return(results)
}

# Lista de factores que quieres analizar
factors <- c("PCR.Cov", "fecha", "equipo")

# Ejecutar la función para cada factor y combinar los resultados
kruskal_results_umap <- do.call(rbind, lapply(factors, function(f) kruskal_umap(umap_scores, datos_filtrados, f)))

# Resumir el p-valor medio para cada factor
factor_summary_umap <- kruskal_results_umap %>%
  group_by(Factor) %>%
  summarise(MeanLogPValue = -log10(mean(PValue)))

# Visualizar los resultados en un gráfico de barras
umap_postcombat_var<-ggplot(factor_summary_umap, aes(x = reorder(Factor, MeanLogPValue), y = MeanLogPValue, fill = Factor)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Importancia de componentes UMAP post COMBAT",
       x = "Factor",
       y = "-log10(P-valor Medio)",
       fill = "Factor")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  
  )


print(umap_postcombat_var)


```

```{r}
library(patchwork)

# Primero definimos el layout de los gráficos combinados
combined_var_combat <- (
  pca_kruskal_COMBAT + umap_postcombat_var
)

# Agregamos los títulos y anotaciones
combined_var_combat <- combined_var_combat + 
  plot_annotation(
    title = "Influencia de los factores en los datos",
    tag_levels = "A"
  ) & theme(plot.title = element_text(hjust = 0.5, size = 10))
# Para ver el gráfico
print(combined_var_combat)

# Guardamos con dimensiones optimizadas
ggsave(
  filename = "combined_var_kruskal.png",
  plot = combined_var_combat,
  width = 14,    # Aumentado para dar más espacio
  height = 10,   # Aumentado proporcionalmente
  dpi = 300,
  scale = 1,    # Quitamos el scale para tener más control directo
  bg = "white"
)
```




```{r}
ggsave(
  filename = "combined_var_kruskal.png",
  plot = combined_var_combat,
  width = 12,    # Ancho ajustado
  height = 8,   # Altura ajustada
  dpi = 300,
  scale = 1.2,  # Escala para aumentar proporcionalmente todo el diseño
  bg = "white"  # Fondo blanco asegurado
)


```



# clustering combat_equipo


```{r}
library(dendextend)

distancias <- dist(combat_corrected_equipo)

# Realizar el clustering jerárquico
hc <- hclust(distancias, method = "ward.D2")

# Convierte el dendrograma a un objeto de dendextend
dend <- as.dendrogram(hc)

# Crea un vector de colores basado en PCR.cov
# Cambia "PCR.cov" a la columna adecuada de Datos_actualizados
label_colors <- as.factor(Datos_actualizados$PCR.Cov)
palette <- c("red", "blue") # Cambia los colores si hay más de 2 categorías
label_colors <- palette[label_colors]

# Aplica los colores a las etiquetas
dend <- dend %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.5) # Ajusta el tamaño de las etiquetas

# Dibuja el dendrograma
plot(dend, main = "Dendrograma por resultado COVID")
legend("topright",           # Posición de la leyenda
       legend = c("COVID Negativo", "COVID Positivo"), # Textos de la leyenda
       fill = c("red", "blue"),                        # Colores de la leyenda
       border = "black",                               # Borde de las cajas de color
       bty = "n",                                      # Sin caja alrededor de la leyenda
       cex = 0.8)    

```


```{r}
table(Datos_actualizados$PCR.Cov, label_colors)

```


 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_pos <- datos_filtrados$PCR.Cov == "Cov.Pos"
featureMatrix_cov_pos <- combat_corrected_equipo[indices_cov_pos, ]
datos_filtrados_cov_pos <- datos_filtrados[indices_cov_pos, ]

# Verificar que los datos estén filtrados correctamente
dim(featureMatrix_cov_pos)
table(datos_filtrados$equipo)


# Realizar el clustering jerárquico
dist_featureMatriz_cov_pos <- dist(featureMatrix_cov_pos)
hc_cov_pos <- hclust(dist_featureMatriz_cov_pos, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_pos <- as.dendrogram(hc_cov_pos)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(datos_filtrados_cov_pos$equipo)
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]

# Personalizar el dendrograma
dend_cov_pos <- dend_cov_pos %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tamaño de las etiquetas

# Visualizar el dendrograma
plot(dend_cov_pos, main = "Clustering de Positivos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")

```


 
 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_neg <- datos_filtrados$PCR.Cov == "Cov.Neg"
featureMatrix_cov_neg <- combat_corrected_equipo[indices_cov_neg, ]
datos_filtrados_cov_neg <- Datos_actualizados[indices_cov_neg, ]

# Verificar que los datos estén filtrados correctamente
dim(featureMatrix_cov_neg)
table(datos_filtrados_cov_neg$equipo)

# Realizar el clustering jerárquico
dist_featureMatriz_cov_neg <- dist(featureMatrix_cov_neg)
hc_cov_neg <- hclust(dist_featureMatriz_cov_neg, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_neg <- as.dendrogram(hc_cov_neg)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- factor(datos_filtrados_cov_pos$equipo, levels = c("CR", "HC", "Malbran"))

palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]

# Personalizar el dendrograma
dend_cov_neg <- dend_cov_neg %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tamaño de las etiquetas

# Visualizar el dendrograma
plot(dend_cov_neg, main = "Clustering de Negativos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")

```
 



```{r}
table(datos_filtrados_cov_neg$equipo)

```



 
```{r}

# Extraer solo las filas que corresponden a los equipos en featureMatrix_num
# Asegúrate de que Datos_actualizados$equipo tenga valores válidos para subindexar.
featureMatrix_equipo <- combat_corrected_equipo

# Verificar que los datos estén filtrados correctamente
table(Datos_actualizados$equipo)

# Calcular la matriz de distancias y realizar el clustering jerárquico
dist_featureMatriz_eq <- dist(featureMatrix_equipo)
hc_eq <- hclust(dist_featureMatriz_eq, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_eq <- as.dendrogram(hc_eq)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- factor(datos_filtrados_cov_neg$equipo, levels = c("CR", "HC", "Malbran"))

palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]           # Asignar colores por equipo

# Personalizar el dendrograma
dend_eq <- dend_eq %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tamaño de las etiquetas


png("dendrograma_COVID.equipo.png", width = 800, height = 600)
plot(dend_eq, main = "Clustering Diferenciado por Equipo post Combat")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")
dev.off()

# Visualizar el dendrograma
plot(dend_eq, main = "Clustering Diferenciado por Equipo post Combat")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")


```




```{r}


datos_filtrados$fecha <- as.factor(datos_filtrados$fecha)

# Matriz de características (featureMatrix_num)
featureMatrix_fecha <- combat_corrected_equipo

# Calcular la matriz de distancias y realizar el clustering jerárquico
dist_featureMatriz_fecha <- dist(featureMatrix_fecha)
hc_fecha <- hclust(dist_featureMatriz_fecha, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_fecha <- as.dendrogram(hc_fecha)

# Crear un vector de colores para las etiquetas basado en 'fecha'
fecha_factor <- datos_filtrados$fecha
palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
label_colors <- palette[fecha_factor]           # Asignar colores por fecha

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'fecha'
  set("labels_cex", 0.6)               # Ajusta el tamaño de las etiquetas

# Visualizar el dendrograma
library(RColorBrewer)

# Crear una paleta más contrastante
num_colores <- length(levels(fecha_factor))
palette <- brewer.pal(n = min(num_colores, 12), name = "Paired") # Máx. 12 colores contrastantes
if (num_colores > 12) {
  palette <- colorRampPalette(brewer.pal(12, "Paired"))(num_colores) # Extender paleta si es necesario
}

# Aplicar los nuevos colores
label_colors <- palette[fecha_factor]

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.6)

# Dibujar el dendrograma
plot(dend_fecha, main = "Clustering Diferenciado por Fecha")
legend(
  "topright",
  legend = levels(fecha_factor),
  col = palette,
  pch = 19,
  title = "Fecha",
  cex = 0.7,
  bty = "n"
)


```



# 18.Correcion efecto batch FECHA: Combat

```{r}
# Ejemplo de datos de entrada
data_matrix <- featureMatrix_num  # Tu matriz de datos
metadata <- datos_filtrados    # Dataframe de metadatos con información de batch
batch_info <- metadata$fecha      # Vector con la información de batch

```

```{r}
# Verificar si 'batch_info' es un factor o un vector de caracteres
str(batch_info)

# Si es necesario, convertirlo a un factor
batch_info <- factor(batch_info)


```

```{r}
sum(is.na(data_matrix))  # Revisa si hay valores NA en la matriz

```



```{r}

combat_corrected_fecha <- ComBat(
  dat = t(data_matrix),             
  batch = batch_info,            # Información de batch
  par.prior = TRUE,
  prior.plots = FALSE
)



```



```{r}
# Transponer de vuelta los datos corregidos
combat_corrected_fecha <- t(combat_corrected_fecha)

# Guardar la matriz corregida
write.csv(combat_corrected_fecha, "corrected_featureMatrix.csv")

```



```{r}
save(featureMatrix, file = "correccion_combat_fecha.rda")

```

# CLUSTERING COMBAT_FECHA


```{r}
library(dendextend)

distancias <- dist(combat_corrected_fecha)

# Realizar el clustering jerárquico
hc <- hclust(distancias, method = "ward.D2")

# Convierte el dendrograma a un objeto de dendextend
dend <- as.dendrogram(hc)

# Crea un vector de colores basado en PCR.cov
# Cambia "PCR.cov" a la columna adecuada de Datos_actualizados
label_colors <- as.factor(datos_filtrados$PCR.Cov)
palette <- c("red", "blue") # Cambia los colores si hay más de 2 categorías
label_colors <- palette[label_colors]

# Aplica los colores a las etiquetas
dend <- dend %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.5) # Ajusta el tamaño de las etiquetas




# Dibuja el dendrograma
plot(dend, main = "Dendrograma por resultado COVID")
legend("topright",           # Posición de la leyenda
       legend = c("COVID Negativo", "COVID Positivo"), # Textos de la leyenda
       fill = c("red", "blue"),                        # Colores de la leyenda
       border = "black",                               # Borde de las cajas de color
       bty = "n",                                      # Sin caja alrededor de la leyenda
       cex = 0.8)    

```


```{r}
table(datos_filtrados$PCR.Cov, label_colors)

```

 
 
```{r}
library(dendextend)
library(factoextra)
# 
# # Filtrar las muestras positivas (COV.POS)
# indices_cov_pos <- datos_filtrados$PCR.Cov == "Cov.Pos"
# table(datos_filtrados$fecha[indices_cov_pos])
# 
# datos_filtrados_cov_pos$fecha <- droplevels(datos_filtrados_cov_pos$fecha)
# table(datos_filtrados_cov_pos$fecha)  # Ahora sí, solo fechas con ≥1 muestra positiva
# featureMatrix_cov_pos <- combat_corrected_fecha[indices_cov_pos, ]
# datos_filtrados_cov_pos <- datos_filtrados[indices_cov_pos, ]
# 
# 
# 
# # Verificar que los datos estén filtrados correctamente
# dim(featureMatrix_cov_pos)
# table(datos_filtrados$fecha)
# 
# 
# # Realizar el clustering jerárquico
# dist_featureMatriz_cov_pos <- dist(featureMatrix_cov_pos)
# hc_cov_pos <- hclust(dist_featureMatriz_cov_pos, method = "ward.D2")
# 
# # Convertir a dendrograma para personalizar
# dend_cov_pos <- as.dendrogram(hc_cov_pos)
# 
# # Crear un vector de colores para las etiquetas basado en 'equipo'
# equipo_factor <- as.factor(datos_filtradoss_cov_pos$fecha)
# palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
# label_colors <- palette[fecha_factor]
# 
# # Personalizar el dendrograma
# dend_cov_pos <- dend_cov_pos %>%
#   set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
#   set("labels_cex", 0.6)               # Ajusta el tamaño de las etiquetas


# Filtrar las muestras positivas (COV.POS)
indices_cov_pos <- datos_filtrados$PCR.Cov == "Cov.Pos"
featureMatrix_cov_pos <- combat_corrected_fecha[indices_cov_pos, ]
Datos_actualizados_cov_pos <- datos_filtrados[datos_filtrados$PCR.Cov == "Cov.Pos", ]


# Verificar que los datos estén filtrados correctamente
dim(featureMatrix_cov_pos)
table(Datos_actualizados_cov_pos$fecha)


# Realizar el clustering jerárquico
dist_featureMatriz_cov_pos <- dist(featureMatrix_cov_pos)
hc_cov_pos <- hclust(dist_featureMatriz_cov_pos, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_pos <- as.dendrogram(hc_cov_pos)

# Crear un vector de colores para las etiquetas basado en 'equipo'
fecha_factor <- as.factor(Datos_actualizados_cov_pos$fecha)
palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
label_colors <- palette[fecha_factor]

# Personalizar el dendrograma
dend_cov_pos <- dend_cov_pos %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tamaño de las etiquetas






# Visualizar el dendrograma
plot(dend_cov_pos, main = "Clustering de Positivos Diferenciado por fecha")
legend("topright", legend = levels(fecha_factor), col = palette, pch = 19, title = "Fecha")




```


 
 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_neg <- datos_filtrados$PCR.Cov == "Cov.Neg"
featureMatrix_cov_neg <- combat_corrected_fecha[indices_cov_neg, ]
datos_filtrados_cov_neg <- Datos_actualizados[indices_cov_neg, ]

# Verificar que los datos estén filtrados correctamente
dim(featureMatrix_cov_neg)
table(datos_filtrados_cov_neg$fecha)

# Realizar el clustering jerárquico
dist_featureMatriz_cov_neg <- dist(featureMatrix_cov_neg)
hc_cov_neg <- hclust(dist_featureMatriz_cov_neg, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_neg <- as.dendrogram(hc_cov_neg)

# Crear un vector de colores para las etiquetas basado en 'fecha'
fecha_factor <- as.factor(datos_filtrados_cov_neg$fecha)
palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
label_colors <- palette[fecha_factor]

# Personalizar el dendrograma
dend_cov_neg <- dend_cov_neg %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tamaño de las etiquetas

# Visualizar el dendrograma
plot(dend_cov_neg, main = "Clustering de Negativos Diferenciado por fecha")
legend("topright", legend = levels(fecha_factor), col = palette, pch = 19, title = "Equipo")

```
 



 
```{r}

# Extraer solo las filas que corresponden a los equipos en featureMatrix_num
# Asegúrate de que Datos_actualizados$equipo tenga valores válidos para subindexar.
featureMatrix_equipo <- combat_corrected_fecha

# Verificar que los datos estén filtrados correctamente
table(Datos_actualizados$equipo)

# Calcular la matriz de distancias y realizar el clustering jerárquico
dist_featureMatriz_eq <- dist(combat_corrected_fecha)
hc_eq <- hclust(dist_featureMatriz_eq, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_eq <- as.dendrogram(hc_eq)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(datos_filtrados$equipo)
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]           # Asignar colores por equipo

# Personalizar el dendrograma
dend_eq <- dend_eq %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tamaño de las etiquetas



# Visualizar el dendrograma
plot(dend_eq, main = "Clustering Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")


```




```{r}


datos_filtrados$fecha <- as.factor(datos_filtrados$fecha)

# Matriz de características (featureMatrix_num)
featureMatrix_fecha <- combat_corrected_fecha

# Calcular la matriz de distancias y realizar el clustering jerárquico
dist_featureMatriz_fecha <- dist(featureMatrix_fecha)
hc_fecha <- hclust(dist_featureMatriz_fecha, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_fecha <- as.dendrogram(hc_fecha)

# Crear un vector de colores para las etiquetas basado en 'fecha'
fecha_factor <- datos_filtrados$fecha
palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
label_colors <- palette[fecha_factor]           # Asignar colores por fecha

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'fecha'
  set("labels_cex", 0.6)               # Ajusta el tamaño de las etiquetas

# Visualizar el dendrograma
library(RColorBrewer)

# Crear una paleta más contrastante
num_colores <- length(levels(fecha_factor))
palette <- brewer.pal(n = min(num_colores, 12), name = "Paired") # Máx. 12 colores contrastantes
if (num_colores > 12) {
  palette <- colorRampPalette(brewer.pal(12, "Paired"))(num_colores) # Extender paleta si es necesario
}

# Aplicar los nuevos colores
label_colors <- palette[fecha_factor]

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.6)




# Dibujar el dendrograma
plot(dend_fecha, main = "Clustering Diferenciado por Fecha")
legend(
  "topright",
  legend = levels(fecha_factor),
  col = palette,
  pch = 19,
  title = "Fecha",
  cex = 0.7,
  bty = "n"
)


png("FECHA_combat.png", width = 800, height = 600)
plot(dend_fecha, main = "Clustering Diferenciado por Fecha")
legend(
  "topright",
  legend = levels(fecha_factor),
  col = palette,
  pch = 19,
  title = "Fecha",
  cex = 0.7,
  bty = "n"
)
dev.off()

```


```{r}
positivos <- datos_filtrados$PCR.Cov == "Cov.Pos"
negativos <- datos_filtrados$PCR.Cov == "Cov.Neg"

table(datos_filtrados$fecha[positivos])
table(datos_filtrados$fecha[negativos])

```


#En ComBat, el argumento modcombat (o mod) contiene la matriz de diseño que representa las variables de interés que deseas preservar durante la corrección por batch


#####error

```{r}
modcombat <- model.matrix(~ equipo, data = datos_filtrados)

```

```{r}
# Ejemplo de datos de entrada
data_matrix <- featureMatrix_num  # Tu matriz de datos
metadata <- datos_filtrados    # Dataframe de metadatos con información de batch
batch_info <- metadata$fecha      # Vector con la información de batch

```

```{r}
# Verificar si 'batch_info' es un factor o un vector de caracteres
str(batch_info)

# Si es necesario, convertirlo a un factor
batch_info <- factor(batch_info)


```


```{r}
# combat_corrected_fecha2 <- ComBat(
#   dat = t(data_matrix),         # Matriz de intensidades
#   batch = batch_info,    # Variable batch (por ejemplo, equipos)
#   mod = modcombat,
#   par.prior = TRUE,
#   prior.plots = FALSE)

```

         
```{r}
# Transponer de vuelta los datos corregidos
# combat_corrected_fecha2 <- t(combat_corrected_fecha2)
# 
# # Guardar la matriz corregida
# write.csv(combat_corrected_fecha2, "corrected_featureMatrix.csv")

```

```{r}
# # Asignar colores manualmente en función de batch_info
# batch_colors <- as.factor(batch_info)   # Convertir batch_info a factor
# levels(batch_colors)  # Ver los niveles de batch_info
# 
# # Definir colores manualmente (puedes cambiar los nombres de niveles y colores)
# col_vector <- batch_colors
# levels(col_vector) <- c("red", "blue", "green")  # Asigna colores a cada batch
```

```{r}
# fecha_colors <- as.factor(metadata$fecha)  # Convertir 'equipo' a factor
# 
# # Asignar colores
# palette_colors <- rainbow(length(unique(fecha_colors)))  # Colores únicos
# col_vector <- palette_colors[fecha_colors]
```

```{r}
# pca_after2 <- prcomp(combat_corrected_fecha2, scale. = TRUE)
# 
# # Plot PCA después de la corrección
# plot(pca_after2$x[,1:2], col = col_vector, main = "PCA después de la corrección")
# legend("topright", 
#        legend = levels(batch_colors), 
#        col = palette_colors, 
#        pch = 16, 
#        title = "Batch")
```


```{r}
# library(umap)
# 
# 
# # Ajustar parámetros directamente en la función umap
# umap_v5 <- umap(combat_corrected2, n_neighbors = 15, metric = "euclidean", min_dist = 0.1)
# 
# # Verificar la estructura del objeto umap_v2
# str(umap_v5) # Esto te mostrará la estructura para asegurarte de que layout es un componente válido.
# 
# # Si la estructura es correcta, continuar con la conversión a dataframe
# umap_coor5 <- as.data.frame(umap_v5)
# 
# # Asignar nombres de columnas
# colnames(umap_coor5) <- c("UMAP1", "UMAP2")
# 
# # Añadir las columnas con los metadatos (COVID, equipo, etc.)
# umap_coor5$covid <- Datos_actualizados$PCR.Cov
# umap_coor5$equipo <- Datos_actualizados$equipo
# 
# # Graficar UMAP con ggplot2
# library(ggplot2)
# ggplot(umap_coor5, aes(x = UMAP1, y = UMAP2, color = equipo, shape = covid)) +
#   geom_point(size = 3) +
#   labs(title = "UMAP luego de corrección por COMBAT",
#        x = "UMAP1",
#        y = "UMAP2") +
#   theme_minimal()
```



```{r}
# 
# umap_scores <- umap_v5  # Tomar el resultado de UMAP directamente
# 
# # Luego sigues con el mismo análisis
# metadata_umap <- cbind(Datos_actualizados[,c(4,5,7)], umap_scores)
# 
# # Función para realizar Kruskal-Wallis sobre las dimensiones de UMAP
# kruskal_umap <- function(umap_scores, metadata, factor) {
#   results <- data.frame()
#   for (i in 1:ncol(umap_scores)) {  # Para cada dimensión de UMAP
#     umap_component <- umap_scores[, i]  # Extraer la puntuación de la dimensión
#     model <- kruskal.test(umap_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
#     factor_effect <- model$p.value  # Obtener el p-valor
#     results <- rbind(results, data.frame(UMAP_Dim = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
#   }
#   return(results)
# }
# 
# # Lista de factores que quieres analizar
# factors <- c("PCR.Cov", "fecha", "equipo")

# Ejecutar la función para cada factor y combinar los resultados
# kruskal_results_umap <- do.call(rbind, lapply(factors, function(f) kruskal_umap(umap_scores, Datos_actualizados, f)))
# 
# # Resumir el p-valor medio para cada factor
# factor_summary_umap <- kruskal_results_umap %>%
#   group_by(Factor) %>%
#   summarise(MeanPValue = mean(PValue))
# 
# # Visualizar los resultados en un gráfico de barras
# ggplot(factor_summary_umap, aes(x = reorder(Factor, MeanPValue), y = MeanPValue, fill = Factor)) +
#   geom_bar(stat = "identity") +
#   coord_flip() +
#   theme_minimal() +
#   labs(title = "Importancia de los Factores en el Efecto Batch (UMAP) despues de COMBAT",
#        x = "Factor",
#        y = "P-valor Medio",
#        fill = "Factor")

```

```{r}
combat_corrected_fecha_high<-combat_corrected_fecha
```

```{r}
combat_corrected_equipo_high<-combat_corrected_equipo
```

