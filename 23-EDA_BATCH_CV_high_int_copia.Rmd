---
title: "EDA-Combat"
author: "Karina Roitman"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

# Objetivos

# 1. Cargar librerias.

rmarkdown como estrategia sint√°ctica. (En bibliografia hay 2 archivos)

```{r}
library(rmarkdown)
```

```{r}

library(stringr)
?stringr
library(tidyr)
?tidyr
library(dplyr)
library(openxlsx)
library(purrr)
library(broom)
library(ggplot2)
library(MALDIquant)
?MALDIquant
library(MALDIquantForeign)
?MALDIquantForeign
```

```{r}
getwd()  # Verifica el directorio de trabajo actual

```

```{r}
setwd("C:/Users/karin/Desktop/MCD/TESIS")
```

# 2. Cargar datos

```{r}
load("./Data_Kari/EspectrosINB/Average_ciego.INBIRS.1.rda")
load("./Data_Kari/EspectrosINB/Average_ciego.INBIRS.2.rda")
load("./Data_Kari/EspectrosINB/Average_ciego.INBIRS.3.rda")
load("./Data_Kari/EspectrosINB/Average_ciego.INBIRS.4.rda")
load("./Data_Kari/EspectrosHC/Average_HC_1.rda")
load("./Data_Kari/EspectrosHC/Average_HC_2.rda")
load("./Data_Kari/EspectrosHC/Average_HC_3.rda")
load("./Data_Kari/EspectrosHC/Average_HC_4.rda")
load("./Data_Kari/EspectrosHC/Average_HC_5.rda")
load("./Data_Kari/EspectrosHC/Average_HC_6.rda")
load("./Data_Kari/Espectros.Malb/Average_ciego.Malbran.1.rda")
load("./Data_Kari/Espectros.Malb/Average_ciego.Malbran.2.rda")
load("./Data_Kari/Espectros.Malb/Average_ciego.Malbran.3.rda")
load("./Data_Kari/EspectrosCR/Average_ciego.Costa.Rica.1.rda")
load("./Data_Kari/EspectrosCR/Average_ciego.Costa.Rica.3.rda")
```


#Ciego
 
```{r}
# load("./Data_Kari/ciego/Average_ciego.Costa.Rica.4.rda")
# load("./Data_Kari/ciego/Average_ciego.Costa.Rica.5.rda")
# load("./Data_Kari/ciego/Average_ciego.Costa.Rica.6.rda")
# load("./Data_Kari/ciego/Average_ciego.Malbran.4.rda")

```


# 3. Asigno batch, institucion y equipo

```{r}
# Listado de tus dataframes
dataframes <- list(INBIRS.1.df.f.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "16_7i"
  df$institucion <- "inbirs"
  df$equipo <- "HC"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

INBIRS.1.df.f.1 <- dataframes[[1]]
```

```{r}
# Listado de tus dataframes
dataframes <- list(INBIRS.df.2.f)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "17_7i"
  df$institucion <- "inbirs"
  df$equipo <- "HC"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

INBIRS.df.2.f <- dataframes[[1]]
```

```{r}
# Listado de tus dataframes
dataframes <- list(INBIRS.df.3.f)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "13_8i"
  df$institucion <- "inbirs"
  df$equipo <- "HC"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

INBIRS.df.3.f <- dataframes[[1]]
```

```{r}
# Listado de tus dataframes
dataframes <- list(Espectros.INBIRS.4.f)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "18_8i"
  df$institucion <- "inbirs"
  df$equipo <- "HC"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales
Espectros.INBIRS.4.f<-dataframes[[1]]

```

HC1

```{r}
# Listado de tus dataframes
dataframes <- list(Categ.Hospi.1.Neg, Categ.Hospi.1.Pos, Categ.Hospi.2.Cnt, Categ.Hospi.2.Neg, Categ.Hospi.2.No.Covid, Categ.Hospi.2.Pos, Categ.Hospi.3.Neg, Categ.Hospi.3.No.Covid, Categ.Hospi.3.Pos)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia1hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

Categ.Hospi.1.Neg<- dataframes[[1]]
Categ.Hospi.1.Pos<- dataframes[[2]]
Categ.Hospi.2.Cnt<- dataframes[[3]]
Categ.Hospi.2.Neg<- dataframes[[4]]
Categ.Hospi.2.No.Covid<- dataframes[[5]]
Categ.Hospi.2.Pos<- dataframes[[6]]
Categ.Hospi.3.Neg<- dataframes[[7]]
Categ.Hospi.3.No.Covid<- dataframes[[8]]
Categ.Hospi.3.Pos<- dataframes[[9]]

```

HC2

```{r}
dataframes <- list(Categ.Ciego.clin.1.Exp1.covid, Categ.Ciego.clin.1.Exp1.flu)

dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia2hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

Categ.Ciego.clin.1.Exp1.covid<-dataframes[[1]]
Categ.Ciego.clin.1.Exp1.flu<-dataframes[[2]]
```

HC3

```{r}
dataframes <- list(Categ.Neg.New.clin.1, Categ.Pos.New.clin.1)

dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia3hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

Categ.Neg.New.clin.1<-dataframes[[1]]
Categ.Pos.New.clin.1<-dataframes[[2]]
```

HC4

```{r}
dataframes <- list(Categ.Ciego.clin25.6.2.covid, Categ.Ciego25.6.clin.2.flu)

dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia4hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

Categ.Ciego.clin25.6.2.covid<-dataframes[[1]]
Categ.Ciego25.6.clin.2.flu<-dataframes[[2]]
```

HC5

```{r}
dataframes <- list(Categ.Ciego_3_7.4)

dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia5hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

Categ.Ciego_3_7.4<-dataframes[[1]]
```

HC6

```{r}
dataframes <- list(Categ.Ciego_8_7.4)

dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia2hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

Categ.Ciego_8_7.4<-dataframes[[1]]

```

MALBRAN 1

```{r}
# Listado de tus dataframes
dataframes <- list(Categ.Malbran.1.1.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "1Malbran"
  df$institucion <- "Malbran"
  df$equipo <- "Malbran"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

Categ.Malbran.1.1.1 <- dataframes[[1]]
```

MALBRAN2

```{r}
# Listado de tus dataframes
dataframes <- list(Categ.Malbran.2.1.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "2Malbran"
  df$institucion <- "Malbran"
  df$equipo <- "Malbran"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

Categ.Malbran.2.1.1 <- dataframes[[1]]
```

MALBRAN3

```{r}
# Listado de tus dataframes
dataframes <- list(Malbran_3_4.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "3Malbran"
  df$institucion <- "Malbran"
  df$equipo <- "Malbran"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

Malbran_3_4.1 <- dataframes[[1]]
```

CR1

```{r}
# Listado de tus dataframes
dataframes <- list(CostaRica.1.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "1CR"
  df$institucion <- "CR"
  df$equipo <- "CR"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

CostaRica.1.1 <- dataframes[[1]]
```

CR2

```{r}
# Listado de tus dataframes
dataframes <- list(CostaRica.3.1.1.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "2CR"
  df$institucion <- "CR"
  df$equipo <- "CR"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

CostaRica.3.1.1.1<- dataframes[[1]]


CostaRica.3.1.1.1$PCR.Cov <- CostaRica.3.1.1.1$Virus
```




#ciego costa rica 4

```{r}
# # Listado de tus dataframes
# dataframes <- list(CostaRica.4.1.1)
# 
# # Usas lapply para agregar las columnas a cada dataframe
# dataframes <- lapply(dataframes, function(df) {
#   df$institucion <- "CR"
#   df$equipo <- "CR"
#   return(df)
# })
# 
# CostaRica.4.1.1 <- dataframes[[1]]
```



CR5


```{r}
# # Listado de tus dataframes
# dataframes <- list(CostaRica.5.1)
# 
# # Usas lapply para agregar las columnas a cada dataframe
# dataframes <- lapply(dataframes, function(df) {
#   df$institucion <- "CR"
#   df$equipo <- "CR"
#   return(df)
# })
# 
# # Asignas los dataframes modificados de vuelta a sus nombres originales
# 
# CostaRica.5.1 <- dataframes[[1]]
```



#ciego costa rica 6

CR6


```{r}
# # Listado de tus dataframes
# dataframes <- list(CostaRica.6.1)
# 
# # Usas lapply para agregar las columnas a cada dataframe
# dataframes <- lapply(dataframes, function(df) {
#   df$institucion <- "CR"
#   df$equipo <- "CR"
#   return(df)
# })
# 
# # Asignas los dataframes modificados de vuelta a sus nombres originales
# 
# CostaRica.6.1 <- dataframes[[1]]
```


# ciego MALBRAN 4

```{r}
# # Listado de tus dataframes
# dataframes <- list(Malbran_5_6.1)
# 
# # Usas lapply para agregar las columnas a cada dataframe
# dataframes <- lapply(dataframes, function(df) {
#   df$institucion <- "Malbran"
#   df$equipo <- "Malbran"
#   return(df)
# })
# 
# # Asignas los dataframes modificados de vuelta a sus nombres originales
# 
# Malbran_5_6.1 <- dataframes[[1]]
```


# 4. Listado de todos los dataframes

```{r}
# dataframes <- list(INBIRS.1.df.f.1,
# INBIRS.df.2.f,
# INBIRS.df.3.f,
# Espectros.INBIRS.4.f,
# Categ.Hospi.1.Neg,
# Categ.Hospi.1.Pos,
# Categ.Hospi.2.Cnt,
# Categ.Hospi.2.Neg,
# Categ.Hospi.2.No.Covid,
# Categ.Hospi.2.Pos,
# Categ.Hospi.3.Neg,
# Categ.Hospi.3.No.Covid,
# Categ.Hospi.3.Pos,
# Categ.Ciego.clin.1.Exp1.covid,
# Categ.Ciego.clin.1.Exp1.flu,
# Categ.Neg.New.clin.1,
# Categ.Pos.New.clin.1,
# Categ.Ciego.clin25.6.2.covid,
# Categ.Ciego25.6.clin.2.flu,
# Categ.Ciego_3_7.4,
# Categ.Ciego_8_7.4,
# Categ.Malbran.1.1.1,
# Categ.Malbran.2.1.1,
# Malbran_3_4.1,
# CostaRica.1.1,
# CostaRica.3.1.1.1)
# 
# 
# 
# 
# # Contar filas para cada dataframe
# filas_count <- sapply(dataframes, nrow)
# 
# # Mostrar los resultados
# print(filas_count)
# sum(filas_count)
```

# 5. Union de todos los espectros

```{r , message=FALSE, echo=FALSE, warning=FALSE, out.width="100%"}

Espec.Union.Clin.Pos.Neg <- c(
                            Espectros.INBIRS.1,
                            Espectros.INBIRS.2,
                            Espectros.INBIRS.3,
                            Espectros.INBIRS.4,
                            Espectros.HC.1.Neg,
                            Espectros.HC.1.HighPos,
                            Espectros.HC.2.Cnt,
                            Espectros.HC.2.Neg,
                            Espectros.HC.2.No.covid,
                            Espectros.HC.2.IntPos,
                            Espectros.HC.3.Neg,
                            Espectros.HC.3.No.covid,
                            Espectros.HC.3.LowPos,
                            Espectros.Ciego.Exp1.covid,
                            Espectros.Ciego.Exp1.flu,
                            Espectros.Neg.New.Clin,
                            Espectros.Pos.New.Clin, 
                            Espectros.Ciego.25.6.covid,
                            Espectros.Ciego.25.6.flu,
                            Espectros.Ciego.4.2,
                            Espectros.Ciego.5,
                            Espectros.Malbran.24,
                            Espectros.Malb.2.24,
                            Espectros.Malb.3_4,
                            Espectros.CR1,
                            Espectros.CR3
                            # Espectros.CR4, #ciego
                            # Espectros.CR5,#ciego
                            # Espectros.CR6,#ciego
                            # Espectros.Malb.5_6#ciego
                            )

Espectra.1 <- alignSpectra(Espec.Union.Clin.Pos.Neg, halfWindowSize=50, SNR=3, 
                    tolerance=0.5, warpingMethod="quadratic")
```

```{r}
library(purrr)
```

```{r}
INBIRS.1.df.f.1<-INBIRS.1.df.f.1[,c(1,6:10)]
INBIRS.1.df.f.1<-data.frame(purrr::map(INBIRS.1.df.f.1, as.character),
                               stringsAsFactors = FALSE)

INBIRS.df.2.f<-INBIRS.df.2.f[,c(1,6:10)]
INBIRS.df.2.f<-data.frame(purrr::map(INBIRS.df.2.f, as.character ),
                               stringsAsFactors = FALSE)

INBIRS.df.3.f<-INBIRS.df.3.f[,c(1,6:10)]
INBIRS.df.3.f<-data.frame(purrr::map(INBIRS.df.3.f, as.character ),
                               stringsAsFactors = FALSE)


Espectros.INBIRS.4.f<-Espectros.INBIRS.4.f[,c(1,6:10)]
Espectros.INBIRS.4.f<-data.frame(purrr::map(Espectros.INBIRS.4.f, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.1.Neg<- Categ.Hospi.1.Neg[,c(1,5,7,10:12)]
#Categ.Hospi.1.Neg<- data.frame(map(Categ.Hospi.1.Neg, as.character),
 #                              stringsAsFactors = FALSE)
Categ.Hospi.1.Neg<-data.frame(purrr::map(Categ.Hospi.1.Neg, as.character ),
                              stringsAsFactors = FALSE)

Categ.Hospi.1.Pos<- Categ.Hospi.1.Pos[,c(1,5,7,10:12)]
Categ.Hospi.1.Pos<-data.frame(purrr::map(Categ.Hospi.1.Pos, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.2.Cnt<- Categ.Hospi.2.Cnt[,c(1,5,8,11:13)]
Categ.Hospi.2.Cnt<-data.frame(purrr::map(Categ.Hospi.2.Cnt, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.2.Neg<- Categ.Hospi.2.Neg[,c(1,5,8,11:13)]
Categ.Hospi.2.Neg<-data.frame(purrr::map(Categ.Hospi.2.Neg, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.2.No.Covid<- Categ.Hospi.2.No.Covid[,c(1,5,8,11:13)]
Categ.Hospi.2.No.Covid<-data.frame(purrr::map(Categ.Hospi.2.No.Covid, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.2.Pos<- Categ.Hospi.2.Pos[,c(1,5,8,11:13)]
Categ.Hospi.2.Pos<-data.frame(purrr::map(Categ.Hospi.2.Pos, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.3.Neg<- Categ.Hospi.3.Neg[,c(1,5,8,11:13)]
Categ.Hospi.3.Neg<-data.frame(purrr::map(Categ.Hospi.3.Neg, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.3.No.Covid<- Categ.Hospi.3.No.Covid[,c(1,5,8,11:13)]
Categ.Hospi.3.No.Covid<-data.frame(purrr::map(Categ.Hospi.3.No.Covid, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.3.Pos<- Categ.Hospi.3.Pos[,c(1,5,8,11:13)]
Categ.Hospi.3.Pos<-data.frame(purrr::map(Categ.Hospi.3.Pos, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego.clin.1.Exp1.covid<-Categ.Ciego.clin.1.Exp1.covid[,c(1,6,7,9:11)]
Categ.Ciego.clin.1.Exp1.covid<-data.frame(purrr::map(Categ.Ciego.clin.1.Exp1.covid, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego.clin.1.Exp1.flu<-Categ.Ciego.clin.1.Exp1.flu[,c(1,6,7,9:11)]
Categ.Ciego.clin.1.Exp1.flu<-data.frame(purrr::map(Categ.Ciego.clin.1.Exp1.flu, as.character ),
                               stringsAsFactors = FALSE)

Categ.Neg.New.clin.1<-Categ.Neg.New.clin.1[,c(1,6:10)]
Categ.Neg.New.clin.1<-data.frame(purrr::map(Categ.Neg.New.clin.1, as.character ),
                               stringsAsFactors = FALSE)

Categ.Pos.New.clin.1<-Categ.Pos.New.clin.1[,c(1,6:10)]
Categ.Pos.New.clin.1<-data.frame(purrr::map(Categ.Pos.New.clin.1, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego.clin25.6.2.covid<-Categ.Ciego.clin25.6.2.covid[,c(1,6,7, 9:11)]
Categ.Ciego.clin25.6.2.covid<-data.frame(purrr::map(Categ.Ciego.clin25.6.2.covid, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego25.6.clin.2.flu<-Categ.Ciego25.6.clin.2.flu[,c(1,6,7, 9:11)]
Categ.Ciego25.6.clin.2.flu<-data.frame(purrr::map(Categ.Ciego25.6.clin.2.flu, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego_3_7.4<-Categ.Ciego_3_7.4[,c(1,6:10)]
Categ.Ciego_3_7.4<-data.frame(purrr::map(Categ.Ciego_3_7.4, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego_8_7.4<-Categ.Ciego_8_7.4[,c(1,6:10)]
Categ.Ciego_8_7.4<-data.frame(purrr::map(Categ.Ciego_8_7.4, as.character ),
                               stringsAsFactors = FALSE)


Categ.Malbran.1.1.1<-Categ.Malbran.1.1.1[,c(1,5:9)]
Categ.Malbran.1.1.1<-data.frame(purrr::map(Categ.Malbran.1.1.1, as.character ),
                               stringsAsFactors = FALSE)

Categ.Malbran.2.1.1<-Categ.Malbran.2.1.1[,c(1,5:9)]
Categ.Malbran.2.1.1<-data.frame(purrr::map(Categ.Malbran.2.1.1, as.character ),
                               stringsAsFactors = FALSE)

Malbran_3_4.1<-Malbran_3_4.1[,c(1,6:10)]
Malbran_3_4.1<-data.frame(purrr::map(Malbran_3_4.1, as.character ),
                               stringsAsFactors = FALSE)

CostaRica.1.1<-CostaRica.1.1[,c(1,6:10)]
CostaRica.1.1<-data.frame(purrr::map(CostaRica.1.1, as.character ),
                               stringsAsFactors = FALSE)

CostaRica.1.1$Carga<-as.character(CostaRica.1.1$Carga)

CostaRica.3.1.1.1<-CostaRica.3.1.1.1[,c(1,6:10)]
CostaRica.3.1.1.1<-data.frame(purrr::map(CostaRica.3.1.1.1, as.character),
                               stringsAsFactors = FALSE)
CostaRica.3.1.1.1$Carga<-as.character(CostaRica.3.1.1.1$Carga)

```




#ciego costa rica 4



<!-- ```{r} -->
<!-- CostaRica.4.1.1<-CostaRica.4.1.1[,c(1,3,5,6,8,9)] -->
<!-- CostaRica.4.1.1<-data.frame(purrr::map(CostaRica.4.1.1, as.character ), -->
<!--                                stringsAsFactors = FALSE) -->
<!-- ``` -->

<!-- ```{r} -->

<!-- library(dplyr) -->

<!-- CostaRica.4.1.1 <- CostaRica.4.1.1 %>% rename(PCR.Cov = Virus) -->
<!-- CostaRica.4.1.1 <- CostaRica.4.1.1 %>% rename(fecha = protocolo) -->
<!-- library(dplyr) -->

<!-- CostaRica.4.1.1 <- CostaRica.4.1.1 %>% dplyr::select(spot.a.1, Carga, PCR.Cov, fecha, institucion, equipo) -->


<!-- CostaRica.4.1.1<-CostaRica.4.1.1[-1,] -->
<!-- ``` -->

<!-- #ciego costa rica 5 -->



<!-- ```{r} -->
<!-- CostaRica.5.1<-CostaRica.5.1[,c(1,3,5,6,8,9)] -->
<!-- CostaRica.5.1<-data.frame(purrr::map(CostaRica.5.1, as.character ), -->
<!--                                stringsAsFactors = FALSE) -->
<!-- ``` -->

<!-- ```{r} -->

<!-- library(dplyr) -->

<!-- CostaRica.5.1 <- CostaRica.5.1 %>% rename(PCR.Cov = Virus) -->
<!-- CostaRica.5.1 <- CostaRica.5.1 %>% rename(fecha = protocolo) -->
<!-- library(dplyr) -->

<!-- CostaRica.5.1 <- CostaRica.5.1 %>% dplyr::select(spot.a.1, Carga, PCR.Cov, fecha, institucion, equipo) -->

<!-- ``` -->



<!-- ```{r} -->
<!-- CostaRica.6.1<-CostaRica.6.1[,c(1,3,5,6,8,9)] -->
<!-- CostaRica.6.1<-data.frame(purrr::map(CostaRica.6.1, as.character ), -->
<!--                                stringsAsFactors = FALSE) -->
<!-- ``` -->

<!-- ```{r} -->

<!-- library(dplyr) -->

<!-- CostaRica.6.1 <- CostaRica.6.1 %>% rename(PCR.Cov = Virus) -->
<!-- CostaRica.6.1 <- CostaRica.6.1 %>% rename(fecha = protocolo) -->
<!-- library(dplyr) -->

<!-- CostaRica.6.1 <- CostaRica.6.1 %>% dplyr::select(spot.a.1, Carga, PCR.Cov, fecha, institucion, equipo) -->

<!-- ``` -->





<!-- ```{r} -->
<!-- Malbran_5_6.1<-Malbran_5_6.1[,c(1,3,6,7,8,9)] -->
<!-- Malbran_5_6.1<-data.frame(purrr::map(Malbran_5_6.1, as.character ), -->
<!--                                stringsAsFactors = FALSE) -->



<!-- #Malbran_5_6.1 <- Malbran_5_6.1 %>% rename(PCR.Cov = Virus) -->
<!-- Malbran_5_6.1 <- Malbran_5_6.1 %>% rename(fecha = protocolo) -->
<!-- library(dplyr) -->

<!-- Malbran_5_6.1<-Malbran_5_6.1 %>% dplyr::select(spot.a.1, Carga, PCR.Cov, fecha, institucion, equipo) -->
<!-- ``` -->




```{r}
dataframes <- list(INBIRS.1.df.f.1,
INBIRS.df.2.f,
INBIRS.df.3.f,
Espectros.INBIRS.4.f,
Categ.Hospi.1.Neg,
Categ.Hospi.1.Pos,
Categ.Hospi.2.Cnt,
Categ.Hospi.2.Neg,
Categ.Hospi.2.No.Covid,
Categ.Hospi.2.Pos,
Categ.Hospi.3.Neg,
Categ.Hospi.3.No.Covid,
Categ.Hospi.3.Pos,
Categ.Ciego.clin.1.Exp1.covid,
Categ.Ciego.clin.1.Exp1.flu,
Categ.Neg.New.clin.1,
Categ.Pos.New.clin.1,
Categ.Ciego.clin25.6.2.covid,
Categ.Ciego25.6.clin.2.flu,
Categ.Ciego_3_7.4,
Categ.Ciego_8_7.4,
Categ.Malbran.1.1.1,
Categ.Malbran.2.1.1,
Malbran_3_4.1,
CostaRica.1.1,
CostaRica.3.1.1.1)
# CostaRica.4.1.1,#ciego
# CostaRica.5.1,#ciego
# CostaRica.6.1, #ciego
# Malbran_5_6.1)




# Contar filas para cada dataframe
filas_count <- sapply(dataframes, nrow)

# Mostrar los resultados
print(filas_count)
sum(filas_count)
```

# 6. Union de todos los dataframes

```{r}
Base.Union.Clinc.Covid <- INBIRS.1.df.f.1 %>%
  bind_rows(INBIRS.df.2.f) %>%
  bind_rows(INBIRS.df.3.f) %>%
  bind_rows(Espectros.INBIRS.4.f) %>%
bind_rows(Categ.Hospi.1.Neg)%>%
bind_rows(Categ.Hospi.1.Pos)%>%
bind_rows(Categ.Hospi.2.Cnt)%>%
bind_rows(Categ.Hospi.2.Neg)%>%
bind_rows(Categ.Hospi.2.No.Covid)%>%
bind_rows(Categ.Hospi.2.Pos)%>%
bind_rows(Categ.Hospi.3.Neg)%>%
bind_rows(Categ.Hospi.3.No.Covid)%>%
bind_rows(Categ.Hospi.3.Pos)%>%
bind_rows(Categ.Ciego.clin.1.Exp1.covid)%>%
bind_rows(Categ.Ciego.clin.1.Exp1.flu)%>%
bind_rows(Categ.Neg.New.clin.1)%>%
bind_rows(Categ.Pos.New.clin.1)%>%
bind_rows(Categ.Ciego.clin25.6.2.covid)%>%
bind_rows(Categ.Ciego25.6.clin.2.flu)%>%
bind_rows(Categ.Ciego_3_7.4)%>%
bind_rows(Categ.Ciego_8_7.4)%>%
bind_rows(Categ.Malbran.1.1.1)%>%
bind_rows(Categ.Malbran.2.1.1)%>%
bind_rows(Malbran_3_4.1)%>%
bind_rows(CostaRica.1.1)%>%
bind_rows(CostaRica.3.1.1.1)
# bind_rows(CostaRica.4.1.1)%>%
# bind_rows(CostaRica.5.1)%>%
# bind_rows(CostaRica.6.1)%>%
# bind_rows(Malbran_5_6.1)
```

```{r}
Espectra.Orig <- data.frame(names(Espectra.1),
                                  stringsAsFactors = FALSE)
names(Espectra.Orig)<- c("spot.a.1")

Datos_actualizados<-  Espectra.Orig %>%
  left_join( Base.Union.Clinc.Covid, by="spot.a.1")
```




```{r}
save(Datos_actualizados, file = "metadata.rda")

```


```{r}
# dev.new()
# 
# # Inicializar el gr√°fico con el primer espectro
# plot(Espectra.1[[1]], main = "Espectros Superpuestos", col = "blue", type = "l")
# 
# # Iterar sobre los espectros restantes y agregarlos al gr√°fico
# for (i in 2:length(Espectra.1)) {
#   lines(Espectra.1[[i]], col = i)  # A√±adir l√≠neas para cada espectro, con diferentes colores
# }
# 
# # A√±adir una leyenda para indicar los colores de cada espectro
# legend("topright", legend = 1:length(Espectra.1), col = 1:length(Espectra.1),
#        title = "Espectros", cex = 0.8)
```

# 7. Deteccion y filtrado de picos

```{r , message=FALSE, echo=FALSE, warning=FALSE}

peaks <- detectPeaks(Espectra.1, SNR = 3, 
                     method="MAD", halfWindowSize=50)
peaks <- binPeaks(peaks,tolerance=0.5)

species.Ave<-factor(Datos_actualizados$PCR.Cov) 
spot.factor.Avera<-factor(Datos_actualizados$spot.a.1) 

peaks <- filterPeaks(peaks, minFrequency=c(0.2, 0.2),
                     labels = species.Ave,
                     mergeWhitelists=TRUE)

featureMatrix <- intensityMatrix(peaks, Espectra.1)
```


dejo tres decimales

```{r}
featureMatrix <- apply(featureMatrix, c(1, 2), function(x) signif(x, digits = 3))

```

```{r}
save(featureMatrix, file = "feature_matrix.rda")

```


```{r}
num_peaks <- sapply(peaks, length)
freq_table <- table(num_peaks)

# Mostrar la tabla
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Num_Peaks", "Frequency")

# Mostrar la tabla con cantidad de espectros con x cantidad de picos
print(freq_df)
```


```{r}
featureMatrix<- cbind(featureMatrix, label=Datos_actualizados$spot.a.1, covid=Datos_actualizados$PCR.Cov, carga=Datos_actualizados$Carga, dia=Datos_actualizados$batch, equipo=Datos_actualizados$equipo, fecha=Datos_actualizados$fecha, institucion=Datos_actualizados$institucion)
```


```{r}
featureMatrix <- as.data.frame(featureMatrix)
sum(is.na(featureMatrix$carga))


table(featureMatrix$carga, useNA = "ifany")
```


```{r}
subset(featureMatrix, carga %in% c("Cov.Pos", "Cov.Neg"))
```


```{r}
# 1Ô∏è‚É£ Paso previo: convierto featureMatrix a data.frame
featureMatrix <- as.data.frame(featureMatrix)

# 2Ô∏è‚É£ Creo vector auxiliar con los n√∫meros (los que no son n√∫mero quedar√°n NA en num, PERO no toco carga)
num <- suppressWarnings(as.numeric(as.character(featureMatrix$carga)))

# 3Ô∏è‚É£ Recategorizo SOLO los que son n√∫meros
featureMatrix$carga[!is.na(num) & num < 24]              <- "High"
featureMatrix$carga[!is.na(num) & num >= 24 & num <= 28] <- "Int"
featureMatrix$carga[!is.na(num) & num > 28]              <- "Low"


featureMatrix <- featureMatrix %>%
  filter(carga %in% c("High", "Int", "Neg"))


#esto es lo que perdimos:
#Cov.Neg Cov.Pos    High     Int     Low     Neg      SD    <NA> 
#  26      24      38      58      49     133     201      34 

```





Quedan 296 espectros con cargas HIGH INT y NEG. Aclaracion: como costa rica no coloco el dato, en carga solo dice Cov.Pos o neg, no se incluyen en el an√°lisis

```{r}
featureMatrix
```


# 8. EDA

```{r}


# Crear tabla de frecuencias
data_freq <- as.data.frame(table(Datos_actualizados$institucion, Datos_actualizados$PCR.Cov))
colnames(data_freq) <- c("institucion", "covid_status", "frecuencia")


# Gr√°fico de barras superpuestas
ggplot(data_freq, aes(x = institucion, y = frecuencia, fill = covid_status)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Frecuencia por Instituci√≥n",
       x = "Instituci√≥n",
       y = "Frecuencia") +
  scale_fill_manual(values = c("Cov.Neg" = "blue", "Cov.Pos" = "red")) +
  theme_minimal()
```

```{r}

print(data_freq)
```


```{r}


# Cargar la librer√≠a
#library(writexl)

# Exportar a Excel
#write.xlsx(data_freq, "C:/Users/karin/Desktop/MCD/TESIS/datafreq.xlsx")
```

```{r}
Datos_actualizados<- Datos_actualizados[ , -10]

Datos_actualizados$id <- 1:nrow(Datos_actualizados)
Datos_actualizados <- Datos_actualizados[ , c("id", names(Datos_actualizados)[-ncol(Datos_actualizados)])]
```

# 9 Matrices
## Matriz de intensidades con label

```{r}

# # Crear una nueva columna con secuencia del 1 hasta el n√∫mero de filas
# featureMatrix<- cbind(id=Datos_actualizados$id, featureMatrix) 
```

## Matriz numerica

```{r}
# Exclude non-numerical columns 
featureMatrix_num <- featureMatrix[, -c(1, (ncol(featureMatrix)-5):ncol(featureMatrix))]
```

```{r}
featureMatrix_num <- apply(featureMatrix_num, 2, function(x) as.numeric(as.character(x)))

```

```{r}
sapply(featureMatrix_num, class)
```

```{r}
class(featureMatrix_num)
```


```{r}
# Calcular estad√≠sticas por pico con conversi√≥n num√©rica
pico_stats <- function(featureMatrix_num) {
  # Convertimos la matriz a num√©rica, preservando los nombres de las columnas
  nombres_picos <- colnames(featureMatrix_num)
  
  # Convertimos la matriz a num√©rica
  featureMatrix_num <- apply(featureMatrix_num, 2, function(x) as.numeric(as.character(x)))
  colnames(featureMatrix_num) <- nombres_picos
  
  # Calculamos las estad√≠sticas
  stats <- data.frame(
    nombre_pico = nombres_picos,
    promedio = colMeans(featureMatrix_num, na.rm = TRUE),
    minimo = apply(featureMatrix_num, 2, min, na.rm = TRUE),
    maximo = apply(featureMatrix_num, 2, max, na.rm = TRUE),
    desv_std = apply(featureMatrix_num, 2, sd, na.rm = TRUE)
  )
  
  # A√±adimos el n√∫mero de pico
  stats$pico_numero <- 1:nrow(stats)
  
  # Reordenamos las columnas
  stats <- stats[, c("pico_numero", "nombre_pico", "promedio", "minimo", "maximo", "desv_std")]
  
  return(stats)
}

# Para usar la funci√≥n:
resultados <- pico_stats(featureMatrix_num)

# Ver los primeros resultados
head(resultados)

```



# 10. PCA mixOmics


```{r}
library(mixOmics)

#Performs a principal components analysis on the given data matrix that can contain missing values. If data are complete 'pca' uses Singular Value Decomposition, if there are some missing values, it uses the NIPALS algorithm.
```

```{r}
featureMatrix_num <- apply(featureMatrix_num, 2, as.numeric)

str(featureMatrix_num)
```

```{r}
?pca
```

```{r}

pca.before <- pca(featureMatrix_num, ncomp = 10)   #ncomp=	Integer, if data is complete ncomp decides the number of components and associated eigenvalues to display from the pcasvd algorithm and if the data has missing values, ncomp gives the number of components to keep to perform the reconstitution of the data using the NIPALS algorithm. If NULL, function sets ncomp = min(nrow(X), ncol(X))

```

```{r}
#pca.before$institucion <- Datos_actualizados$institucion
pca.before$fecha <- featureMatrix$fecha
pca.before$equipo <-featureMatrix$equipo
pca.before$covid<- featureMatrix$covid
```

```{r}
pca_coor<-as.data.frame(pca.before$variates$X) # Coordenadas principales obtenidas del PCA
pca.before$X

```

```{r}
dim(pca_coor)
```

```{r}
colnames(pca.before$variates$X) <- paste0("PC", 1:ncol((pca.before$variates$X)))
```

```{r}
library(ggExtra)
#expl_var <- pca.before$sdev^2 / sum(pca.before$sdev^2)  # Varianza explicada por cada componente

# Crear un gr√°fico de dispersi√≥n con ggplot2
p <- ggplot(pca_coor, aes(x = PC1, y = PC2, color = pca.before$equipo, shape = pca.before$covid)) +
  geom_point(size = 2) +  # Tama√±o de los puntos
  labs(title = 'PCA con mixOmics',
       x = 'Componente principal 1',
       y = 'Componente principal 2',
       color = 'Batch', shape = 'Tratamiento') +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12,),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 1),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
  )


# A√±adir gr√°ficos de densidad marginal con ggExtra
p_with_density <- ggMarginal(p, type = "density", margins = "both", groupColour = TRUE, groupFill = TRUE)

# Mostrar el gr√°fico final
print(p_with_density)
```

```{r}
nrow(pca_coor)        # deber√≠a dar 327
length(pca.before$equipo)  # ¬øtambi√©n 327?
length(pca.before$covid)   # igual que los dem√°s

```


```{r}
library(ggExtra)
#expl_var <- pca.before$sdev^2 / sum(pca.before$sdev^2)  # Varianza explicada por cada componente

# Crear un gr√°fico de dispersi√≥n con ggplot2
p <- ggplot(pca_coor, aes(x = PC2, y = PC3, color = pca.before$equipo, shape = pca.before$covid)) +
  geom_point(size = 2) +  # Tama√±o de los puntos
  labs(title = 'PCA con mixOmics',
       x = 'Componente principal 2',
       y = 'Componente principal 3',
       color = 'Batch', shape = 'Tratamiento') +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12,),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 1),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
  )


# A√±adir gr√°ficos de densidad marginal con ggExtra
p_with_density2 <- ggMarginal(p, type = "density", margins = "both", groupColour = TRUE, groupFill = TRUE)

# Mostrar el gr√°fico final
print(p_with_density2)
```


```{r}
library(ggExtra)
#expl_var <- pca.before$sdev^2 / sum(pca.before$sdev^2)  # Varianza explicada por cada componente

# Crear un gr√°fico de dispersi√≥n con ggplot2
p <- ggplot(pca_coor, aes(x = PC1, y = PC2, color = pca.before$covid)) +
  geom_point(size = 2) +  # Tama√±o de los puntos
  labs(title = 'PCA con mixOmics',
       x = 'Componente principal 1',
       y = 'Componente principal 2',
       color = 'Batch') +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12,),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 10),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 10),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 1),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 10),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 10)  # Reducir tama√±o del texto de la leyenda
  )


# A√±adir gr√°ficos de densidad marginal con ggExtra
p_with_density3 <- ggMarginal(p, type = "density", margins = "both", groupColour = TRUE, groupFill = TRUE)

# Mostrar el gr√°fico final
print(p_with_density3)
```

```{r}
# Extraer la varianza explicada
explained_var <- pca.before$prop_expl_var$X * 100  # Convertir a porcentaje
components <- seq_along(explained_var)  # Crear un √≠ndice para los componentes

# Crear un data frame para el gr√°fico
var_df <- data.frame(
  Component = components,
  ExplainedVariance = explained_var
)

# Graficar usando ggplot2
library(ggplot2)
explained_var_plot_MixOmics<- ggplot(var_df, aes(x = Component, y = ExplainedVariance)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes(label = round(ExplainedVariance, 1)), vjust = -0.5, size = 3) +

  labs(
    title = "Varianza explicada -MixOmics",
    x = "Componente Principal",
    y = "Varianza Explicada (%)"
  ) +
  theme_minimal()+
  theme(
    plot.title = element_text(size = 12,),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 1),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
  )

print(explained_var_plot_MixOmics)

```






# 11. PCA con prcomp

```{r}
# Perform PCA on numerical columns only
pca_res <- prcomp(featureMatrix_num, scale. = TRUE)

```




```{r}


porcentaje_varianza_explicada <- (pca_res$sdev^2 / sum(pca_res$sdev^2)) * 100
components <- seq_along(porcentaje_varianza_explicada) 


# Crear un data frame para el gr√°fico
var_df <- data.frame(
  Component = components,
  ExplainedVariance = porcentaje_varianza_explicada
)
 # Crear un √≠ndice para los componentes



var_df_10 <- var_df[1:10, ]

# Graficar usando ggplot2
library(ggplot2)
exaplained_var_plot_rbase<- ggplot(var_df_10, aes(x = Component, y = ExplainedVariance)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes(label = round(ExplainedVariance, 1)), vjust = -0.5, size = 3) +
    ylim(0, max(var_df_10$ExplainedVariance) * 1.1) +
  labs(
    title = "Varianza explicada",
    x = "Componente Principal",
    y = "Varianza Explicada (%)"
  ) +
  theme_minimal()+
    theme(
    plot.title = element_text(size = 12, face = "bold"),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 10),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 10),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 10)  # Reducir tama√±o del texto de la leyenda
  )


print(exaplained_var_plot_rbase)
```






```{r}
summary(pca_res)
```

```{r}

# Now you can add back the categorical data for plotting purposes
pca_data <- as.data.frame(pca_res$x)
#pca_data$institucion <- Datos_actualizados$institucion
pca_data$fecha <- featureMatrix$fecha
pca_data$equipo <- featureMatrix$equipo
pca_data$covid<- featureMatrix$covid

```

```{r}
# pca_prcomp<- ggplot(pca_data, aes(x = PC1, y = PC2, color = equipo, shape = covid)) +
#   geom_point(size = 2) + # Tama√±o de los puntos
#   labs(title = "PCA - PC1 y PC2 R base",
#        x = "Componente Principal 1",
#        y = "Componente Principal 2") +
#   scale_color_manual(values = c( "blue", "green", "purple")) + # Personaliza los colores si es necesario
#   scale_shape_manual(values = c(16, 17)) + # Personaliza las formas si es necesario
#   theme_minimal()+
#   theme_minimal()+
#     theme(
#     plot.title = element_text(size = 12, face = "bold"),  # Reducir tama√±o del t√≠tulo
#     axis.title.x = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje X
#     axis.title.y = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje Y
#     axis.text = element_text(size = 1),  # Reducir tama√±o de los textos de los ejes
#     legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
#     legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
#   )
# print(pca_prcomp)
plot_pca <- function(data, x, y, color_by = NULL, shape_by = NULL,
                     title = "PCA", shape_manual = c(16,17),
                     size = 2, usar_paleta_auto = FALSE) {
  
  aes_base <- aes(x = {{ x }}, y = {{ y }})
  
  if (!is.null(color_by)) aes_base <- modifyList(aes_base, aes(color = .data[[color_by]]))
  if (!is.null(shape_by)) aes_base <- modifyList(aes_base, aes(shape = .data[[shape_by]]))
  
  p <- ggplot(data, aes_base) +
    geom_point(size = size) +
    labs(title = title,
         x = paste("Componente Principal", gsub("PC", "", deparse(substitute(x)))),
         y = paste("Componente Principal", gsub("PC", "", deparse(substitute(y))))) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 12, face = "bold"),
      axis.title.x = element_text(size = 12),
      axis.title.y = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 12)
    )
  
  if (!is.null(color_by) && usar_paleta_auto) {
    n_colors <- length(unique(data[[color_by]]))
    if (n_colors <= 8) {
      p <- p + scale_color_brewer(palette = "Dark2")  # Cambia si quer√©s otra
    } else {
      p <- p + scale_color_viridis_d(option = "turbo")
    }
  }
  
  if (!is.null(shape_by)) {
    p <- p + scale_shape_manual(values = shape_manual)
  }
  
  return(p)
}

```

```{r}
# Gr√°ficos PCA usando la funci√≥n
plot_pca(pca_data, PC1, PC2, color_by = "equipo", shape_by = "covid",
         title = "PCA - PC1 y PC2 por equipo", usar_paleta_auto = TRUE)

```

```{r}
plot_pca(pca_data, PC2, PC3, color_by = "equipo", shape_by = "covid", 
         title = "PCA - PC2 vs PC3 por equipo y pos/neg", usar_paleta_auto = TRUE)
```

```{r}
plot_pca(pca_data, PC1, PC2, color_by = "fecha", shape_by = "covid",
         title = "PCA - PC1 vs PC2 por fecha",
         usar_paleta_auto = TRUE)

```

```{r}
plot_pca(pca_data, PC1, PC2, color_by = "covid", shape_by = "covid", 
         title = "PCA - PC1 vs PC2 COV POS/NEG", usar_paleta_auto = TRUE)
```


```{r}
plot_pca(pca_data, PC1, PC3, color_by = "covid", shape_by = "covid", 
         title = "PCA - PC1 vs PC3 COV POS/NEG", usar_paleta_auto = TRUE)
```

```{r}
# pca_prcomp2<-ggplot(pca_data, aes(x = PC2, y = PC3, color = equipo, shape = covid)) +
#   geom_point(size = 2) + # Tama√±o de los puntos
#   labs(title = "PCA - PC2 y PC3- R base",
#        x = "Componente Principal 2",
#        y = "Componente Principal 3") +
#   scale_color_manual(values = c( "blue", "green", "purple")) + # Personaliza los colores si es necesario
#   scale_shape_manual(values = c(16, 17)) + # Personaliza las formas si es necesario
#   theme_minimal()+
#   theme_minimal()+
#     theme(
#     plot.title = element_text(size = 12, face = "bold"),  # Reducir tama√±o del t√≠tulo
#     axis.title.x = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje X
#     axis.title.y = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje Y
#     axis.text = element_text(size = 1),  # Reducir tama√±o de los textos de los ejes
#     legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
#     legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
#   )
# 
# print(pca_prcomp2)
```

```{r}
# ggplot(pca_data, aes(x = PC1, y = PC2, color = institucion, shape = covid)) +
#   geom_point(size = 3) + # Tama√±o de los puntos
#   labs(title = "PCA - Componentes Principales",
#        x = "Componente Principal 1",
#        y = "Componente Principal 2") +
#   scale_color_manual(values = c( "red","blue", "green", "purple")) + # Personaliza los colores si es necesario
#   scale_shape_manual(values = c(16, 17)) + # Personaliza las formas si es necesario
#   theme_minimal() # O puedes usar otro tema si prefieres
```

```{r}
# ggplot(pca_data, aes(x = PC1, y = PC2, color = fecha, shape = covid)) +
#   geom_point(size = 3) + # Tama√±o de los puntos
#   labs(title = "PCA - Componentes Principales",
#        x = "Componente Principal 1",
#        y = "Componente Principal 2") +
#   scale_color_manual(values = c( "red", "blue", "green", "purple", "orange", "pink", "yellow", "cyan", "brown", "magenta", "gray", "black", "darkgreen", "darkblue")) +
#   scale_shape_manual(values = c(16, 17)) +
#   theme_minimal()

```

```{r}
# valores_unicos_fecha <- unique(featureMatrix[,"fecha"])
# 
# # Mostrar los valores √∫nicos
# print(valores_unicos_fecha)
```

```{r}
# pos_neg<- ggplot(pca_data, aes(x = PC1, y = PC2, color=covid, shape = covid)) +
#   geom_point(size = 2) + # Tama√±o de los puntos
#   labs(title = "PCA - COV POS/NEG",
#        x = "Componente Principal 1",
#        y = "Componente Principal 2") +
#  scale_color_manual(values = c( "red","blue"))+
#   scale_shape_manual(values = c(16, 17)) +
#   theme_minimal()+
#     theme(
#     plot.title = element_text(size = 12, face = "bold"),  # Reducir tama√±o del t√≠tulo
#     axis.title.x = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje X
#     axis.title.y = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje Y
#     axis.text = element_text(size = 1),  # Reducir tama√±o de los textos de los ejes
#     legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
#     legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
#   )
# 
# 
# print(pos_neg)
```

```{r}
# ggplot(pca_data, aes(x = pca_data$PC1, y = pca_data$PC3, color=covid, shape = covid)) +
#   geom_point(size = 3) + # Tama√±o de los puntos
#   labs(title = "PCA - Componentes Principales",
#        x = "Componente Principal 1",
#        y = "Componente Principal 3") +
#  scale_color_manual(values = c( "red","blue"))+
#   scale_shape_manual(values = c(16, 17)) +
#   theme_minimal()
```







# 12. UMAP

```{r}
library(umap)
set.seed(42)

```

```{r}

library(uwot)
```

```{r}
set.seed(123)
umap_result <- umap(featureMatrix_num)
```

```{r}
umap_df <- as.data.frame(umap_result)
colnames(umap_df) <- c("V1", "V2")
```

```{r}
#umap_df$institucion <- Datos_actualizados$institucion
umap_df$fecha <- featureMatrix$fecha
umap_df$equipo <- featureMatrix$equipo
umap_df$covid<- featureMatrix$covid
```

```{r}
plot_umap <- function(data, x, y, color_by = NULL, shape_by = NULL,
                      title = "UMAP", shape_manual = c(16, 17), size = 2,
                      usar_paleta_auto = FALSE, color_manual = NULL) {

  aes_base <- aes(x = {{ x }}, y = {{ y }})
  if (!is.null(color_by)) aes_base <- modifyList(aes_base, aes(color = .data[[color_by]]))
  if (!is.null(shape_by)) aes_base <- modifyList(aes_base, aes(shape = .data[[shape_by]]))

  p <- ggplot(data, aes_base) +
    geom_point(size = size) +
    labs(title = title,
         x = deparse(substitute(x)),
         y = deparse(substitute(y))) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 16),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 12)
    )

  if (!is.null(color_manual)) {
    p <- p + scale_color_manual(values = color_manual)
  } else if (!is.null(color_by) && usar_paleta_auto) {
    n_colors <- length(unique(data[[color_by]]))
    if (n_colors <= 8) {
      p <- p + scale_color_brewer(palette = "Dark2")
    } else {
      p <- p + scale_color_viridis_d(option = "turbo")
    }
  }

  if (!is.null(shape_by)) {
    p <- p + scale_shape_manual(values = shape_manual)
  }

  return(p)
}

```



```{r}
plot_umap(umap_df, V1, V2, color_by = "equipo", shape_by = "covid",
          title = "UMAP base", usar_paleta_auto = TRUE)

```


```{r}
plot_umap(umap_df, V1, V2, color_by = "covid", shape_by = "covid",
          title = "UMAP para Detecci√≥n de Efectos de Batch", usar_paleta_auto = TRUE)

```

```{r}
UMAP_base<-plot_umap(umap_df, V1, V2, color_by = "fecha", shape_by = "covid",
          title = "UMAP por fecha", usar_paleta_auto = TRUE)
UMAP_base
```




```{r}

# UMAP_base<- ggplot(umap_df, aes(x = V1, y = V2, color = equipo, shape=covid)) +
#   geom_point(size = 2) +
#   labs(title = "UMAP base", x = "UMAP1", y = "UMAP2") +
#   theme_minimal()+
#   theme(
#     plot.title = element_text(size = 16),  # Reducir tama√±o del t√≠tulo
#     axis.title.x = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje X
#     axis.title.y = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje Y
#     axis.text = element_text(size = 10),  # Reducir tama√±o de los textos de los ejes
#     legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
#     legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
#   )
#     
#     
#   
#     print(UMAP_base)
```

```{r}

# ggplot(umap_df, aes(x = V1, y = V2, color = covid, shape=covid)) +
#   geom_point() +
#   labs(title = "UMAP para Detecci√≥n de Efectos de Batch", x = "UMAP1", y = "UMAP2") +
#     scale_shape_manual(values = c(16, 17)) +
#   theme_minimal()

```

```{r}
# ggplot(umap_df,aes(x = V1, y = V2, color = fecha, shape=covid)) +
#   geom_point(size = 3) + # Tama√±o de los puntos
#   labs(title = "UMAP POR FECHA",
#        x = "UMAP 1",
#        y = "UMAP 2") +
#   scale_color_manual(values = c( "red", "blue", "green", "purple", "orange", "pink", "yellow", "cyan", "brown", "magenta", "gray", "black", "darkgreen", "darkblue")) +
#   scale_shape_manual(values = c(16, 17)) +
#   theme_minimal() # O puedes usar otro tema si prefieres
```

```{r}
#UMAP intenta encontrar una representaci√≥n (no lineal) de pocas dimensiones de los datos que preserve las distancias entre cada puntos y sus vecinos en el espacio multi-dimensional

#Comparison among PCA, t-SNE and UMAP : https://aurigait.com/blog/blog-easy-explanation-of-dimensionality-reduction-and-techniques/



library(umap)


# Ajustar par√°metros directamente en la funci√≥n umap
umap_v2 <- umap(featureMatrix_num, n_neighbors = 15, metric = "euclidean", min_dist = 0.5)

# Verificar la estructura del objeto umap_v2
str(umap_v2) # Esto te mostrar√° la estructura para asegurarte de que layout es un componente v√°lido.

# Si la estructura es correcta, continuar con la conversi√≥n a dataframe
umap_coor2 <- as.data.frame(umap_v2)

# Asignar nombres de columnas
colnames(umap_coor2) <- c("UMAP1", "UMAP2")

# A√±adir las columnas con los metadatos (COVID, equipo, etc.)
umap_coor2$covid <- featureMatrix$covid
umap_coor2$equipo <- featureMatrix$equipo

UMAP_ajustado<-plot_umap(umap_coor2, UMAP1, UMAP2, color_by  = "equipo", shape_by = "covid",
          title = "UMAP2 por equipo", usar_paleta_auto = TRUE)
UMAP_ajustado


```



```{r}

library(patchwork)
combined_plot <- (
  UMAP_base + UMAP_ajustado
)

# Agregar t√≠tulos a cada gr√°fico
combined_plot_UMAP <- combined_plot + 
  plot_annotation(
    title = "UMAP",
    tag_levels = "A"  # Etiquetas A, B, C, ...
  ) + 
  plot_layout(guides = "collect")  # Para combinar las leyendas, si hay

# Mostrar el gr√°fico combinado
print(combined_plot_UMAP)


```
```{r}
ggsave(
  filename = "combined_plot_UMAP.png",
  plot = combined_plot_UMAP,
  width = 12,
  height = 10,
  dpi = 300
)
```



# 13. t-SNE

```{r}
#tsne
library(Rtsne)
library(ggplot2)
library(readxl)
library(RColorBrewer)
```

```{r}
?Rtsne
```

```{r}
set.seed(9)
tsne_model <- Rtsne(featureMatrix_num, check_duplicates=FALSE, 
                      pca=TRUE, perplexity=30, theta=0.5, dims=3)
```

```{r}
#tsne_model$institucion <- Datos_actualizados$institucion
tsne_model$fecha <- Datos_actualizados$fecha
tsne_model$equipo <- Datos_actualizados$equipo
tsne_model$covid<- Datos_actualizados$PCR.Cov
```

```{r}
tsne_data <- as.data.frame(tsne_model$Y)
colnames(tsne_data) <- c("Dim1", "Dim2","Dim3")
```

```{r}
#tsne_data$institucion <- Datos_actualizados$institucion
tsne_data$fecha <- featureMatrix$fecha
tsne_data$equipo <- featureMatrix$equipo
tsne_data$covid<- featureMatrix$covid
```

```{r}
# tSNE<-ggplot(tsne_data, aes(x=Dim1, y=Dim2, color=equipo, shape = covid)) +
#   geom_point(size=2, alpha=0.7) +
#   ggtitle("t-SNE 1 y 2") +
#   theme_minimal(base_size=15) +
#     theme(
#     plot.title = element_text(size = 16),  # Reducir tama√±o del t√≠tulo
#     axis.title.x = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje X
#     axis.title.y = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje Y
#     axis.text = element_text(size = 10),  # Reducir tama√±o de los textos de los ejes
#     legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
#     legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
#   )
#   scale_color_manual(values=c("#D32F2F", "#1976D2", "#388E3C"))  # Use a color palette
#   print(tSNE)
# ```
# 
# 
# 
# ```{r}
# tSNE2<-ggplot(tsne_data, aes(x=Dim2, y=Dim3, color=equipo, shape=covid)) +
#   geom_point(size=2, alpha=0.7) +
#   ggtitle("t-SNE 2 y 3") +
#   theme_minimal(base_size=15) +
#     theme(
#     plot.title = element_text(size = 16),  # Reducir tama√±o del t√≠tulo
#     axis.title.x = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje X
#     axis.title.y = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje Y
#     axis.text = element_text(size = 10),  # Reducir tama√±o de los textos de los ejes
#     legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
#     legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
#   )
#   scale_color_manual(values=c("#D32F2F", "#1976D2", "#388E3C"))  # Use a color palette
#   print(tSNE2)
```

```{r}
plot_tsne <- function(data, x, y, color_by = NULL, shape_by = NULL,
                      title = "t-SNE", shape_manual = c(16, 17), size = 2, alpha = 0.7,
                      usar_paleta_auto = FALSE, color_manual = NULL) {
  
  aes_base <- aes(x = {{ x }}, y = {{ y }})
  if (!is.null(color_by)) aes_base <- modifyList(aes_base, aes(color = .data[[color_by]]))
  if (!is.null(shape_by)) aes_base <- modifyList(aes_base, aes(shape = .data[[shape_by]]))
  
  p <- ggplot(data, aes_base) +
    geom_point(size = size, alpha = alpha) +
    ggtitle(title) +
    theme_minimal(base_size = 15) +
    theme(
      plot.title = element_text(size = 16),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 12)
    )
  
  if (!is.null(color_manual)) {
    p <- p + scale_color_manual(values = color_manual)
  } else if (!is.null(color_by) && usar_paleta_auto) {
    n_colors <- length(unique(data[[color_by]]))
    if (n_colors <= 8) {
      p <- p + scale_color_brewer(palette = "Dark2")
    } else {
      p <- p + scale_color_viridis_d(option = "turbo")
    }
  }
  
  if (!is.null(shape_by)) {
    p <- p + scale_shape_manual(values = shape_manual)
  }
  
  return(p)
}

```


```{r}


library(patchwork)

# Crear gr√°ficos con la funci√≥n
g1 <- plot_tsne(tsne_data, Dim1, Dim2, color_by = "equipo", shape_by = "covid", 
                title = "t-SNE 1 y 2", usar_paleta_auto = TRUE)

g2 <- plot_tsne(tsne_data, Dim2, Dim3, color_by = "equipo", shape_by = "covid", 
                title = "t-SNE 2 y 3", usar_paleta_auto = TRUE)

# Combinarlos con patchwork
combined_plot_tSNE_carga <- (g1 | g2) +
  plot_annotation(
    title = "t-SNE por equipo",
    tag_levels = "A"
  ) +
  plot_layout(guides = "collect")

# Mostrar
print(combined_plot_tSNE_carga)



```




```{r}
ggsave(
  filename = "combined_plot_tSNE_carga.png",
  plot = combined_plot_tSNE_carga,
  width = 12,
  height = 10,
  dpi = 300
)
```

# 14. Imposibilidad de analizar Cts:

```{r}

cantidad_sd_0_na <- sum(Datos_actualizados$Carga %in% c("SD", "0") | is.na(Datos_actualizados$Carga))

# Mostrar el resultado
cantidad_sd_0_na
```

```{r}
valores_unicos <- unique(Datos_actualizados$Carga)
print(valores_unicos)

```
```{r}
frecuencias <- table(Datos_actualizados$Carga)
print(frecuencias)
```



```{r}
library(dplyr)
# Convertir las variables categ√≥ricas en factores
Datos_actualizados <- Datos_actualizados[,c(1:7)] %>%
  mutate(across(c(PCR.Cov, fecha, equipo), as.factor))

# Convertir la matriz de datos a una matriz num√©rica si a√∫n no lo es
featureMatrix_num <- as.matrix(featureMatrix_num)

```

```{r}
# Prueba de normalidad: Prop√≥sito: Verificar si las puntuaciones de los componentes principales siguen una distribuci√≥n normal.
shapiro.test(pca.before$X[, 1])

# Prueba de homocedasticidad: Prop√≥sito: Evaluar si las varianzas entre grupos (definidos por un factor como PCR.Cov) son iguales. Algunas pruebas estad√≠sticas (como ANOVA) requieren homogeneidad de varianzas.

library(car)
leveneTest(pca.before$X[, 1] ~ featureMatrix$covid)

```




```{r}
# Inicializar un dataframe para almacenar los resultados
shapiro_results <- data.frame(Componente = integer(), PValue = numeric(), stringsAsFactors = FALSE)

# Iterar sobre cada componente principal
for (i in 1:ncol(pca.before$X)) {
  p_value <- shapiro.test(pca.before$X[, i])$p.value
  shapiro_results <- rbind(shapiro_results, data.frame(Componente = i, PValue = p_value))
}

# Visualizar los resultados
print(shapiro_results)

```

# 15. Kruskal wallis
para detectar el peso de cada factor en el efecto batch. Prop√≥sito: Evaluar si las puntuaciones del PCA difieren significativamente entre los niveles de un factor (como PCR.Cov, fecha o equipo).
Kruskal-Wallis es una prueba no param√©trica que no asume normalidad, lo que la hace adecuada si los datos no pasan la prueba de Shapiro-Wilk.

```{r}
# Cargar librer√≠as necesarias
library(ggplot2)
library(dplyr)

# 1. Realizar PCA
pca_result <- prcomp(featureMatrix_num, scale. = TRUE)

# 2. Obtener las puntuaciones de los componentes principales
pca_scores <- pca_result$x

Datos_actualizados <- as.data.frame(Datos_actualizados)

# 2Ô∏è‚É£ Creo vector auxiliar con los n√∫meros (los que no son n√∫mero quedar√°n NA en num, PERO no toco carga)
num <- suppressWarnings(as.numeric(as.character(Datos_actualizados$Carga)))

# 3Ô∏è‚É£ Recategorizo SOLO los que son n√∫meros
Datos_actualizados$Carga[!is.na(num) & num < 24]              <- "High"
Datos_actualizados$Carga[!is.na(num) & num >= 24 & num <= 28] <- "Int"
Datos_actualizados$Carga[!is.na(num) & num > 28]              <- "Low"

# 4Ô∏è‚É£ Filtro la columna carga para quedarme con lo que quiero:
# High, Int, Low, SD (NO me traigo NA ni otras cosas raras)
featureMatrix <- featureMatrix %>%
  filter(carga %in% c("High", "Int", "Neg"))
datos_filtrados <- Datos_actualizados %>%
  filter(Carga %in% c("High", "Int", "Neg"))

# 3. Agregar los resultados PCA al dataframe de metadatos
metadata_pca <- cbind(datos_filtrados[,c(4:7)], pca_scores)



# 4. Funci√≥n para realizar Kruskal-Wallis sobre los componentes principales
kruskal_pca <- function(pca_scores, metadata, factor) {
  results <- data.frame()
  for (i in 1:ncol(pca_scores)) {  # Para cada componente principal
    pca_component <- pca_scores[, i]  # Extraer la puntuaci√≥n del componente
    model <- kruskal.test(pca_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
    factor_effect <- model$p.value  # Obtener el p-valor
    results <- rbind(results, data.frame(PC = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
  }
  return(results)
}

# 5. Lista de factores que quieres analizar

# 5. Lista de factores que quieres analizar
factors <- c("PCR.Cov", "fecha", "equipo")

# Ejecutar la funci√≥n para cada factor y combinar los resultados
kruskal_results <- do.call(rbind, lapply(factors, function(f) kruskal_pca(pca_scores, datos_filtrados, f)))

# 6. Resumir el p-valor medio para cada factor
factor_summary <- kruskal_results %>%
  group_by(Factor) %>%
  summarise(MeanLogPValue = -log10(mean(PValue)))

pca_kruskal<- ggplot(factor_summary, aes(x = reorder(Factor, MeanLogPValue), y = MeanLogPValue, fill = Factor)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Importancia de los Factores PCA",
       x = "Factor",
       y = "-log10(P-valor Medio)",
       fill = "Factor")
    theme(
    plot.title = element_text(size = 30),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 26),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 26),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 18),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 24),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 24)  # Reducir tama√±o del texto de la leyenda
  )
print(pca_kruskal)
```

# 16. Kruskal wallis 
para detectar el peso de cada factor en el efecto batch en analisis de UMAP

```{r}
# Prueba de normalidad Shapiro-Wilk en la primera dimensi√≥n de UMAP
shapiro.test(umap_v2[, 1])

# Prueba de normalidad Shapiro-Wilk en la segunda dimensi√≥n de UMAP
shapiro.test(umap_v2[, 2])


```

```{r}

umap_scores <- umap_v2  # Tomar el resultado de UMAP directamente

# Luego sigues con el mismo an√°lisis
metadata_umap <-cbind(datos_filtrados[,c(4:7)] , umap_scores)
 

# Funci√≥n para realizar Kruskal-Wallis sobre las dimensiones de UMAP
kruskal_umap <- function(umap_scores, metadata, factor) {
  results <- data.frame()
  for (i in 1:ncol(umap_scores)) {  # Para cada dimensi√≥n de UMAP
    umap_component <- umap_scores[, i]  # Extraer la puntuaci√≥n de la dimensi√≥n
    model <- kruskal.test(umap_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
    factor_effect <- model$p.value  # Obtener el p-valor
    results <- rbind(results, data.frame(UMAP_Dim = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
  }
  return(results)
}

# Lista de factores que quieres analizar
factors <- c("PCR.Cov", "fecha", "equipo")



# Ejecutar la funci√≥n para cada factor y combinar los resultados


kruskal_results_umap <- do.call(rbind, lapply(factors, function(f) kruskal_umap(umap_scores, datos_filtrados, f)))

# Resumir el p-valor medio para cada factor
factor_summary_umap <- kruskal_results_umap %>%
  group_by(Factor) %>%
  summarise(MeanPValue = mean(PValue))

# Visualizar los resultados en un gr√°fico de barras
factor_summary <- kruskal_results_umap %>%
  group_by(Factor) %>%
  summarise(MeanLogPValue = -log10(mean(PValue)))

UMAP_kruskal<- ggplot(factor_summary, aes(x = reorder(Factor, MeanLogPValue), y = MeanLogPValue, fill = Factor)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Importancia de los Factores-UMAP",
       x = "Factor",
       y = "-log10(P-valor Medio)",
       fill = "Factor")
    theme(
    plot.title = element_text(size = 30),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 26),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 26),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 18),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 24),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 24)  # Reducir tama√±o del texto de la leyenda
  )
print(UMAP_kruskal)
```



```{r}
library(patchwork)
combined_plot <- (
  pca_kruskal+UMAP_kruskal
)

# Agregar t√≠tulos a cada gr√°fico
combined_plot_kruskal <- combined_plot + 
  plot_annotation(
    title = "Influencia de los factores en los datos",
    tag_levels = "A"  # Etiquetas A, B, C, ...
  ) + 
  plot_layout(guides = "collect")  # Para combinar las leyendas, si hay

# Mostrar el gr√°fico combinado
print(combined_plot_kruskal)
```


```{r}
ggsave(
  filename = "combined_plot_kruskal.png",
  plot = combined_plot_kruskal,
  width = 12,
  height = 10,
  dpi = 400
)
```



```{r}
dim(featureMatrix_num)
dim(Datos_actualizados)
```





## 17 Clustering



```{r}
library(dendextend)

distancias <- dist(featureMatrix_num)

# Realizar el clustering jer√°rquico
hc <- hclust(distancias, method = "ward.D2")

# Convierte el dendrograma a un objeto de dendextend
dend <- as.dendrogram(hc)

# Crea un vector de colores basado en PCR.cov
# Cambia "PCR.cov" a la columna adecuada de Datos_actualizados
label_colors <- as.factor(Datos_actualizados$PCR.Cov)
palette <- c("red", "blue") # Cambia los colores si hay m√°s de 2 categor√≠as
label_colors <- palette[label_colors]

# Aplica los colores a las etiquetas
dend <- dend %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.5) # Ajusta el tama√±o de las etiquetas

# Dibuja el dendrograma
png("dendrograma_COVID.png", width = 800, height = 600)
plot(dend, main = "Dendrograma por resultado COVID")
legend("topright",
       legend = c("COVID Negativo", "COVID Positivo"),
       fill = c("red", "blue"),
       border = "black",
       bty = "n",
       cex = 0.8)
dev.off() 

COVID_clustering<-plot(dend, main = "Dendrograma por resultado COVID")
legend("topright",           # Posici√≥n de la leyenda
       legend = c("COVID Negativo", "COVID Positivo"), # Textos de la leyenda
       fill = c("red", "blue"),                        # Colores de la leyenda
       border = "black",                               # Borde de las cajas de color
       bty = "n",                                      # Sin caja alrededor de la leyenda
       cex = 0.8)    


print(COVID_clustering)
```



```{r}
table(Datos_actualizados$PCR.Cov, label_colors)

```


 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_pos <- datos_filtrados$PCR.Cov == "Cov.Pos"
featureMatrix_cov_pos <- featureMatrix_num[indices_cov_pos, ]
datos_filtrados_cov_pos <- datos_filtrados[indices_cov_pos, ]

# Verificar que los datos est√©n filtrados correctamente
dim(featureMatrix_cov_pos)
table(datos_filtrados_cov_pos$equipo)


# Realizar el clustering jer√°rquico
dist_featureMatriz_cov_pos <- dist(featureMatrix_cov_pos)
hc_cov_pos <- hclust(dist_featureMatriz_cov_pos, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_pos <- as.dendrogram(hc_cov_pos)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- factor(datos_filtrados_cov_pos$equipo, levels = c("CR", "HC", "Malbran"))
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]

# Personalizar el dendrograma

dend_cov_pos <- dend_cov_pos %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

png("dendrograma_COVID.pos.png", width = 800, height = 600)
plot(dend_cov_pos, main = "Clustering de Positivos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")
dev.off()

# Visualizar el dendrograma
plot(dend_cov_pos, main = "Clustering de Positivos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")

```


 
 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_neg <- datos_filtrados$PCR.Cov == "Cov.Neg"
featureMatrix_cov_neg <- featureMatrix_num[indices_cov_neg, ]
datos_filtrados_cov_neg <- datos_filtrados[indices_cov_neg, ]

# Verificar que los datos est√©n filtrados correctamente
dim(featureMatrix_cov_neg)
table(datos_filtrados_cov_neg$equipo)

# Realizar el clustering jer√°rquico
dist_featureMatriz_cov_neg <- dist(featureMatrix_cov_neg)
hc_cov_neg <- hclust(dist_featureMatriz_cov_neg, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_neg <- as.dendrogram(hc_cov_neg)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(datos_filtrados_cov_neg$equipo)
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]

# Personalizar el dendrograma
dend_cov_neg <- dend_cov_neg %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas


png("dendrograma_COVID.neg.png", width = 800, height = 600)
plot(dend_cov_neg, main = "Clustering de Negativos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")
dev.off()

# Visualizar el dendrograma
plot(dend_cov_neg, main = "Clustering de Negativos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")

```
 



 
```{r}

# Extraer solo las filas que corresponden a los equipos en featureMatrix_num
# Aseg√∫rate de que Datos_actualizados$equipo tenga valores v√°lidos para subindexar.
featureMatrix_equipo <- featureMatrix_num

# Verificar que los datos est√©n filtrados correctamente
table(datos_filtrados$equipo)

# Calcular la matriz de distancias y realizar el clustering jer√°rquico
dist_featureMatriz_eq <- dist(featureMatrix_equipo)
hc_eq <- hclust(dist_featureMatriz_eq, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_eq <- as.dendrogram(hc_eq)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(datos_filtrados$equipo)
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]           # Asignar colores por equipo

# Personalizar el dendrograma
dend_eq <- dend_eq %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

png("dendrograma_COVID.equipo.png", width = 800, height = 600)
plot(dend_eq, main = "Clustering Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")
dev.off()

# Visualizar el dendrograma
plot(dend_eq, main = "Clustering Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")


```
```{r}


datos_filtrados$fecha <- as.factor(datos_filtrados$fecha)

# Matriz de caracter√≠sticas (featureMatrix_num)
featureMatrix_fecha <- featureMatrix_num

# Calcular la matriz de distancias y realizar el clustering jer√°rquico
dist_featureMatriz_fecha <- dist(featureMatrix_fecha)
hc_fecha <- hclust(dist_featureMatriz_fecha, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_fecha <- as.dendrogram(hc_fecha)

# Crear un vector de colores para las etiquetas basado en 'fecha'
fecha_factor <- datos_filtrados$fecha
palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
label_colors <- palette[fecha_factor]           # Asignar colores por fecha

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'fecha'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

# Visualizar el dendrograma
library(RColorBrewer)

# Crear una paleta m√°s contrastante
num_colores <- length(levels(fecha_factor))
palette <- brewer.pal(n = min(num_colores, 12), name = "Paired") # M√°x. 12 colores contrastantes
if (num_colores > 12) {
  palette <- colorRampPalette(brewer.pal(12, "Paired"))(num_colores) # Extender paleta si es necesario
}

# Aplicar los nuevos colores
label_colors <- palette[fecha_factor]

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.6)

png("dendrograma_fecha.png", width = 800, height = 600)
plot(dend_fecha, main = "Clustering Diferenciado por Fecha")
legend(
  "topright",
  legend = levels(fecha_factor),
  col = palette,
  pch = 19,
  title = "Fecha",
  cex = 0.7,
  bty = "n"
)
dev.off()

# Dibujar el dendrograma
plot(dend_fecha, main = "Clustering Diferenciado por Fecha")
legend(
  "topright",
  legend = levels(fecha_factor),
  col = palette,
  pch = 19,
  title = "Fecha",
  cex = 0.7,
  bty = "n"
)


```


 
 
```{r}
plot_dendrogram <- function(data_matrix, labels_vector, titulo = "Dendrograma", nombre_png = NULL,
                            colores = NULL, cex = 0.6, method = "ward.D2", titulo_leyenda = NULL,
                            palette_type = c("auto", "brewer")) {

  palette_type <- match.arg(palette_type)

  # Calcular matriz de distancias
  distancias <- dist(data_matrix)

  # Clustering jer√°rquico
  hc <- hclust(distancias, method = method)
  dend <- as.dendrogram(hc)

  # Preparar factores y colores
  factor_labels <- as.factor(labels_vector)
  n_levels <- length(levels(factor_labels))

  # Selecci√≥n de paleta de colores
  if (is.null(colores)) {
    if (palette_type == "brewer") {
      if (n_levels <= 9) {
        colores <- RColorBrewer::brewer.pal(n_levels, "Set3")
      } else {
        colores <- colorRampPalette(RColorBrewer::brewer.pal(9, "Set3"))(n_levels)
      }
    } else {
      colores <- rainbow(n_levels)
    }
  }

  label_colors <- colores[factor_labels]

  # Asignar colores y tama√±o de etiquetas
  dend <- dend %>%
    set("labels_col", label_colors) %>%
    set("labels_cex", cex)

  # Ajustar m√°rgenes para evitar superposici√≥n
  old_par <- par(no.readonly = TRUE)  # guardar config previa
  par(mar = c(10, 4, 4, 2))            # ampliar margen inferior

  # T√≠tulo de la leyenda
  if (is.null(titulo_leyenda)) {
    titulo_leyenda <- deparse(substitute(labels_vector))
  }

  # Exportar si se especific√≥ archivo PNG
  if (!is.null(nombre_png)) {
    png(nombre_png, width = 1800, height = 1000, res = 150)
    plot(dend, main = titulo, las = 2)
    legend("topright", legend = levels(factor_labels), col = colores, pch = 19,
           title = titulo_leyenda, cex = 0.8, bty = "n")
    dev.off()
  }

  # Mostrar en pantalla
  plot(dend, main = titulo, las = 2)
  legend("topright", legend = levels(factor_labels), col = colores, pch = 19,
         title = titulo_leyenda, cex = 0.8, bty = "n")

  # Restaurar configuraci√≥n gr√°fica
  par(old_par)

  invisible(dend)
}

```


# ------------------ USO DE LA FUNCI√ìN OPTIMIZADA ------------------

```{r}

# Clustering por resultado COVID
COVID<-datos_filtrados$PCR.Cov
plot_dendrogram(featureMatrix_num, COVID,
                titulo = "Dendrograma por resultado COVID",
                nombre_png = "dendrograma_carga.png")




# Clustering por equipo en positivos
equipo_covidpos <- datos_filtrados$equipo[indices_cov_pos]
indices_cov_pos <- datos_filtrados$PCR.Cov == "Cov.Pos"
plot_dendrogram(featureMatrix_num[indices_cov_pos, ],
                equipo_covidpos,
                titulo = "Clustering Positivos por Equipo",
                nombre_png = "dendrograma_soloCOVID.pos.png")


equipo_covidneg <- datos_filtrados$equipo[indices_cov_neg]
# Clustering por equipo en negativos
indices_cov_neg <- datos_filtrados$PCR.Cov == "Cov.Neg"
plot_dendrogram(featureMatrix_num[indices_cov_neg, ],
                equipo_covidneg,
                titulo = "Clustering Negativos por Equipo",
                nombre_png = "dendrograma_soloCOVID.neg.png")

# Clustering por equipo en toda la base
equipo<-datos_filtrados$equipo
plot_dendrogram(featureMatrix_num, equipo,
                titulo = "Clustering Diferenciado por Equipo",
                nombre_png = "dendrograma_soloCOVID.equipo.png")

# Clustering por fecha
fecha<-datos_filtrados$fecha
plot_dendrogram(featureMatrix_num, fecha,
                titulo = "Clustering Diferenciado por Fecha",
                nombre_png = "dendrograma_fecha_solocovid.png",
                              palette_type = "brewer")


```
# 18.Correcion efecto batch EQUIPO: Combat

```{r}
# Cargar el paquete sva
library(sva)

```

```{r}
# Ejemplo de datos de entrada
data_matrix <- featureMatrix_num  # Tu matriz de datos
metadata <- datos_filtrados    # Dataframe de metadatos con informaci√≥n de batch
batch_info <- metadata$equipo      # Vector con la informaci√≥n de batch

```

```{r}
# Verificar si 'batch_info' es un factor o un vector de caracteres
str(batch_info)

# Si es necesario, convertirlo a un factor
batch_info <- factor(batch_info)


```

```{r}
sum(is.na(data_matrix))  # Revisa si hay valores NA en la matriz

```



```{r}

combat_corrected_equipo <- ComBat(
  dat = t(data_matrix),             
  batch = batch_info,            # Informaci√≥n de batch
  par.prior = TRUE,
  prior.plots = FALSE
)



```



```{r}
# Transponer de vuelta los datos corregidos
combat_corrected_equipo <- t(combat_corrected_equipo)

# Guardar la matriz corregida
write.csv(combat_corrected_equipo, "corrected_featureMatrix.csv")

```



```{r}
save(combat_corrected_equipo, file = "correccion_combat_equipo.rda")

```



```{r}
# Asignar colores manualmente en funci√≥n de batch_info
batch_colors <- as.factor(batch_info)   # Convertir batch_info a factor
levels(batch_colors)  # Ver los niveles de batch_info

# Definir colores manualmente (puedes cambiar los nombres de niveles y colores)
col_vector <- batch_colors
levels(col_vector) <- c("red", "blue", "green")  # Asigna colores a cada batch
```

```{r}
equipo_colors <- as.factor(metadata$equipo)  # Convertir 'equipo' a factor

# Asignar colores
palette_colors <- rainbow(length(unique(equipo_colors)))  # Colores √∫nicos
col_vector <- palette_colors[equipo_colors]
```

```{r}
pca_after <- prcomp(combat_corrected_equipo, scale. = TRUE)


png("PCA post COMBAT.png", width = 800, height = 600)
# Plot PCA despu√©s de la correcci√≥n
plot(pca_after$x[,1:2], col = col_vector, main = "PCA base despu√©s de la correcci√≥n")
legend("topright", 
       legend = levels(batch_colors), 
       col = palette_colors, 
       pch = 16, 
       title = "Batch")
dev.off()


# Plot PCA despu√©s de la correcci√≥n
plot(pca_after$x[,1:2], col = col_vector, main = "PCA base despu√©s de la correcci√≥n")
legend("topright", 
       legend = levels(batch_colors), 
       col = palette_colors, 
       pch = 16, 
       title = "Batch")
```


```{r}
# Verifica la consistencia de las dimensiones
stopifnot(nrow(pca_after$x) == nrow(datos_filtrados))

# Define los colores por equipo
palette_colors <- c("red", "blue", "green")  # Cambia seg√∫n los equipos
col_vector <- palette_colors[as.factor(datos_filtrados$equipo)]

# Define las formas por resultado COVID
pch_vector <- ifelse(Datos_actualizados$PCR.Cov == "Cov.Pos", 16, 17)


png("PCA_combat.png", width = 1200, height = 800)
plot(pca_after$x[, 1:2], 
     col = col_vector, 
     pch = pch_vector, 
     main = "PCA diferenciado por equipo y resultado COVID",
     xlab = "PC1", 
     ylab = "PC2")

# Leyenda por equipo
legend("topright", 
       legend = levels(as.factor(Datos_actualizados$equipo)), 
       col = palette_colors, 
       pch = 16, 
       title = "Equipo")

# Leyenda por resultado COVID
legend("topleft", 
       legend = c("COVID Positivo", "COVID Negativo"), 
       col = "black", 
       pch = c(16, 17), 
       title = "Resultado COVID")
dev.off()



# Grafica el PCA con diferenciaci√≥n por equipo y COVID
plot(pca_after$x[, 1:2], 
     col = col_vector, 
     pch = pch_vector, 
     main = "PCA diferenciado por equipo y resultado COVID",
     xlab = "PC1", 
     ylab = "PC2")

# Leyenda por equipo
legend("topright", 
       legend = levels(as.factor(Datos_actualizados$equipo)), 
       col = palette_colors, 
       pch = 22, 
       title = "Equipo")

# Leyenda por resultado COVID
legend("topleft", 
       legend = c("COVID Positivo", "COVID Negativo"), 
       col = "black", 
       pch = c(16, 17), 
       title = "Resultado COVID")


```

```{r}
# Verifica la consistencia de las dimensiones
stopifnot(nrow(pca_after$x) == nrow(datos_filtrados))

# Define los colores por equipo
palette_colors <- c("red", "blue", "green")  # Cambia seg√∫n los equipos
col_vector <- palette_colors[as.factor(datos_filtrados$equipo)]

# Define las formas por resultado COVID
pch_vector <- ifelse(datos_filtrados$PCR.Cov == "Cov.Pos", 16, 17)


png("PCA_combat.png", width = 1200, height = 800)
plot(pca_after$x[, 2:3], 
     col = col_vector, 
     pch = pch_vector, 
     main = "PCA diferenciado por equipo y resultado COVID",
     xlab = "PC2", 
     ylab = "PC3")

# Leyenda por equipo
legend("topright", 
       legend = levels(as.factor(Datos_actualizados$equipo)), 
       col = palette_colors, 
       pch = 16, 
       title = "Equipo")

# Leyenda por resultado COVID
legend("topleft", 
       legend = c("COVID Positivo", "COVID Negativo"), 
       col = "black", 
       pch = c(16, 17), 
       title = "Resultado COVID")
dev.off()



# Grafica el PCA con diferenciaci√≥n por equipo y COVID
plot(pca_after$x[, 2:3], 
     col = col_vector, 
     pch = pch_vector, 
     main = "PCA diferenciado por equipo y resultado COVID",
     xlab = "PC2", 
     ylab = "PC3")

# Leyenda por equipo
legend("topright", 
       legend = levels(as.factor(Datos_actualizados$equipo)), 
       col = palette_colors, 
       pch = 22, 
       title = "Equipo")

# Leyenda por resultado COVID
legend("topleft", 
       legend = c("COVID Positivo", "COVID Negativo"), 
       col = "black", 
       pch = c(16, 17), 
       title = "Resultado COVID")


```


```{r}
# Cargar librer√≠as necesarias
library(ggplot2)
library(dplyr)


pca_scores <- pca_after$x

# 3. Agregar los resultados PCA al dataframe de metadatos
metadata_pca <- cbind(datos_filtrados[,c(4:7)], pca_scores)

# 4. Funci√≥n para realizar Kruskal-Wallis sobre los componentes principales
kruskal_pca <- function(pca_scores, metadata, factor) {
  results <- data.frame()
  for (i in 1:ncol(pca_scores)) {  # Para cada componente principal
    pca_component <- pca_scores[, i]  # Extraer la puntuaci√≥n del componente
    model <- kruskal.test(pca_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
    factor_effect <- model$p.value  # Obtener el p-valor
    results <- rbind(results, data.frame(PC = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
  }
  return(results)
}

# 5. Lista de factores que quieres analizar
factors <- c("PCR.Cov", "fecha", "equipo")


# Ejecutar la funci√≥n para cada factor y combinar los resultados
kruskal_results <- do.call(rbind, lapply(factors, function(f) kruskal_pca(pca_scores, datos_filtrados, f)))

# 6. Resumir el p-valor medio para cada factor
factor_summary <- kruskal_results %>%
  group_by(Factor) %>%
  summarise(MeanLogPValue = -log10(mean(PValue)))

pca_kruskal_COMBAT<- ggplot(factor_summary, aes(x = reorder(Factor, MeanLogPValue), y = MeanLogPValue, fill = Factor)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Importancia de los Factores PCA",
       x = "Factor",
       y = "-log10(P-valor Medio)",
       fill = "Factor")
    theme(
    plot.title = element_text(size = 35),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 30),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 30),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 18),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 28),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 28)  # Reducir tama√±o del texto de la leyenda
  )
print(pca_kruskal_COMBAT)
```

```{r}
# 
# pca_kruskal_COMBAT <- ggplot(factor_summary, aes(x = reorder(Factor, MeanLogPValue), y = MeanLogPValue, fill = Factor)) +
#   geom_bar(stat = "identity", width = 0.7) +  # Ajusta el ancho de las barras
#   coord_flip() +
#   labs(
#     title = "Importancia de los Factores PCA",
#     x = "Factor",
#     y = "-log10(P-valor Medio)",
#     fill = "Factor"
#   ) +
#   theme_minimal() +
#   theme(
#     plot.title = element_text(size = 16, face = "bold"),
#     axis.title.x = element_text(size = 14),
#     axis.title.y = element_text(size = 14),
#     axis.text.x = element_text(size = 12),
#     axis.text.y = element_text(size = 12),
#     legend.title = element_text(size = 14),
#     legend.text = element_text(size = 12),
#     panel.background = element_rect(fill = "white", color = NA),
#     plot.background = element_rect(fill = "white", color = NA)
#   )
# 
# # Exportar el gr√°fico con dimensiones ajustadas
# ggsave(
#   filename = "CombatPCA.png",
#   plot = pca_kruskal_COMBAT,
#   width = 8,    # Ancho ajustado
#   height = 6,   # Altura ajustada
#   dpi = 300,
#   scale = 1.5,  # Escala para aumentar proporcionalmente todo el dise√±o
#   bg = "white"  # Fondo blanco asegurado
# )
```


UMAP

```{r}
library(umap)


# Ajustar par√°metros directamente en la funci√≥n umap
umap_combat <- umap(combat_corrected_equipo, n_neighbors = 10, metric = "euclidean", min_dist = 0.3)

# Verificar la estructura del objeto umap_v2
str(umap_combat) # Esto te mostrar√° la estructura para asegurarte de que layout es un componente v√°lido.

# Si la estructura es correcta, continuar con la conversi√≥n a dataframe
umap_coor_combat <- as.data.frame(umap_combat)

# Asignar nombres de columnas
colnames(umap_coor_combat) <- c("UMAP1", "UMAP2")

# A√±adir las columnas con los metadatos (COVID, equipo, etc.)
umap_coor_combat$covid <- datos_filtrados$PCR.Cov
umap_coor_combat$equipo <- datos_filtrados$equipo

UMAP_postCombat<-plot_umap(umap_coor_combat, UMAP1, UMAP2, color_by  = "equipo", shape_by = "covid",
          title = "UMAP post COMBAT", usar_paleta_auto = TRUE)
UMAP_postCombat
```


```{r}
UMAP_postCombat <- UMAP_postCombat + 
  theme(
    panel.background = element_rect(fill = "white"), # Fondo blanco
    
    panel.grid.minor = element_blank(), # Sin l√≠neas de cuadr√≠cula menores
    plot.background = element_rect(fill = "white") # Fondo del gr√°fico blanco
  )

```



```{r}

umap_scores <- umap_combat  # Tomar el resultado de UMAP directamente

# Luego sigues con el mismo an√°lisis
metadata_umap <- cbind(datos_filtrados[,c(4,5,7)], umap_scores)

# Funci√≥n para realizar Kruskal-Wallis sobre las dimensiones de UMAP
kruskal_umap <- function(umap_scores, metadata, factor) {
  results <- data.frame()
  for (i in 1:ncol(umap_scores)) {  # Para cada dimensi√≥n de UMAP
    umap_component <- umap_scores[, i]  # Extraer la puntuaci√≥n de la dimensi√≥n
    model <- kruskal.test(umap_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
    factor_effect <- model$p.value  # Obtener el p-valor
    results <- rbind(results, data.frame(UMAP_Dim = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
  }
  return(results)
}

# Lista de factores que quieres analizar
factors <- c("PCR.Cov", "fecha", "equipo")

# Ejecutar la funci√≥n para cada factor y combinar los resultados
kruskal_results_umap <- do.call(rbind, lapply(factors, function(f) kruskal_umap(umap_scores, datos_filtrados, f)))

# Resumir el p-valor medio para cada factor
factor_summary_umap <- kruskal_results_umap %>%
  group_by(Factor) %>%
  summarise(MeanLogPValue = -log10(mean(PValue)))

# Visualizar los resultados en un gr√°fico de barras
umap_postcombat_var<-ggplot(factor_summary_umap, aes(x = reorder(Factor, MeanLogPValue), y = MeanLogPValue, fill = Factor)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Importancia de componentes UMAP post COMBAT",
       x = "Factor",
       y = "-log10(P-valor Medio)",
       fill = "Factor")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  
  )


print(umap_postcombat_var)


```

```{r}
library(patchwork)

# Primero definimos el layout de los gr√°ficos combinados
combined_var_combat <- (
  pca_kruskal_COMBAT + umap_postcombat_var
)

# Agregamos los t√≠tulos y anotaciones
combined_var_combat <- combined_var_combat + 
  plot_annotation(
    title = "Influencia de los factores en los datos",
    tag_levels = "A"
  ) & theme(plot.title = element_text(hjust = 0.5, size = 10))
# Para ver el gr√°fico
print(combined_var_combat)

# Guardamos con dimensiones optimizadas
ggsave(
  filename = "combined_var_kruskal.png",
  plot = combined_var_combat,
  width = 14,    # Aumentado para dar m√°s espacio
  height = 10,   # Aumentado proporcionalmente
  dpi = 300,
  scale = 1,    # Quitamos el scale para tener m√°s control directo
  bg = "white"
)
```




```{r}
ggsave(
  filename = "combined_var_kruskal.png",
  plot = combined_var_combat,
  width = 12,    # Ancho ajustado
  height = 8,   # Altura ajustada
  dpi = 300,
  scale = 1.2,  # Escala para aumentar proporcionalmente todo el dise√±o
  bg = "white"  # Fondo blanco asegurado
)


```



# clustering combat_equipo


```{r}
library(dendextend)

distancias <- dist(combat_corrected_equipo)

# Realizar el clustering jer√°rquico
hc <- hclust(distancias, method = "ward.D2")

# Convierte el dendrograma a un objeto de dendextend
dend <- as.dendrogram(hc)

# Crea un vector de colores basado en PCR.cov
# Cambia "PCR.cov" a la columna adecuada de Datos_actualizados
label_colors <- as.factor(Datos_actualizados$PCR.Cov)
palette <- c("red", "blue") # Cambia los colores si hay m√°s de 2 categor√≠as
label_colors <- palette[label_colors]

# Aplica los colores a las etiquetas
dend <- dend %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.5) # Ajusta el tama√±o de las etiquetas

# Dibuja el dendrograma
plot(dend, main = "Dendrograma por resultado COVID")
legend("topright",           # Posici√≥n de la leyenda
       legend = c("COVID Negativo", "COVID Positivo"), # Textos de la leyenda
       fill = c("red", "blue"),                        # Colores de la leyenda
       border = "black",                               # Borde de las cajas de color
       bty = "n",                                      # Sin caja alrededor de la leyenda
       cex = 0.8)    

```


```{r}
table(Datos_actualizados$PCR.Cov, label_colors)

```


 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_pos <- datos_filtrados$PCR.Cov == "Cov.Pos"
featureMatrix_cov_pos <- combat_corrected_equipo[indices_cov_pos, ]
datos_filtrados_cov_pos <- datos_filtrados[indices_cov_pos, ]

# Verificar que los datos est√©n filtrados correctamente
dim(featureMatrix_cov_pos)
table(datos_filtrados$equipo)


# Realizar el clustering jer√°rquico
dist_featureMatriz_cov_pos <- dist(featureMatrix_cov_pos)
hc_cov_pos <- hclust(dist_featureMatriz_cov_pos, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_pos <- as.dendrogram(hc_cov_pos)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(datos_filtrados_cov_pos$equipo)
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]

# Personalizar el dendrograma
dend_cov_pos <- dend_cov_pos %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

# Visualizar el dendrograma
plot(dend_cov_pos, main = "Clustering de Positivos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")

```


 
 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_neg <- datos_filtrados$PCR.Cov == "Cov.Neg"
featureMatrix_cov_neg <- combat_corrected_equipo[indices_cov_neg, ]
datos_filtrados_cov_neg <- Datos_actualizados[indices_cov_neg, ]

# Verificar que los datos est√©n filtrados correctamente
dim(featureMatrix_cov_neg)
table(datos_filtrados_cov_neg$equipo)

# Realizar el clustering jer√°rquico
dist_featureMatriz_cov_neg <- dist(featureMatrix_cov_neg)
hc_cov_neg <- hclust(dist_featureMatriz_cov_neg, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_neg <- as.dendrogram(hc_cov_neg)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- factor(datos_filtrados_cov_pos$equipo, levels = c("CR", "HC", "Malbran"))

palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]

# Personalizar el dendrograma
dend_cov_neg <- dend_cov_neg %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

# Visualizar el dendrograma
plot(dend_cov_neg, main = "Clustering de Negativos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")

```
 



```{r}
table(datos_filtrados_cov_neg$equipo)

```



 
```{r}

# Extraer solo las filas que corresponden a los equipos en featureMatrix_num
# Aseg√∫rate de que Datos_actualizados$equipo tenga valores v√°lidos para subindexar.
featureMatrix_equipo <- combat_corrected_equipo

# Verificar que los datos est√©n filtrados correctamente
table(Datos_actualizados$equipo)

# Calcular la matriz de distancias y realizar el clustering jer√°rquico
dist_featureMatriz_eq <- dist(featureMatrix_equipo)
hc_eq <- hclust(dist_featureMatriz_eq, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_eq <- as.dendrogram(hc_eq)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- factor(datos_filtrados_cov_neg$equipo, levels = c("CR", "HC", "Malbran"))

palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]           # Asignar colores por equipo

# Personalizar el dendrograma
dend_eq <- dend_eq %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas


png("dendrograma_COVID.equipo.png", width = 800, height = 600)
plot(dend_eq, main = "Clustering Diferenciado por Equipo post Combat")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")
dev.off()

# Visualizar el dendrograma
plot(dend_eq, main = "Clustering Diferenciado por Equipo post Combat")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")


```




```{r}


datos_filtrados$fecha <- as.factor(datos_filtrados$fecha)

# Matriz de caracter√≠sticas (featureMatrix_num)
featureMatrix_fecha <- combat_corrected_equipo

# Calcular la matriz de distancias y realizar el clustering jer√°rquico
dist_featureMatriz_fecha <- dist(featureMatrix_fecha)
hc_fecha <- hclust(dist_featureMatriz_fecha, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_fecha <- as.dendrogram(hc_fecha)

# Crear un vector de colores para las etiquetas basado en 'fecha'
fecha_factor <- datos_filtrados$fecha
palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
label_colors <- palette[fecha_factor]           # Asignar colores por fecha

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'fecha'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

# Visualizar el dendrograma
library(RColorBrewer)

# Crear una paleta m√°s contrastante
num_colores <- length(levels(fecha_factor))
palette <- brewer.pal(n = min(num_colores, 12), name = "Paired") # M√°x. 12 colores contrastantes
if (num_colores > 12) {
  palette <- colorRampPalette(brewer.pal(12, "Paired"))(num_colores) # Extender paleta si es necesario
}

# Aplicar los nuevos colores
label_colors <- palette[fecha_factor]

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.6)

# Dibujar el dendrograma
plot(dend_fecha, main = "Clustering Diferenciado por Fecha")
legend(
  "topright",
  legend = levels(fecha_factor),
  col = palette,
  pch = 19,
  title = "Fecha",
  cex = 0.7,
  bty = "n"
)


```



# 18.Correcion efecto batch FECHA: Combat

```{r}
# Ejemplo de datos de entrada
data_matrix <- featureMatrix_num  # Tu matriz de datos
metadata <- datos_filtrados    # Dataframe de metadatos con informaci√≥n de batch
batch_info <- metadata$fecha      # Vector con la informaci√≥n de batch

```

```{r}
# Verificar si 'batch_info' es un factor o un vector de caracteres
str(batch_info)

# Si es necesario, convertirlo a un factor
batch_info <- factor(batch_info)


```

```{r}
sum(is.na(data_matrix))  # Revisa si hay valores NA en la matriz

```



```{r}

combat_corrected_fecha <- ComBat(
  dat = t(data_matrix),             
  batch = batch_info,            # Informaci√≥n de batch
  par.prior = TRUE,
  prior.plots = FALSE
)



```



```{r}
# Transponer de vuelta los datos corregidos
combat_corrected_fecha <- t(combat_corrected_fecha)

# Guardar la matriz corregida
write.csv(combat_corrected_fecha, "corrected_featureMatrix.csv")

```



```{r}
save(featureMatrix, file = "correccion_combat_fecha.rda")

```

# CLUSTERING COMBAT_FECHA


```{r}
library(dendextend)

distancias <- dist(combat_corrected_fecha)

# Realizar el clustering jer√°rquico
hc <- hclust(distancias, method = "ward.D2")

# Convierte el dendrograma a un objeto de dendextend
dend <- as.dendrogram(hc)

# Crea un vector de colores basado en PCR.cov
# Cambia "PCR.cov" a la columna adecuada de Datos_actualizados
label_colors <- as.factor(datos_filtrados$PCR.Cov)
palette <- c("red", "blue") # Cambia los colores si hay m√°s de 2 categor√≠as
label_colors <- palette[label_colors]

# Aplica los colores a las etiquetas
dend <- dend %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.5) # Ajusta el tama√±o de las etiquetas




# Dibuja el dendrograma
plot(dend, main = "Dendrograma por resultado COVID")
legend("topright",           # Posici√≥n de la leyenda
       legend = c("COVID Negativo", "COVID Positivo"), # Textos de la leyenda
       fill = c("red", "blue"),                        # Colores de la leyenda
       border = "black",                               # Borde de las cajas de color
       bty = "n",                                      # Sin caja alrededor de la leyenda
       cex = 0.8)    

```


```{r}
table(datos_filtrados$PCR.Cov, label_colors)

```

 
 
```{r}
library(dendextend)
library(factoextra)
# 
# # Filtrar las muestras positivas (COV.POS)
# indices_cov_pos <- datos_filtrados$PCR.Cov == "Cov.Pos"
# table(datos_filtrados$fecha[indices_cov_pos])
# 
# datos_filtrados_cov_pos$fecha <- droplevels(datos_filtrados_cov_pos$fecha)
# table(datos_filtrados_cov_pos$fecha)  # Ahora s√≠, solo fechas con ‚â•1 muestra positiva
# featureMatrix_cov_pos <- combat_corrected_fecha[indices_cov_pos, ]
# datos_filtrados_cov_pos <- datos_filtrados[indices_cov_pos, ]
# 
# 
# 
# # Verificar que los datos est√©n filtrados correctamente
# dim(featureMatrix_cov_pos)
# table(datos_filtrados$fecha)
# 
# 
# # Realizar el clustering jer√°rquico
# dist_featureMatriz_cov_pos <- dist(featureMatrix_cov_pos)
# hc_cov_pos <- hclust(dist_featureMatriz_cov_pos, method = "ward.D2")
# 
# # Convertir a dendrograma para personalizar
# dend_cov_pos <- as.dendrogram(hc_cov_pos)
# 
# # Crear un vector de colores para las etiquetas basado en 'equipo'
# equipo_factor <- as.factor(datos_filtradoss_cov_pos$fecha)
# palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
# label_colors <- palette[fecha_factor]
# 
# # Personalizar el dendrograma
# dend_cov_pos <- dend_cov_pos %>%
#   set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
#   set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas


# Filtrar las muestras positivas (COV.POS)
indices_cov_pos <- datos_filtrados$PCR.Cov == "Cov.Pos"
featureMatrix_cov_pos <- combat_corrected_fecha[indices_cov_pos, ]
Datos_actualizados_cov_pos <- datos_filtrados[datos_filtrados$PCR.Cov == "Cov.Pos", ]


# Verificar que los datos est√©n filtrados correctamente
dim(featureMatrix_cov_pos)
table(Datos_actualizados_cov_pos$fecha)


# Realizar el clustering jer√°rquico
dist_featureMatriz_cov_pos <- dist(featureMatrix_cov_pos)
hc_cov_pos <- hclust(dist_featureMatriz_cov_pos, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_pos <- as.dendrogram(hc_cov_pos)

# Crear un vector de colores para las etiquetas basado en 'equipo'
fecha_factor <- as.factor(Datos_actualizados_cov_pos$fecha)
palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
label_colors <- palette[fecha_factor]

# Personalizar el dendrograma
dend_cov_pos <- dend_cov_pos %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas






# Visualizar el dendrograma
plot(dend_cov_pos, main = "Clustering de Positivos Diferenciado por fecha")
legend("topright", legend = levels(fecha_factor), col = palette, pch = 19, title = "Fecha")




```


 
 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_neg <- datos_filtrados$PCR.Cov == "Cov.Neg"
featureMatrix_cov_neg <- combat_corrected_fecha[indices_cov_neg, ]
datos_filtrados_cov_neg <- Datos_actualizados[indices_cov_neg, ]

# Verificar que los datos est√©n filtrados correctamente
dim(featureMatrix_cov_neg)
table(datos_filtrados_cov_neg$fecha)

# Realizar el clustering jer√°rquico
dist_featureMatriz_cov_neg <- dist(featureMatrix_cov_neg)
hc_cov_neg <- hclust(dist_featureMatriz_cov_neg, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_neg <- as.dendrogram(hc_cov_neg)

# Crear un vector de colores para las etiquetas basado en 'fecha'
fecha_factor <- as.factor(datos_filtrados_cov_neg$fecha)
palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
label_colors <- palette[fecha_factor]

# Personalizar el dendrograma
dend_cov_neg <- dend_cov_neg %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

# Visualizar el dendrograma
plot(dend_cov_neg, main = "Clustering de Negativos Diferenciado por fecha")
legend("topright", legend = levels(fecha_factor), col = palette, pch = 19, title = "Equipo")

```
 



 
```{r}

# Extraer solo las filas que corresponden a los equipos en featureMatrix_num
# Aseg√∫rate de que Datos_actualizados$equipo tenga valores v√°lidos para subindexar.
featureMatrix_equipo <- combat_corrected_fecha

# Verificar que los datos est√©n filtrados correctamente
table(Datos_actualizados$equipo)

# Calcular la matriz de distancias y realizar el clustering jer√°rquico
dist_featureMatriz_eq <- dist(combat_corrected_fecha)
hc_eq <- hclust(dist_featureMatriz_eq, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_eq <- as.dendrogram(hc_eq)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(datos_filtrados$equipo)
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]           # Asignar colores por equipo

# Personalizar el dendrograma
dend_eq <- dend_eq %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas



# Visualizar el dendrograma
plot(dend_eq, main = "Clustering Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")


```




```{r}


datos_filtrados$fecha <- as.factor(datos_filtrados$fecha)

# Matriz de caracter√≠sticas (featureMatrix_num)
featureMatrix_fecha <- combat_corrected_fecha

# Calcular la matriz de distancias y realizar el clustering jer√°rquico
dist_featureMatriz_fecha <- dist(featureMatrix_fecha)
hc_fecha <- hclust(dist_featureMatriz_fecha, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_fecha <- as.dendrogram(hc_fecha)

# Crear un vector de colores para las etiquetas basado en 'fecha'
fecha_factor <- datos_filtrados$fecha
palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
label_colors <- palette[fecha_factor]           # Asignar colores por fecha

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'fecha'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

# Visualizar el dendrograma
library(RColorBrewer)

# Crear una paleta m√°s contrastante
num_colores <- length(levels(fecha_factor))
palette <- brewer.pal(n = min(num_colores, 12), name = "Paired") # M√°x. 12 colores contrastantes
if (num_colores > 12) {
  palette <- colorRampPalette(brewer.pal(12, "Paired"))(num_colores) # Extender paleta si es necesario
}

# Aplicar los nuevos colores
label_colors <- palette[fecha_factor]

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.6)




# Dibujar el dendrograma
plot(dend_fecha, main = "Clustering Diferenciado por Fecha")
legend(
  "topright",
  legend = levels(fecha_factor),
  col = palette,
  pch = 19,
  title = "Fecha",
  cex = 0.7,
  bty = "n"
)


png("FECHA_combat.png", width = 800, height = 600)
plot(dend_fecha, main = "Clustering Diferenciado por Fecha")
legend(
  "topright",
  legend = levels(fecha_factor),
  col = palette,
  pch = 19,
  title = "Fecha",
  cex = 0.7,
  bty = "n"
)
dev.off()

```


```{r}
positivos <- datos_filtrados$PCR.Cov == "Cov.Pos"
negativos <- datos_filtrados$PCR.Cov == "Cov.Neg"

table(datos_filtrados$fecha[positivos])
table(datos_filtrados$fecha[negativos])

```


#En ComBat, el argumento modcombat (o mod) contiene la matriz de dise√±o que representa las variables de inter√©s que deseas preservar durante la correcci√≥n por batch


#####error

```{r}
modcombat <- model.matrix(~ equipo, data = datos_filtrados)

```

```{r}
# Ejemplo de datos de entrada
data_matrix <- featureMatrix_num  # Tu matriz de datos
metadata <- datos_filtrados    # Dataframe de metadatos con informaci√≥n de batch
batch_info <- metadata$fecha      # Vector con la informaci√≥n de batch

```

```{r}
# Verificar si 'batch_info' es un factor o un vector de caracteres
str(batch_info)

# Si es necesario, convertirlo a un factor
batch_info <- factor(batch_info)


```


```{r}
# combat_corrected_fecha2 <- ComBat(
#   dat = t(data_matrix),         # Matriz de intensidades
#   batch = batch_info,    # Variable batch (por ejemplo, equipos)
#   mod = modcombat,
#   par.prior = TRUE,
#   prior.plots = FALSE)

```

         
```{r}
# Transponer de vuelta los datos corregidos
# combat_corrected_fecha2 <- t(combat_corrected_fecha2)
# 
# # Guardar la matriz corregida
# write.csv(combat_corrected_fecha2, "corrected_featureMatrix.csv")

```

```{r}
# # Asignar colores manualmente en funci√≥n de batch_info
# batch_colors <- as.factor(batch_info)   # Convertir batch_info a factor
# levels(batch_colors)  # Ver los niveles de batch_info
# 
# # Definir colores manualmente (puedes cambiar los nombres de niveles y colores)
# col_vector <- batch_colors
# levels(col_vector) <- c("red", "blue", "green")  # Asigna colores a cada batch
```

```{r}
# fecha_colors <- as.factor(metadata$fecha)  # Convertir 'equipo' a factor
# 
# # Asignar colores
# palette_colors <- rainbow(length(unique(fecha_colors)))  # Colores √∫nicos
# col_vector <- palette_colors[fecha_colors]
```

```{r}
# pca_after2 <- prcomp(combat_corrected_fecha2, scale. = TRUE)
# 
# # Plot PCA despu√©s de la correcci√≥n
# plot(pca_after2$x[,1:2], col = col_vector, main = "PCA despu√©s de la correcci√≥n")
# legend("topright", 
#        legend = levels(batch_colors), 
#        col = palette_colors, 
#        pch = 16, 
#        title = "Batch")
```


```{r}
# library(umap)
# 
# 
# # Ajustar par√°metros directamente en la funci√≥n umap
# umap_v5 <- umap(combat_corrected2, n_neighbors = 15, metric = "euclidean", min_dist = 0.1)
# 
# # Verificar la estructura del objeto umap_v2
# str(umap_v5) # Esto te mostrar√° la estructura para asegurarte de que layout es un componente v√°lido.
# 
# # Si la estructura es correcta, continuar con la conversi√≥n a dataframe
# umap_coor5 <- as.data.frame(umap_v5)
# 
# # Asignar nombres de columnas
# colnames(umap_coor5) <- c("UMAP1", "UMAP2")
# 
# # A√±adir las columnas con los metadatos (COVID, equipo, etc.)
# umap_coor5$covid <- Datos_actualizados$PCR.Cov
# umap_coor5$equipo <- Datos_actualizados$equipo
# 
# # Graficar UMAP con ggplot2
# library(ggplot2)
# ggplot(umap_coor5, aes(x = UMAP1, y = UMAP2, color = equipo, shape = covid)) +
#   geom_point(size = 3) +
#   labs(title = "UMAP luego de correcci√≥n por COMBAT",
#        x = "UMAP1",
#        y = "UMAP2") +
#   theme_minimal()
```



```{r}
# 
# umap_scores <- umap_v5  # Tomar el resultado de UMAP directamente
# 
# # Luego sigues con el mismo an√°lisis
# metadata_umap <- cbind(Datos_actualizados[,c(4,5,7)], umap_scores)
# 
# # Funci√≥n para realizar Kruskal-Wallis sobre las dimensiones de UMAP
# kruskal_umap <- function(umap_scores, metadata, factor) {
#   results <- data.frame()
#   for (i in 1:ncol(umap_scores)) {  # Para cada dimensi√≥n de UMAP
#     umap_component <- umap_scores[, i]  # Extraer la puntuaci√≥n de la dimensi√≥n
#     model <- kruskal.test(umap_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
#     factor_effect <- model$p.value  # Obtener el p-valor
#     results <- rbind(results, data.frame(UMAP_Dim = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
#   }
#   return(results)
# }
# 
# # Lista de factores que quieres analizar
# factors <- c("PCR.Cov", "fecha", "equipo")

# Ejecutar la funci√≥n para cada factor y combinar los resultados
# kruskal_results_umap <- do.call(rbind, lapply(factors, function(f) kruskal_umap(umap_scores, Datos_actualizados, f)))
# 
# # Resumir el p-valor medio para cada factor
# factor_summary_umap <- kruskal_results_umap %>%
#   group_by(Factor) %>%
#   summarise(MeanPValue = mean(PValue))
# 
# # Visualizar los resultados en un gr√°fico de barras
# ggplot(factor_summary_umap, aes(x = reorder(Factor, MeanPValue), y = MeanPValue, fill = Factor)) +
#   geom_bar(stat = "identity") +
#   coord_flip() +
#   theme_minimal() +
#   labs(title = "Importancia de los Factores en el Efecto Batch (UMAP) despues de COMBAT",
#        x = "Factor",
#        y = "P-valor Medio",
#        fill = "Factor")

```

```{r}
combat_corrected_fecha_high<-combat_corrected_fecha
```

```{r}
combat_corrected_equipo_high<-combat_corrected_equipo
```

