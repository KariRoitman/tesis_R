---
title: "EDA-Combat"
author: "Karina Roitman"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

# Objetivos

# 1. Cargar librerias.

rmarkdown como estrategia sint√°ctica. (En bibliografia hay 2 archivos)

```{r}
library(rmarkdown)
```

```{r}

library(stringr)
?stringr
library(tidyr)
?tidyr
library(dplyr)
library(openxlsx)
library(purrr)
library(broom)
library(ggplot2)
library(MALDIquant)
?MALDIquant
library(MALDIquantForeign)
?MALDIquantForeign
```

```{r}
getwd()  # Verifica el directorio de trabajo actual

```

```{r}
setwd("C:/Users/karin/Desktop/MCD/TESIS")
```

# 2. Cargar datos

```{r}
load("./Data_Kari/EspectrosINB/Average_ciego.INBIRS.1.rda")
load("./Data_Kari/EspectrosINB/Average_ciego.INBIRS.2.rda")
load("./Data_Kari/EspectrosINB/Average_ciego.INBIRS.3.rda")
load("./Data_Kari/EspectrosINB/Average_ciego.INBIRS.4.rda")
load("./Data_Kari/EspectrosHC/Average_HC_1.rda")
load("./Data_Kari/EspectrosHC/Average_HC_2.rda")
load("./Data_Kari/EspectrosHC/Average_HC_3.rda")
load("./Data_Kari/EspectrosHC/Average_HC_4.rda")
load("./Data_Kari/EspectrosHC/Average_HC_5.rda")
load("./Data_Kari/EspectrosHC/Average_HC_6.rda")
load("./Data_Kari/Espectros.Malb/Average_ciego.Malbran.1.rda")
load("./Data_Kari/Espectros.Malb/Average_ciego.Malbran.2.rda")
load("./Data_Kari/Espectros.Malb/Average_ciego.Malbran.3.rda")
load("./Data_Kari/EspectrosCR/Average_ciego.Costa.Rica.1.rda")
load("./Data_Kari/EspectrosCR/Average_ciego.Costa.Rica.3.rda")
```

# 3. Asigno batch, institucion y equipo

```{r}
# Listado de tus dataframes
dataframes <- list(INBIRS.1.df.f.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "16_7i"
  df$institucion <- "inbirs"
  df$equipo <- "HC"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

INBIRS.1.df.f.1 <- dataframes[[1]]
```

```{r}
# Listado de tus dataframes
dataframes <- list(INBIRS.df.2.f)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "17_7i"
  df$institucion <- "inbirs"
  df$equipo <- "HC"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

INBIRS.df.2.f <- dataframes[[1]]
```

```{r}
# Listado de tus dataframes
dataframes <- list(INBIRS.df.3.f)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "13_8i"
  df$institucion <- "inbirs"
  df$equipo <- "HC"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

INBIRS.df.3.f <- dataframes[[1]]
```

```{r}
# Listado de tus dataframes
dataframes <- list(Espectros.INBIRS.4.f)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "18_8i"
  df$institucion <- "inbirs"
  df$equipo <- "HC"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales
Espectros.INBIRS.4.f<-dataframes[[1]]

```

HC1

```{r}
# Listado de tus dataframes
dataframes <- list(Categ.Hospi.1.Neg, Categ.Hospi.1.Pos, Categ.Hospi.2.Cnt, Categ.Hospi.2.Neg, Categ.Hospi.2.No.Covid, Categ.Hospi.2.Pos, Categ.Hospi.3.Neg, Categ.Hospi.3.No.Covid, Categ.Hospi.3.Pos)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia1hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

Categ.Hospi.1.Neg<- dataframes[[1]]
Categ.Hospi.1.Pos<- dataframes[[2]]
Categ.Hospi.2.Cnt<- dataframes[[3]]
Categ.Hospi.2.Neg<- dataframes[[4]]
Categ.Hospi.2.No.Covid<- dataframes[[5]]
Categ.Hospi.2.Pos<- dataframes[[6]]
Categ.Hospi.3.Neg<- dataframes[[7]]
Categ.Hospi.3.No.Covid<- dataframes[[8]]
Categ.Hospi.3.Pos<- dataframes[[9]]

```

HC2

```{r}
dataframes <- list(Categ.Ciego.clin.1.Exp1.covid, Categ.Ciego.clin.1.Exp1.flu)

dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia2hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

Categ.Ciego.clin.1.Exp1.covid<-dataframes[[1]]
Categ.Ciego.clin.1.Exp1.flu<-dataframes[[2]]
```

HC3

```{r}
dataframes <- list(Categ.Neg.New.clin.1, Categ.Pos.New.clin.1)

dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia3hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

Categ.Neg.New.clin.1<-dataframes[[1]]
Categ.Pos.New.clin.1<-dataframes[[2]]
```

HC4

```{r}
dataframes <- list(Categ.Ciego.clin25.6.2.covid, Categ.Ciego25.6.clin.2.flu)

dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia4hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

Categ.Ciego.clin25.6.2.covid<-dataframes[[1]]
Categ.Ciego25.6.clin.2.flu<-dataframes[[2]]
```

HC5

```{r}
dataframes <- list(Categ.Ciego_3_7.4)

dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia5hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

Categ.Ciego_3_7.4<-dataframes[[1]]
```

HC6

```{r}
dataframes <- list(Categ.Ciego_8_7.4)

dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "dia2hc"
  df$institucion <- "HdC"
  df$equipo <- "HC"
  return(df)
})

Categ.Ciego_8_7.4<-dataframes[[1]]

```

MALBRAN 1

```{r}
# Listado de tus dataframes
dataframes <- list(Categ.Malbran.1.1.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "1Malbran"
  df$institucion <- "Malbran"
  df$equipo <- "Malbran"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

Categ.Malbran.1.1.1 <- dataframes[[1]]
```

MALBRAN2

```{r}
# Listado de tus dataframes
dataframes <- list(Categ.Malbran.2.1.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "2Malbran"
  df$institucion <- "Malbran"
  df$equipo <- "Malbran"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

Categ.Malbran.2.1.1 <- dataframes[[1]]
```

MALBRAN3

```{r}
# Listado de tus dataframes
dataframes <- list(Malbran_3_4.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "3Malbran"
  df$institucion <- "Malbran"
  df$equipo <- "Malbran"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

Malbran_3_4.1 <- dataframes[[1]]
```

CR1

```{r}
# Listado de tus dataframes
dataframes <- list(CostaRica.1.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "1CR"
  df$institucion <- "CR"
  df$equipo <- "CR"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

CostaRica.1.1 <- dataframes[[1]]
```

CR2

```{r}
# Listado de tus dataframes
dataframes <- list(CostaRica.3.1.1.1)

# Usas lapply para agregar las columnas a cada dataframe
dataframes <- lapply(dataframes, function(df) {
  df$fecha <- "2CR"
  df$institucion <- "CR"
  df$equipo <- "CR"
  return(df)
})

# Asignas los dataframes modificados de vuelta a sus nombres originales

CostaRica.3.1.1.1<- dataframes[[1]]


CostaRica.3.1.1.1$PCR.Cov <- CostaRica.3.1.1.1$Virus
```

# 4. Listado de todos los dataframes

```{r}
dataframes <- list(INBIRS.1.df.f.1,
INBIRS.df.2.f,
INBIRS.df.3.f,
Espectros.INBIRS.4.f,
Categ.Hospi.1.Neg,
Categ.Hospi.1.Pos,
Categ.Hospi.2.Cnt,
Categ.Hospi.2.Neg,
Categ.Hospi.2.No.Covid,
Categ.Hospi.2.Pos,
Categ.Hospi.3.Neg,
Categ.Hospi.3.No.Covid,
Categ.Hospi.3.Pos,
Categ.Ciego.clin.1.Exp1.covid,
Categ.Ciego.clin.1.Exp1.flu,
Categ.Neg.New.clin.1,
Categ.Pos.New.clin.1,
Categ.Ciego.clin25.6.2.covid,
Categ.Ciego25.6.clin.2.flu,
Categ.Ciego_3_7.4,
Categ.Ciego_8_7.4,
Categ.Malbran.1.1.1,
Categ.Malbran.2.1.1,
Malbran_3_4.1,
CostaRica.1.1,
CostaRica.3.1.1.1)




# Contar filas para cada dataframe
filas_count <- sapply(dataframes, nrow)

# Mostrar los resultados
print(filas_count)
sum(filas_count)
```

# 5. Union de todos los espectros

```{r , message=FALSE, echo=FALSE, warning=FALSE, out.width="100%"}

Espec.Union.Clin.Pos.Neg <- c(
                            Espectros.INBIRS.1,
                            Espectros.INBIRS.2,
                            Espectros.INBIRS.3,
                            Espectros.INBIRS.4,
                            Espectros.HC.1.Neg,
                            Espectros.HC.1.HighPos,
                            Espectros.HC.2.Cnt,
                            Espectros.HC.2.Neg,
                            Espectros.HC.2.No.covid,
                            Espectros.HC.2.IntPos,
                            Espectros.HC.3.Neg,
                            Espectros.HC.3.No.covid,
                            Espectros.HC.3.LowPos,
                            Espectros.Ciego.Exp1.covid,
                            Espectros.Ciego.Exp1.flu,
                            Espectros.Neg.New.Clin,
                            Espectros.Pos.New.Clin, 
                            Espectros.Ciego.25.6.covid,
                            Espectros.Ciego.25.6.flu,
                            Espectros.Ciego.4.2,
                            Espectros.Ciego.5,
                            Espectros.Malbran.24,
                            Espectros.Malb.2.24,
                            Espectros.Malb.3_4,
                            Espectros.CR1,
                            Espectros.CR3
                            )

Espectra.1 <- alignSpectra(Espec.Union.Clin.Pos.Neg, halfWindowSize=50, SNR=3, 
                    tolerance=0.5, warpingMethod="quadratic")
```

```{r}
library(purrr)
```

```{r}
INBIRS.1.df.f.1<-INBIRS.1.df.f.1[,c(1,6:10)]
INBIRS.1.df.f.1<-data.frame(purrr::map(INBIRS.1.df.f.1, as.character),
                               stringsAsFactors = FALSE)

INBIRS.df.2.f<-INBIRS.df.2.f[,c(1,6:10)]
INBIRS.df.2.f<-data.frame(purrr::map(INBIRS.df.2.f, as.character ),
                               stringsAsFactors = FALSE)

INBIRS.df.3.f<-INBIRS.df.3.f[,c(1,6:10)]
INBIRS.df.3.f<-data.frame(purrr::map(INBIRS.df.3.f, as.character ),
                               stringsAsFactors = FALSE)


Espectros.INBIRS.4.f<-Espectros.INBIRS.4.f[,c(1,6:10)]
Espectros.INBIRS.4.f<-data.frame(purrr::map(Espectros.INBIRS.4.f, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.1.Neg<- Categ.Hospi.1.Neg[,c(1,5,7,10:12)]
#Categ.Hospi.1.Neg<- data.frame(map(Categ.Hospi.1.Neg, as.character),
 #                              stringsAsFactors = FALSE)
Categ.Hospi.1.Neg<-data.frame(purrr::map(Categ.Hospi.1.Neg, as.character ),
                              stringsAsFactors = FALSE)

Categ.Hospi.1.Pos<- Categ.Hospi.1.Pos[,c(1,5,7,10:12)]
Categ.Hospi.1.Pos<-data.frame(purrr::map(Categ.Hospi.1.Pos, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.2.Cnt<- Categ.Hospi.2.Cnt[,c(1,5,8,11:13)]
Categ.Hospi.2.Cnt<-data.frame(purrr::map(Categ.Hospi.2.Cnt, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.2.Neg<- Categ.Hospi.2.Neg[,c(1,5,8,11:13)]
Categ.Hospi.2.Neg<-data.frame(purrr::map(Categ.Hospi.2.Neg, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.2.No.Covid<- Categ.Hospi.2.No.Covid[,c(1,5,8,11:13)]
Categ.Hospi.2.No.Covid<-data.frame(purrr::map(Categ.Hospi.2.No.Covid, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.2.Pos<- Categ.Hospi.2.Pos[,c(1,5,8,11:13)]
Categ.Hospi.2.Pos<-data.frame(purrr::map(Categ.Hospi.2.Pos, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.3.Neg<- Categ.Hospi.3.Neg[,c(1,5,8,11:13)]
Categ.Hospi.3.Neg<-data.frame(purrr::map(Categ.Hospi.3.Neg, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.3.No.Covid<- Categ.Hospi.3.No.Covid[,c(1,5,8,11:13)]
Categ.Hospi.3.No.Covid<-data.frame(purrr::map(Categ.Hospi.3.No.Covid, as.character ),
                               stringsAsFactors = FALSE)

Categ.Hospi.3.Pos<- Categ.Hospi.3.Pos[,c(1,5,8,11:13)]
Categ.Hospi.3.Pos<-data.frame(purrr::map(Categ.Hospi.3.Pos, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego.clin.1.Exp1.covid<-Categ.Ciego.clin.1.Exp1.covid[,c(1,6,7,9:11)]
Categ.Ciego.clin.1.Exp1.covid<-data.frame(purrr::map(Categ.Ciego.clin.1.Exp1.covid, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego.clin.1.Exp1.flu<-Categ.Ciego.clin.1.Exp1.flu[,c(1,6,7,9:11)]
Categ.Ciego.clin.1.Exp1.flu<-data.frame(purrr::map(Categ.Ciego.clin.1.Exp1.flu, as.character ),
                               stringsAsFactors = FALSE)

Categ.Neg.New.clin.1<-Categ.Neg.New.clin.1[,c(1,6:10)]
Categ.Neg.New.clin.1<-data.frame(purrr::map(Categ.Neg.New.clin.1, as.character ),
                               stringsAsFactors = FALSE)

Categ.Pos.New.clin.1<-Categ.Pos.New.clin.1[,c(1,6:10)]
Categ.Pos.New.clin.1<-data.frame(purrr::map(Categ.Pos.New.clin.1, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego.clin25.6.2.covid<-Categ.Ciego.clin25.6.2.covid[,c(1,6,7, 9:11)]
Categ.Ciego.clin25.6.2.covid<-data.frame(purrr::map(Categ.Ciego.clin25.6.2.covid, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego25.6.clin.2.flu<-Categ.Ciego25.6.clin.2.flu[,c(1,6,7, 9:11)]
Categ.Ciego25.6.clin.2.flu<-data.frame(purrr::map(Categ.Ciego25.6.clin.2.flu, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego_3_7.4<-Categ.Ciego_3_7.4[,c(1,6:10)]
Categ.Ciego_3_7.4<-data.frame(purrr::map(Categ.Ciego_3_7.4, as.character ),
                               stringsAsFactors = FALSE)

Categ.Ciego_8_7.4<-Categ.Ciego_8_7.4[,c(1,6:10)]
Categ.Ciego_8_7.4<-data.frame(purrr::map(Categ.Ciego_8_7.4, as.character ),
                               stringsAsFactors = FALSE)


Categ.Malbran.1.1.1<-Categ.Malbran.1.1.1[,c(1,5:9)]
Categ.Malbran.1.1.1<-data.frame(purrr::map(Categ.Malbran.1.1.1, as.character ),
                               stringsAsFactors = FALSE)

Categ.Malbran.2.1.1<-Categ.Malbran.2.1.1[,c(1,5:9)]
Categ.Malbran.2.1.1<-data.frame(purrr::map(Categ.Malbran.2.1.1, as.character ),
                               stringsAsFactors = FALSE)

Malbran_3_4.1<-Malbran_3_4.1[,c(1,6:10)]
Malbran_3_4.1<-data.frame(purrr::map(Malbran_3_4.1, as.character ),
                               stringsAsFactors = FALSE)

CostaRica.1.1<-CostaRica.1.1[,c(1,6:10)]
CostaRica.1.1<-data.frame(purrr::map(CostaRica.1.1, as.character ),
                               stringsAsFactors = FALSE)

CostaRica.1.1$Carga<-as.character(CostaRica.1.1$Carga)

CostaRica.3.1.1.1<-CostaRica.3.1.1.1[,c(1,6:10)]
CostaRica.3.1.1.1<-data.frame(purrr::map(CostaRica.3.1.1.1, as.character),
                               stringsAsFactors = FALSE)
CostaRica.3.1.1.1$Carga<-as.character(CostaRica.3.1.1.1$Carga)

```

```{r}
dataframes <- list(INBIRS.1.df.f.1,
INBIRS.df.2.f,
INBIRS.df.3.f,
Espectros.INBIRS.4.f,
Categ.Hospi.1.Neg,
Categ.Hospi.1.Pos,
Categ.Hospi.2.Cnt,
Categ.Hospi.2.Neg,
Categ.Hospi.2.No.Covid,
Categ.Hospi.2.Pos,
Categ.Hospi.3.Neg,
Categ.Hospi.3.No.Covid,
Categ.Hospi.3.Pos,
Categ.Ciego.clin.1.Exp1.covid,
Categ.Ciego.clin.1.Exp1.flu,
Categ.Neg.New.clin.1,
Categ.Pos.New.clin.1,
Categ.Ciego.clin25.6.2.covid,
Categ.Ciego25.6.clin.2.flu,
Categ.Ciego_3_7.4,
Categ.Ciego_8_7.4,
Categ.Malbran.1.1.1,
Categ.Malbran.2.1.1,
Malbran_3_4.1,
CostaRica.1.1,
CostaRica.3.1.1.1)




# Contar filas para cada dataframe
filas_count <- sapply(dataframes, nrow)

# Mostrar los resultados
print(filas_count)
sum(filas_count)
```

# 6. Union de todos los dataframes

```{r}
Base.Union.Clinc.Covid <- INBIRS.1.df.f.1 %>%
  bind_rows(INBIRS.df.2.f) %>%
  bind_rows(INBIRS.df.3.f) %>%
  bind_rows(Espectros.INBIRS.4.f) %>%
bind_rows(Categ.Hospi.1.Neg)%>%
bind_rows(Categ.Hospi.1.Pos)%>%
bind_rows(Categ.Hospi.2.Cnt)%>%
bind_rows(Categ.Hospi.2.Neg)%>%
bind_rows(Categ.Hospi.2.No.Covid)%>%
bind_rows(Categ.Hospi.2.Pos)%>%
bind_rows(Categ.Hospi.3.Neg)%>%
bind_rows(Categ.Hospi.3.No.Covid)%>%
bind_rows(Categ.Hospi.3.Pos)%>%
bind_rows(Categ.Ciego.clin.1.Exp1.covid)%>%
bind_rows(Categ.Ciego.clin.1.Exp1.flu)%>%
bind_rows(Categ.Neg.New.clin.1)%>%
bind_rows(Categ.Pos.New.clin.1)%>%
bind_rows(Categ.Ciego.clin25.6.2.covid)%>%
bind_rows(Categ.Ciego25.6.clin.2.flu)%>%
bind_rows(Categ.Ciego_3_7.4)%>%
bind_rows(Categ.Ciego_8_7.4)%>%
bind_rows(Categ.Malbran.1.1.1)%>%
bind_rows(Categ.Malbran.2.1.1)%>%
bind_rows(Malbran_3_4.1)%>%
bind_rows(CostaRica.1.1)%>%
bind_rows(CostaRica.3.1.1.1)
```

```{r}
Espectra.Orig <- data.frame(names(Espectra.1),
                                  stringsAsFactors = FALSE)
names(Espectra.Orig)<- c("spot.a.1")

Datos_actualizados<-  Espectra.Orig %>%
  left_join( Base.Union.Clinc.Covid, by="spot.a.1")
```


```{r}
save(Datos_actualizados, file = "metadata.rda")

```


```{r}
# dev.new()
# 
# # Inicializar el gr√°fico con el primer espectro
# plot(Espectra.1[[1]], main = "Espectros Superpuestos", col = "blue", type = "l")
# 
# # Iterar sobre los espectros restantes y agregarlos al gr√°fico
# for (i in 2:length(Espectra.1)) {
#   lines(Espectra.1[[i]], col = i)  # A√±adir l√≠neas para cada espectro, con diferentes colores
# }
# 
# # A√±adir una leyenda para indicar los colores de cada espectro
# legend("topright", legend = 1:length(Espectra.1), col = 1:length(Espectra.1),
#        title = "Espectros", cex = 0.8)
```

# 7. Deteccion y filtrado de picos

```{r , message=FALSE, echo=FALSE, warning=FALSE}

peaks <- detectPeaks(Espectra.1, SNR = 3, 
                     method="MAD", halfWindowSize=50)
peaks <- binPeaks(peaks,tolerance=0.5)

species.Ave<-factor(Datos_actualizados$PCR.Cov) 
spot.factor.Avera<-factor(Datos_actualizados$spot.a.1) 

peaks <- filterPeaks(peaks, minFrequency=c(0.2, 0.2),
                     labels = species.Ave,
                     mergeWhitelists=TRUE)

featureMatrix <- intensityMatrix(peaks, Espectra.1)
```


dejo tres decimales

```{r}
featureMatrix <- apply(featureMatrix, c(1, 2), function(x) signif(x, digits = 3))

```

```{r}
save(featureMatrix, file = "feature_matrix.rda")

```


```{r}
num_peaks <- sapply(peaks, length)
freq_table <- table(num_peaks)

# Mostrar la tabla
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Num_Peaks", "Frequency")

# Mostrar la tabla con cantidad de espectros con x cantidad de picos
print(freq_df)
```



```{r}
featureMatrix<- cbind(featureMatrix, label=Datos_actualizados$spot.a.1, covid=Datos_actualizados$PCR.Cov, carga=Datos_actualizados$Carga, dia=Datos_actualizados$batch, equipo=Datos_actualizados$equipo, fecha=Datos_actualizados$fecha, institucion=Datos_actualizados$institucion)
```

```{r}
featureMatrix<- as.data.frame(featureMatrix)
featureMatrix <- featureMatrix %>%
  filter(carga %in% c("High", "Int", "Neg"))

```

Quedan 229 espectros con cargas HIGH INT y NEG. Aclaracion: como costa rica no coloco el dato, en carga solo dice Cov.Pos o neg, no se incluyen en el an√°lisis

```{r}
featureMatrix
```


# 8. EDA

```{r}
Datos_actualizados <- Datos_actualizados %>%
  filter(Carga %in% c("High", "Int", "Neg"))

# Crear tabla de frecuencias
data_freq <- as.data.frame(table(Datos_actualizados$institucion, Datos_actualizados$PCR.Cov))
colnames(data_freq) <- c("institucion", "covid_status", "frecuencia")


# Gr√°fico de barras superpuestas
ggplot(data_freq, aes(x = institucion, y = frecuencia, fill = covid_status)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Frecuencia por Instituci√≥n",
       x = "Instituci√≥n",
       y = "Frecuencia") +
  scale_fill_manual(values = c("Cov.Neg" = "blue", "Cov.Pos" = "red")) +
  theme_minimal()
```

```{r}

print(data_freq)
```


```{r}


# Cargar la librer√≠a
library(writexl)

# Exportar a Excel
write.xlsx(data_freq, "C:/Users/karin/Desktop/MCD/TESIS/datafreq.xlsx")
```

```{r}
Datos_actualizados<- Datos_actualizados[ , -10]

Datos_actualizados$id <- 1:nrow(Datos_actualizados)
Datos_actualizados <- Datos_actualizados[ , c("id", names(Datos_actualizados)[-ncol(Datos_actualizados)])]
```

# 9 Matrices
## Matriz de intensidades con label

```{r}

# Crear una nueva columna con secuencia del 1 hasta el n√∫mero de filas
featureMatrix<- cbind(id=Datos_actualizados$id, featureMatrix) 
```

## Matriz numerica

```{r}
# Exclude non-numerical columns 
featureMatrix_num <- featureMatrix[, -c(1, (ncol(featureMatrix)-5):ncol(featureMatrix))]
```

```{r}
featureMatrix_num <- apply(featureMatrix_num, 2, function(x) as.numeric(as.character(x)))

```

```{r}
sapply(featureMatrix_num, class)
```

```{r}
class(featureMatrix_num)
```


```{r}
# Calcular estad√≠sticas por pico con conversi√≥n num√©rica
pico_stats <- function(featureMatrix_num) {
  # Convertimos la matriz a num√©rica, preservando los nombres de las columnas
  nombres_picos <- colnames(featureMatrix_num)
  
  # Convertimos la matriz a num√©rica
  featureMatrix_num <- apply(featureMatrix_num, 2, function(x) as.numeric(as.character(x)))
  colnames(featureMatrix_num) <- nombres_picos
  
  # Calculamos las estad√≠sticas
  stats <- data.frame(
    nombre_pico = nombres_picos,
    promedio = colMeans(featureMatrix_num, na.rm = TRUE),
    minimo = apply(featureMatrix_num, 2, min, na.rm = TRUE),
    maximo = apply(featureMatrix_num, 2, max, na.rm = TRUE),
    desv_std = apply(featureMatrix_num, 2, sd, na.rm = TRUE)
  )
  
  # A√±adimos el n√∫mero de pico
  stats$pico_numero <- 1:nrow(stats)
  
  # Reordenamos las columnas
  stats <- stats[, c("pico_numero", "nombre_pico", "promedio", "minimo", "maximo", "desv_std")]
  
  return(stats)
}

# Para usar la funci√≥n:
resultados <- pico_stats(featureMatrix_num)

# Ver los primeros resultados
head(resultados)

```



# 10. PCA mixOmics

```{r}

#  install.packages("BiocManager") 
## install mixOmics 
#BiocManager::install('mixOmics')
```

```{r}
library(mixOmics)

#Performs a principal components analysis on the given data matrix that can contain missing values. If data are complete 'pca' uses Singular Value Decomposition, if there are some missing values, it uses the NIPALS algorithm.
```

```{r}
featureMatrix_num <- apply(featureMatrix_num, 2, as.numeric)

str(featureMatrix_num)
```

```{r}
?pca
```

```{r}

pca.before <- pca(featureMatrix_num, ncomp = 10)   #ncomp=	Integer, if data is complete ncomp decides the number of components and associated eigenvalues to display from the pcasvd algorithm and if the data has missing values, ncomp gives the number of components to keep to perform the reconstitution of the data using the NIPALS algorithm. If NULL, function sets ncomp = min(nrow(X), ncol(X))
```

```{r}
#pca.before$institucion <- Datos_actualizados$institucion
pca.before$fecha <- Datos_actualizados$fecha
pca.before$equipo <- Datos_actualizados$equipo
pca.before$covid<- Datos_actualizados$PCR.Cov
```

```{r}
pca_coor<-as.data.frame(pca.before$variates$X) # Coordenadas principales obtenidas del PCA
pca.before$X

```

```{r}
dim(pca_coor)
```

```{r}
colnames(pca.before$variates$X) <- paste0("PC", 1:ncol((pca.before$variates$X)))
```

```{r}
library(ggExtra)
#expl_var <- pca.before$sdev^2 / sum(pca.before$sdev^2)  # Varianza explicada por cada componente

# Crear un gr√°fico de dispersi√≥n con ggplot2
p <- ggplot(pca_coor, aes(x = PC1, y = PC2, color = pca.before$equipo, shape = pca.before$covid)) +
  geom_point(size = 2) +  # Tama√±o de los puntos
  labs(title = 'PCA con mixOmics',
       x = 'Componente principal 1',
       y = 'Componente principal 2',
       color = 'Batch', shape = 'Tratamiento') +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12,),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 1),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
  )


# A√±adir gr√°ficos de densidad marginal con ggExtra
p_with_density <- ggMarginal(p, type = "density", margins = "both", groupColour = TRUE, groupFill = TRUE)

# Mostrar el gr√°fico final
print(p_with_density)
```

```{r}
library(ggExtra)
#expl_var <- pca.before$sdev^2 / sum(pca.before$sdev^2)  # Varianza explicada por cada componente

# Crear un gr√°fico de dispersi√≥n con ggplot2
p <- ggplot(pca_coor, aes(x = PC2, y = PC3, color = pca.before$equipo, shape = pca.before$covid)) +
  geom_point(size = 2) +  # Tama√±o de los puntos
  labs(title = 'PCA con mixOmics',
       x = 'Componente principal 2',
       y = 'Componente principal 3',
       color = 'Batch', shape = 'Tratamiento') +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12,),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 1),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
  )


# A√±adir gr√°ficos de densidad marginal con ggExtra
p_with_density2 <- ggMarginal(p, type = "density", margins = "both", groupColour = TRUE, groupFill = TRUE)

# Mostrar el gr√°fico final
print(p_with_density2)
```


```{r}
library(ggExtra)
#expl_var <- pca.before$sdev^2 / sum(pca.before$sdev^2)  # Varianza explicada por cada componente

# Crear un gr√°fico de dispersi√≥n con ggplot2
p <- ggplot(pca_coor, aes(x = PC1, y = PC2, color = pca.before$covid)) +
  geom_point(size = 2) +  # Tama√±o de los puntos
  labs(title = 'PCA con mixOmics',
       x = 'Componente principal 1',
       y = 'Componente principal 2',
       color = 'Batch') +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12,),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 10),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 10),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 1),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 10),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 10)  # Reducir tama√±o del texto de la leyenda
  )


# A√±adir gr√°ficos de densidad marginal con ggExtra
p_with_density3 <- ggMarginal(p, type = "density", margins = "both", groupColour = TRUE, groupFill = TRUE)

# Mostrar el gr√°fico final
print(p_with_density3)
```

```{r}
# Extraer la varianza explicada
explained_var <- pca.before$prop_expl_var$X * 100  # Convertir a porcentaje
components <- seq_along(explained_var)  # Crear un √≠ndice para los componentes

# Crear un data frame para el gr√°fico
var_df <- data.frame(
  Component = components,
  ExplainedVariance = explained_var
)

# Graficar usando ggplot2
library(ggplot2)
explained_var_plot_MixOmics<- ggplot(var_df, aes(x = Component, y = ExplainedVariance)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes(label = round(ExplainedVariance, 1)), vjust = -0.5, size = 3) +

  labs(
    title = "Varianza explicada -MixOmics",
    x = "Componente Principal",
    y = "Varianza Explicada (%)"
  ) +
  theme_minimal()+
  theme(
    plot.title = element_text(size = 12,),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 1),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
  )

print(explained_var_plot_MixOmics)

```






```{r}
# Crear el gr√°fico de dispersi√≥n b√°sico
# p1 <- ggplot(pca_coor, aes(x = PC1, y = PC2, color = pca.before$equipo, shape = pca.before$covid)) +
#   geom_point(size = 2) +
#   labs(title = 'PCA con mixOmics', x = 'PC1', y = 'PC2', color = 'Batch', shape = 'Covid') +
#   theme_minimal()
# 
# # A√±adir gr√°ficos de densidad marginal con ggExtra
# p_with_density <- ggMarginal(p1, type = "density", margins = "both", groupColour = TRUE, groupFill = TRUE)
# 
# # Crear otro gr√°fico de dispersi√≥n b√°sico
# p2 <- ggplot(pca_coor, aes(x = PC2, y = PC3, color = pca.before$equipo, shape = pca.before$covid)) +
#   geom_point(size = 2) +
#   labs(title = 'PCA con mixOmics', x = 'PC2', y = 'PC3', color = 'Batch', shape = 'COVID') +
#   theme_minimal()
# 
# # A√±adir gr√°ficos de densidad marginal con ggExtra
# p_with_density2 <- ggMarginal(p2, type = "density", margins = "both", groupColour = TRUE, groupFill = TRUE)
# 
# p3 <- ggplot(pca_coor, aes(x = PC1, y = PC2, color = pca.before$covid)) +
#   geom_point(size = 2) +
#   labs(title = 'PCA con mixOmics', x = 'PC1', y = 'PC2', color = 'COVID') +
#   theme_minimal()
# 
# # A√±adir gr√°ficos de densidad marginal con ggExtra
# p_with_density3 <- ggMarginal(p2, type = "density", margins = "both", groupColour = TRUE, groupFill = TRUE)
# 
# 
# p1_base <- p1
# p2_base <- p2
# p3_base <- p3
# 
# 
# combined_plot_Omics <- (
#   (p1_base + p2_base) /
#     (p3_base + explained_var_plot_MixOmics)  # Solo los gr√°ficos base sin los m√°rgenes
# )
# 
# # Agregar t√≠tulo y etiquetas a los gr√°ficos combinados
# combined_plot2 <- combined_plot_Omics + 
#   plot_annotation(
#     title = "PCA con MixOmics",
#     tag_levels = "A"  # Etiquetas A, B, C, ...
#   ) + 
#   plot_layout(guides = "collect")  # Para combinar las leyendas
# 
# # Mostrar el gr√°fico combinado
# print(combined_plot2)
```

```{r}

# ggsave(
#   filename = "combined_plot_mixOmics.png",
#   plot = combined_plot2,
#   width = 12,
#   height = 10,
#   dpi = 300
# )

```



```{r}
# library(gridExtra)
# library(grid)
# 
# combined_plot <- grid.arrange(p_with_density, p_with_density2, p_with_density3, explained_var_plot_MixOmics, 
#                             ncol = 2)  # Puedes ajustar el n√∫mero de columnas
# 
# # Para guardar el gr√°fico combinado
# png("graficos_combinados.png", width = 1200, height = 800)
# grid.arrange(p_with_density, p_with_density2, p_with_density3, explained_var_plot_MixOmics,
#              ncol = 2)
# dev.off()

```
```{r}
# ggsave(
#   filename = "combined_plot_mixOmics.png",
#   plot = combined_plot,
#   width = 12,
#   height = 10,
#   dpi = 300
# )
```


```{r}
# ggplot(pca_coor, aes(x = pca_coor$PC1, y = pca_coor$PC2, color = pca.before$fecha, shape = pca.before$covid))  +
#   geom_point(size = 3) + # Tama√±o de los puntos
#   labs(title = "PCA - Componentes Principales",
#        x = "Componente Principal 1",
#        y = "Componente Principal 2") +
#   scale_color_manual(values = c( "red", "blue", "green", "purple", "orange", "pink", "yellow", "cyan", "brown", "magenta", "gray", "black", "darkgreen", "darkblue")) + # Personaliza los colores si es necesario
#   scale_shape_manual(values = c(16, 17)) + # Personaliza las formas si es necesario
#   theme_minimal() # O puedes usar otro tema si prefieres
```

# 11. PCA con prcomp

```{r}
# Perform PCA on numerical columns only
pca_res <- prcomp(featureMatrix_num, scale. = TRUE)

```




```{r}


porcentaje_varianza_explicada <- (pca_res$sdev^2 / sum(pca_res$sdev^2)) * 100
components <- seq_along(porcentaje_varianza_explicada) 


# Crear un data frame para el gr√°fico
var_df <- data.frame(
  Component = components,
  ExplainedVariance = porcentaje_varianza_explicada
)
 # Crear un √≠ndice para los componentes



var_df_10 <- var_df[1:10, ]

# Graficar usando ggplot2
library(ggplot2)
exaplained_var_plot_rbase<- ggplot(var_df_10, aes(x = Component, y = ExplainedVariance)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes(label = round(ExplainedVariance, 1)), vjust = -0.5, size = 3) +
    ylim(0, max(var_df_10$ExplainedVariance) * 1.1) +
  labs(
    title = "Varianza explicada",
    x = "Componente Principal",
    y = "Varianza Explicada (%)"
  ) +
  theme_minimal()+
    theme(
    plot.title = element_text(size = 12, face = "bold"),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 10),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 10),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 10)  # Reducir tama√±o del texto de la leyenda
  )


print(exaplained_var_plot_rbase)
```






```{r}
summary(pca_res)
```

```{r}

# Now you can add back the categorical data for plotting purposes
pca_data <- as.data.frame(pca_res$x)
#pca_data$institucion <- Datos_actualizados$institucion
pca_data$fecha <- Datos_actualizados$fecha
pca_data$equipo <- Datos_actualizados$equipo
pca_data$covid<- Datos_actualizados$PCR.Cov

```

```{r}
pca_prcomp<- ggplot(pca_data, aes(x = PC1, y = PC2, color = equipo, shape = covid)) +
  geom_point(size = 2) + # Tama√±o de los puntos
  labs(title = "PCA - PC1 y PC2 R base",
       x = "Componente Principal 1",
       y = "Componente Principal 2") +
  scale_color_manual(values = c( "blue", "green", "purple")) + # Personaliza los colores si es necesario
  scale_shape_manual(values = c(16, 17)) + # Personaliza las formas si es necesario
  theme_minimal()+
  theme_minimal()+
    theme(
    plot.title = element_text(size = 12, face = "bold"),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 1),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
  )
print(pca_prcomp)
```

```{r}
pca_prcomp2<-ggplot(pca_data, aes(x = PC2, y = PC3, color = equipo, shape = covid)) +
  geom_point(size = 2) + # Tama√±o de los puntos
  labs(title = "PCA - PC2 y PC3- R base",
       x = "Componente Principal 2",
       y = "Componente Principal 3") +
  scale_color_manual(values = c( "blue", "green", "purple")) + # Personaliza los colores si es necesario
  scale_shape_manual(values = c(16, 17)) + # Personaliza las formas si es necesario
  theme_minimal()+
  theme_minimal()+
    theme(
    plot.title = element_text(size = 12, face = "bold"),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 1),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
  )

print(pca_prcomp2)
```

```{r}
# ggplot(pca_data, aes(x = PC1, y = PC2, color = institucion, shape = covid)) +
#   geom_point(size = 3) + # Tama√±o de los puntos
#   labs(title = "PCA - Componentes Principales",
#        x = "Componente Principal 1",
#        y = "Componente Principal 2") +
#   scale_color_manual(values = c( "red","blue", "green", "purple")) + # Personaliza los colores si es necesario
#   scale_shape_manual(values = c(16, 17)) + # Personaliza las formas si es necesario
#   theme_minimal() # O puedes usar otro tema si prefieres
```

```{r}
ggplot(pca_data, aes(x = PC1, y = PC2, color = fecha, shape = covid)) +
  geom_point(size = 3) + # Tama√±o de los puntos
  labs(title = "PCA - Componentes Principales",
       x = "Componente Principal 1",
       y = "Componente Principal 2") +
  scale_color_manual(values = c( "red", "blue", "green", "purple", "orange", "pink", "yellow", "cyan", "brown", "magenta", "gray", "black", "darkgreen", "darkblue")) +
  scale_shape_manual(values = c(16, 17)) +
  theme_minimal()

```

```{r}
valores_unicos_fecha <- unique(featureMatrix[,"fecha"])

# Mostrar los valores √∫nicos
print(valores_unicos_fecha)
```

```{r}
pos_neg<- ggplot(pca_data, aes(x = PC1, y = PC2, color=covid, shape = covid)) +
  geom_point(size = 2) + # Tama√±o de los puntos
  labs(title = "PCA - COV POS/NEG",
       x = "Componente Principal 1",
       y = "Componente Principal 2") +
 scale_color_manual(values = c( "red","blue"))+
  scale_shape_manual(values = c(16, 17)) +
  theme_minimal()+
    theme(
    plot.title = element_text(size = 12, face = "bold"),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 12),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 1),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
  )


print(pos_neg)
```

```{r}
ggplot(pca_data, aes(x = pca_data$PC1, y = pca_data$PC3, color=covid, shape = covid)) +
  geom_point(size = 3) + # Tama√±o de los puntos
  labs(title = "PCA - Componentes Principales",
       x = "Componente Principal 1",
       y = "Componente Principal 3") +
 scale_color_manual(values = c( "red","blue"))+
  scale_shape_manual(values = c(16, 17)) +
  theme_minimal()
```







# 12. UMAP

```{r}
library(umap)
set.seed(42)

```

```{r}

library(uwot)
```

```{r}
set.seed(123)
umap_result <- umap(featureMatrix_num)
```

```{r}
umap_df <- as.data.frame(umap_result)
colnames(umap_df) <- c("V1", "V2")
```

```{r}
#umap_df$institucion <- Datos_actualizados$institucion
umap_df$fecha <- Datos_actualizados$fecha
umap_df$equipo <- Datos_actualizados$equipo
umap_df$covid<- Datos_actualizados$PCR.Cov
```

```{r}

UMAP_base<- ggplot(umap_df, aes(x = V1, y = V2, color = equipo, shape=covid)) +
  geom_point(size = 2) +
  labs(title = "UMAP base", x = "UMAP1", y = "UMAP2") +
  theme_minimal()+
  theme(
    plot.title = element_text(size = 16),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 10),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
  )
    
    
  
    print(UMAP_base)
```

```{r}

ggplot(umap_df, aes(x = V1, y = V2, color = covid, shape=covid)) +
  geom_point() +
  labs(title = "UMAP para Detecci√≥n de Efectos de Batch", x = "UMAP1", y = "UMAP2") +
    scale_shape_manual(values = c(16, 17)) +
  theme_minimal()

```

```{r}
ggplot(umap_df,aes(x = V1, y = V2, color = fecha, shape=covid)) +
  geom_point(size = 3) + # Tama√±o de los puntos
  labs(title = "UMAP POR FECHA",
       x = "UMAP 1",
       y = "UMAP 2") +
  scale_color_manual(values = c( "red", "blue", "green", "purple", "orange", "pink", "yellow", "cyan", "brown", "magenta", "gray", "black", "darkgreen", "darkblue")) +
  scale_shape_manual(values = c(16, 17)) +
  theme_minimal() # O puedes usar otro tema si prefieres
```

```{r}
#UMAP intenta encontrar una representaci√≥n (no lineal) de pocas dimensiones de los datos que preserve las distancias entre cada puntos y sus vecinos en el espacio multi-dimensional

#Comparison among PCA, t-SNE and UMAP : https://aurigait.com/blog/blog-easy-explanation-of-dimensionality-reduction-and-techniques/



library(umap)


# Ajustar par√°metros directamente en la funci√≥n umap
umap_v2 <- umap(featureMatrix_num, n_neighbors = 15, metric = "euclidean", min_dist = 0.5)

# Verificar la estructura del objeto umap_v2
str(umap_v2) # Esto te mostrar√° la estructura para asegurarte de que layout es un componente v√°lido.

# Si la estructura es correcta, continuar con la conversi√≥n a dataframe
umap_coor2 <- as.data.frame(umap_v2)

# Asignar nombres de columnas
colnames(umap_coor2) <- c("UMAP1", "UMAP2")

# A√±adir las columnas con los metadatos (COVID, equipo, etc.)
umap_coor2$covid <- Datos_actualizados$PCR.Cov
umap_coor2$equipo <- Datos_actualizados$equipo

# Graficar UMAP con ggplot2
library(ggplot2)
UMAP_ajustado<- ggplot(umap_coor2, aes(x = UMAP1, y = UMAP2, color = equipo, shape = covid)) +
  geom_point(size = 2) +
  labs(title = "UMAP par√°metros ajustados",
       x = "UMAP1",
       y = "UMAP2") +
  theme_minimal()+
  theme(
    plot.title = element_text(size = 16),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 10),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
  )

print(UMAP_ajustado)
```



```{r}

library(patchwork)
combined_plot <- (
  UMAP_base + UMAP_ajustado
)

# Agregar t√≠tulos a cada gr√°fico
combined_plot_UMAP <- combined_plot + 
  plot_annotation(
    title = "UMAP",
    tag_levels = "A"  # Etiquetas A, B, C, ...
  ) + 
  plot_layout(guides = "collect")  # Para combinar las leyendas, si hay

# Mostrar el gr√°fico combinado
print(combined_plot_UMAP)


```
```{r}
ggsave(
  filename = "combined_plot_UMAP.png",
  plot = combined_plot_UMAP,
  width = 12,
  height = 10,
  dpi = 300
)
```


```{r}

# 
# ggplot(umap_df, aes(x = V1, y = V2, color = institucion, shape=covid)) +
#   geom_point() +
#   labs(title = "UMAP para Detecci√≥n de Efectos de Batch", x = "UMAP1", y = "UMAP2") +
#     scale_shape_manual(values = c(16, 17)) +
#   theme_minimal()

```

```{r}
# # Ajustar par√°metros directamente en la funci√≥n umap
# umap_v3 <- umap2(featureMatrix_num)
# 
# # Verificar la estructura del objeto umap_v2
# str(umap_v3) # Esto te mostrar√° la estructura para asegurarte de que layout es un componente v√°lido.
# 
# # Si la estructura es correcta, continuar con la conversi√≥n a dataframe
# umap_coor3 <- as.data.frame(umap_v3)
# 
# # Asignar nombres de columnas
# colnames(umap_coor3) <- c("UMAP1", "UMAP2")
# 
# # A√±adir las columnas con los metadatos (COVID, equipo, etc.)
# umap_coor3$covid <- Datos_actualizados$PCR.Cov
# umap_coor3$equipo <- Datos_actualizados$equipo
# 
# # Graficar UMAP con ggplot2
# library(ggplot2)
# ggplot(umap_coor3, aes(x = UMAP1, y = UMAP2, color = equipo, shape = covid)) +
#   geom_point(size = 3) +
#   labs(title = "UMAP para Detecci√≥n de Efectos de Batch",
#        x = "UMAP1",
#        y = "UMAP2") +
#   theme_minimal()


```





# 13. t-SNE

```{r}
#tsne
library(Rtsne)
library(ggplot2)
library(readxl)
library(RColorBrewer)
```

```{r}
?Rtsne
```

```{r}
set.seed(9)
tsne_model <- Rtsne(featureMatrix_num, check_duplicates=FALSE, 
                      pca=TRUE, perplexity=30, theta=0.5, dims=3)
```

```{r}
#tsne_model$institucion <- Datos_actualizados$institucion
tsne_model$fecha <- Datos_actualizados$fecha
tsne_model$equipo <- Datos_actualizados$equipo
tsne_model$covid<- Datos_actualizados$PCR.Cov
```

```{r}
tsne_data <- as.data.frame(tsne_model$Y)
colnames(tsne_data) <- c("Dim1", "Dim2","Dim3")
```

```{r}
#tsne_data$institucion <- Datos_actualizados$institucion
tsne_data$fecha <- Datos_actualizados$fecha
tsne_data$equipo <- Datos_actualizados$equipo
tsne_data$covid<- Datos_actualizados$PCR.Cov
```

```{r}
tSNE<-ggplot(tsne_data, aes(x=Dim1, y=Dim2, color=equipo, shape = covid)) +
  geom_point(size=2, alpha=0.7) +
  ggtitle("t-SNE 1 y 2") +
  theme_minimal(base_size=15) +
    theme(
    plot.title = element_text(size = 16),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 10),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
  )
  scale_color_manual(values=c("#D32F2F", "#1976D2", "#388E3C"))  # Use a color palette
  print(tSNE)
```



```{r}
tSNE2<-ggplot(tsne_data, aes(x=Dim2, y=Dim3, color=equipo, shape=covid)) +
  geom_point(size=2, alpha=0.7) +
  ggtitle("t-SNE 2 y 3") +
  theme_minimal(base_size=15) +
    theme(
    plot.title = element_text(size = 16),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 10),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 12),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 12)  # Reducir tama√±o del texto de la leyenda
  )
  scale_color_manual(values=c("#D32F2F", "#1976D2", "#388E3C"))  # Use a color palette
  print(tSNE2)
```



```{r}

library(patchwork)
combined_plot <- (
  tSNE + tSNE2
)

# Agregar t√≠tulos a cada gr√°fico
combined_plot_tSNE <- combined_plot + 
  plot_annotation(
    title = "UMAP",
    tag_levels = "A"  # Etiquetas A, B, C, ...
  ) + 
  plot_layout(guides = "collect")  # Para combinar las leyendas, si hay

# Mostrar el gr√°fico combinado
print(combined_plot_tSNE)


```


```{r}
ggsave(
  filename = "combined_plot_tSNE.png",
  plot = combined_plot_tSNE,
  width = 12,
  height = 10,
  dpi = 300
)
```

# 14. Imposibilidad de analizar Cts:

```{r}

cantidad_sd_0_na <- sum(Datos_actualizados$Carga %in% c("SD", "0") | is.na(Datos_actualizados$Carga))

# Mostrar el resultado
cantidad_sd_0_na
```

```{r}
valores_unicos <- unique(Datos_actualizados$Carga)
print(valores_unicos)

```
```{r}
frecuencias <- table(Datos_actualizados$Carga)
print(frecuencias)
```



```{r}
library(dplyr)
# Convertir las variables categ√≥ricas en factores
Datos_actualizados <- Datos_actualizados[,c(1:7)] %>%
  mutate(across(c(PCR.Cov, fecha, equipo), as.factor))

# Convertir la matriz de datos a una matriz num√©rica si a√∫n no lo es
featureMatrix_num <- as.matrix(featureMatrix_num)

```

```{r}
# Prueba de normalidad: Prop√≥sito: Verificar si las puntuaciones de los componentes principales siguen una distribuci√≥n normal.
shapiro.test(pca.before$X[, 1])

# Prueba de homocedasticidad: Prop√≥sito: Evaluar si las varianzas entre grupos (definidos por un factor como PCR.Cov) son iguales. Algunas pruebas estad√≠sticas (como ANOVA) requieren homogeneidad de varianzas.

library(car)
leveneTest(pca.before$X[, 1] ~ Datos_actualizados$PCR.Cov)

```




```{r}
# Inicializar un dataframe para almacenar los resultados
shapiro_results <- data.frame(Componente = integer(), PValue = numeric(), stringsAsFactors = FALSE)

# Iterar sobre cada componente principal
for (i in 1:ncol(pca.before$X)) {
  p_value <- shapiro.test(pca.before$X[, i])$p.value
  shapiro_results <- rbind(shapiro_results, data.frame(Componente = i, PValue = p_value))
}

# Visualizar los resultados
print(shapiro_results)

```

# 15. Kruskal wallis
para detectar el peso de cada factor en el efecto batch. Prop√≥sito: Evaluar si las puntuaciones del PCA difieren significativamente entre los niveles de un factor (como PCR.Cov, fecha o equipo).
Kruskal-Wallis es una prueba no param√©trica que no asume normalidad, lo que la hace adecuada si los datos no pasan la prueba de Shapiro-Wilk.

```{r}
# Cargar librer√≠as necesarias
library(ggplot2)
library(dplyr)

# 1. Realizar PCA
pca_result <- prcomp(featureMatrix_num, scale. = TRUE)

# 2. Obtener las puntuaciones de los componentes principales
pca_scores <- pca_result$x

# 3. Agregar los resultados PCA al dataframe de metadatos
metadata_pca <- cbind(Datos_actualizados[,c(4:7)], pca_scores)

# 4. Funci√≥n para realizar Kruskal-Wallis sobre los componentes principales
kruskal_pca <- function(pca_scores, metadata, factor) {
  results <- data.frame()
  for (i in 1:ncol(pca_scores)) {  # Para cada componente principal
    pca_component <- pca_scores[, i]  # Extraer la puntuaci√≥n del componente
    model <- kruskal.test(pca_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
    factor_effect <- model$p.value  # Obtener el p-valor
    results <- rbind(results, data.frame(PC = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
  }
  return(results)
}

# 5. Lista de factores que quieres analizar
factors <- c("PCR.Cov", "fecha", "equipo")

# Ejecutar la funci√≥n para cada factor y combinar los resultados
kruskal_results <- do.call(rbind, lapply(factors, function(f) kruskal_pca(pca_scores, Datos_actualizados, f)))

# 6. Resumir el p-valor medio para cada factor
factor_summary <- kruskal_results %>%
  group_by(Factor) %>%
  summarise(MeanLogPValue = -log10(mean(PValue)))

pca_kruskal<- ggplot(factor_summary, aes(x = reorder(Factor, MeanLogPValue), y = MeanLogPValue, fill = Factor)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Importancia de los Factores PCA",
       x = "Factor",
       y = "-log10(P-valor Medio)",
       fill = "Factor")
    theme(
    plot.title = element_text(size = 30),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 26),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 26),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 18),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 24),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 24)  # Reducir tama√±o del texto de la leyenda
  )
print(pca_kruskal)
```

# 16. Kruskal wallis 
para detectar el peso de cada factor en el efecto batch en analisis de UMAP

```{r}
# Prueba de normalidad Shapiro-Wilk en la primera dimensi√≥n de UMAP
shapiro.test(umap_v2[, 1])

# Prueba de normalidad Shapiro-Wilk en la segunda dimensi√≥n de UMAP
shapiro.test(umap_v2[, 2])


```

```{r}

umap_scores <- umap_v2  # Tomar el resultado de UMAP directamente

# Luego sigues con el mismo an√°lisis
metadata_umap <- cbind(Datos_actualizados[,c(4,5,7)], umap_scores)

# Funci√≥n para realizar Kruskal-Wallis sobre las dimensiones de UMAP
kruskal_umap <- function(umap_scores, metadata, factor) {
  results <- data.frame()
  for (i in 1:ncol(umap_scores)) {  # Para cada dimensi√≥n de UMAP
    umap_component <- umap_scores[, i]  # Extraer la puntuaci√≥n de la dimensi√≥n
    model <- kruskal.test(umap_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
    factor_effect <- model$p.value  # Obtener el p-valor
    results <- rbind(results, data.frame(UMAP_Dim = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
  }
  return(results)
}

# Lista de factores que quieres analizar
factors <- c("PCR.Cov", "fecha", "equipo")

# Ejecutar la funci√≥n para cada factor y combinar los resultados
kruskal_results_umap <- do.call(rbind, lapply(factors, function(f) kruskal_umap(umap_scores, Datos_actualizados, f)))

# Resumir el p-valor medio para cada factor
factor_summary_umap <- kruskal_results_umap %>%
  group_by(Factor) %>%
  summarise(MeanPValue = mean(PValue))

# Visualizar los resultados en un gr√°fico de barras
factor_summary <- kruskal_results %>%
  group_by(Factor) %>%
  summarise(MeanLogPValue = -log10(mean(PValue)))

UMAP_kruskal<- ggplot(factor_summary, aes(x = reorder(Factor, MeanLogPValue), y = MeanLogPValue, fill = Factor)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Importancia de los Factores-UMAP",
       x = "Factor",
       y = "-log10(P-valor Medio)",
       fill = "Factor")
    theme(
    plot.title = element_text(size = 30),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 26),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 26),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 18),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 24),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 24)  # Reducir tama√±o del texto de la leyenda
  )
print(UMAP_kruskal)
```



```{r}
library(patchwork)
combined_plot <- (
  pca_kruskal+UMAP_kruskal
)

# Agregar t√≠tulos a cada gr√°fico
combined_plot_kruskal <- combined_plot + 
  plot_annotation(
    title = "Influencia de los factores en los datos",
    tag_levels = "A"  # Etiquetas A, B, C, ...
  ) + 
  plot_layout(guides = "collect")  # Para combinar las leyendas, si hay

# Mostrar el gr√°fico combinado
print(combined_plot_kruskal)
```


```{r}
ggsave(
  filename = "combined_plot_kruskal.png",
  plot = combined_plot_kruskal,
  width = 12,
  height = 10,
  dpi = 400
)
```



```{r}
#PVCA combina PCA y ANOVA (an√°lisis de varianza) para descomponer la varianza total en componentes atribuibles a diferentes factores (variables categ√≥ricas o continuas). Esto permite medir la proporci√≥n de la varianza atribuible a diferentes fuentes.

# library(lme4)
# library(ggplot2)
# 
# # Function to perform PVCA
# perform_pvca <- function(featureMatrix_num, Datos_actualizados, factors_to_analyze) {
#   print("Starting PVCA analysis...")
#   
#   # Check inputs
#   if (!is.matrix(featureMatrix_num) || !is.numeric(featureMatrix_num)) {
#     stop("featureMatrix_num must be a numeric matrix")
#   }
#   if (!is.data.frame(Datos_actualizados)) {
#     stop("Datos_actualizados must be a data frame")
#   }
#   if (!all(factors_to_analyze %in% names(Datos_actualizados))) {
#     stop("Not all factors_to_analyze are present in Datos_actualizados")
#   }
#   if (nrow(featureMatrix_num) != nrow(Datos_actualizados)) {
#     stop("Number of rows in featureMatrix_num and Datos_actualizados must be the same")
#   }
#   
#   # Perform PCA
#   print("Performing PCA...")
#   pca_result <- prcomp(featureMatrix_num, scale. = TRUE)
#   
#   # Calculate proportion of variance explained by each PC
#   var_prop <- pca_result$sdev^2 / sum(pca_result$sdev^2)
#   
#   # Initialize results matrix
#   n_factors <- length(factors_to_analyze)
#   n_pcs <- ncol(pca_result$x)
#   vc_matrix <- matrix(0, nrow = n_factors, ncol = n_pcs)
#   
#   # Perform variance component analysis for each PC
#   print("Performing variance component analysis...")
#   for (i in 1:n_pcs) {
#     pc_data <- data.frame(PC = pca_result$x[, i], Datos_actualizados)
#     
#     # Create formula for mixed model
#     formula <- as.formula(paste("PC ~", paste("(1|", factors_to_analyze, ")", collapse = " + ")))
#     
#     # Fit mixed model
#     tryCatch({
#       mixed_model <- lmer(formula, data = pc_data, REML = TRUE)
#       
#       # Extract variance components
#       vc <- as.data.frame(VarCorr(mixed_model))
#       vc_matrix[, i] <- vc$vcov[1:n_factors]
#     }, error = function(e) {
#       warning(paste("Error in PC", i, ":", e$message))
#     })
#   }
#   
#   # Weight the variance components by the proportion of variance explained
#   weighted_vc <- vc_matrix %*% diag(var_prop)
#   
#   # Calculate the proportion of variance explained by each factor
#   pvca_results <- rowSums(weighted_vc) / sum(var_prop)
#   names(pvca_results) <- factors_to_analyze
#   
#   print("PVCA analysis completed.")
#   return(pvca_results)
# }
# 
# # Function to plot PVCA results
# plot_pvca <- function(pvca_results) {
#   print("Creating PVCA plot...")
#   results_df <- data.frame(
#     Factor = names(pvca_results),
#     Proportion = pvca_results
#   )
#   
#   p <- ggplot(results_df, aes(x = reorder(Factor, -Proportion), y = Proportion)) +
#     geom_bar(stat = "identity", fill = "steelblue") +
#     theme_minimal() +
#     labs(x = "Factors", y = "Proportion of Variance Explained", 
#          title = "Principal Variance Component Analysis") +
#     theme(axis.text.x = element_text(angle = 45, hjust = 1))
#   
#   print(p)
#   print("Plot created.")
# }
# 
# # Usage with your existing data:
# print("Preparing to run PVCA with your data...")
# 
# # Asumiendo que ya tiene featureMatrix_num y Datos_actualizados
# # Reemplace 'sus_factores' con los nombres reales de sus factores
# factors_to_analyze <- c('PCR.Cov', 'equipo', 'fecha')  # Por ejemplo: c("Factor1", "Factor2", "Factor3")
# 
# print("Running PVCA...")
# results <- perform_pvca(featureMatrix_num, Datos_actualizados, factors_to_analyze)
# print("PVCA Results:")
# print(results)
# 
# print("Creating plot...")
# plot_pvca(results)
# 
# print("Script execution completed.")
# ```
# ```{r}
# help("isSingular")
```

```{r}
dim(featureMatrix_num)
dim(Datos_actualizados)
```





## 17 Clustering



```{r}
library(dendextend)

distancias <- dist(featureMatrix_num)

# Realizar el clustering jer√°rquico
hc <- hclust(distancias, method = "ward.D2")

# Convierte el dendrograma a un objeto de dendextend
dend <- as.dendrogram(hc)

# Crea un vector de colores basado en PCR.cov
# Cambia "PCR.cov" a la columna adecuada de Datos_actualizados
label_colors <- as.factor(Datos_actualizados$PCR.Cov)
palette <- c("red", "blue") # Cambia los colores si hay m√°s de 2 categor√≠as
label_colors <- palette[label_colors]

# Aplica los colores a las etiquetas
dend <- dend %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.5) # Ajusta el tama√±o de las etiquetas

# Dibuja el dendrograma
png("dendrograma_COVID.png", width = 800, height = 600)
plot(dend, main = "Dendrograma por resultado COVID")
legend("topright",
       legend = c("COVID Negativo", "COVID Positivo"),
       fill = c("red", "blue"),
       border = "black",
       bty = "n",
       cex = 0.8)
dev.off() 

COVID_clustering<-plot(dend, main = "Dendrograma por resultado COVID")
legend("topright",           # Posici√≥n de la leyenda
       legend = c("COVID Negativo", "COVID Positivo"), # Textos de la leyenda
       fill = c("red", "blue"),                        # Colores de la leyenda
       border = "black",                               # Borde de las cajas de color
       bty = "n",                                      # Sin caja alrededor de la leyenda
       cex = 0.8)    


print(COVID_clustering)
```



```{r}
table(Datos_actualizados$PCR.Cov, label_colors)

```


 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_pos <- Datos_actualizados$PCR.Cov == "Cov.Pos"
featureMatrix_cov_pos <- featureMatrix_num[indices_cov_pos, ]
Datos_actualizados_cov_pos <- Datos_actualizados[indices_cov_pos, ]

# Verificar que los datos est√©n filtrados correctamente
dim(featureMatrix_cov_pos)
table(Datos_actualizados_cov_pos$equipo)


# Realizar el clustering jer√°rquico
dist_featureMatriz_cov_pos <- dist(featureMatrix_cov_pos)
hc_cov_pos <- hclust(dist_featureMatriz_cov_pos, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_pos <- as.dendrogram(hc_cov_pos)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(Datos_actualizados_cov_pos$equipo)
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]

# Personalizar el dendrograma

dend_cov_pos <- dend_cov_pos %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

png("dendrograma_COVID.pos.png", width = 800, height = 600)
plot(dend_cov_pos, main = "Clustering de Positivos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")
dev.off()

# Visualizar el dendrograma
plot(dend_cov_pos, main = "Clustering de Positivos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")

```


 
 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_neg <- Datos_actualizados$PCR.Cov == "Cov.Neg"
featureMatrix_cov_neg <- featureMatrix_num[indices_cov_neg, ]
Datos_actualizados_cov_neg <- Datos_actualizados[indices_cov_neg, ]

# Verificar que los datos est√©n filtrados correctamente
dim(featureMatrix_cov_neg)
table(Datos_actualizados_cov_neg$equipo)

# Realizar el clustering jer√°rquico
dist_featureMatriz_cov_neg <- dist(featureMatrix_cov_neg)
hc_cov_neg <- hclust(dist_featureMatriz_cov_neg, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_neg <- as.dendrogram(hc_cov_neg)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(Datos_actualizados_cov_neg$equipo)
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]

# Personalizar el dendrograma
dend_cov_neg <- dend_cov_neg %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas


png("dendrograma_COVID.neg.png", width = 800, height = 600)
plot(dend_cov_neg, main = "Clustering de Negativos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")
dev.off()

# Visualizar el dendrograma
plot(dend_cov_neg, main = "Clustering de Negativos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")

```
 



 
```{r}

# Extraer solo las filas que corresponden a los equipos en featureMatrix_num
# Aseg√∫rate de que Datos_actualizados$equipo tenga valores v√°lidos para subindexar.
featureMatrix_equipo <- featureMatrix_num

# Verificar que los datos est√©n filtrados correctamente
table(Datos_actualizados$equipo)

# Calcular la matriz de distancias y realizar el clustering jer√°rquico
dist_featureMatriz_eq <- dist(featureMatrix_equipo)
hc_eq <- hclust(dist_featureMatriz_eq, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_eq <- as.dendrogram(hc_eq)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(Datos_actualizados$equipo)
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]           # Asignar colores por equipo

# Personalizar el dendrograma
dend_eq <- dend_eq %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

png("dendrograma_COVID.equipo.png", width = 800, height = 600)
plot(dend_eq, main = "Clustering Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")
dev.off()

# Visualizar el dendrograma
plot(dend_eq, main = "Clustering Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")


```
```{r}


Datos_actualizados$fecha <- as.factor(Datos_actualizados$fecha)

# Matriz de caracter√≠sticas (featureMatrix_num)
featureMatrix_fecha <- featureMatrix_num

# Calcular la matriz de distancias y realizar el clustering jer√°rquico
dist_featureMatriz_fecha <- dist(featureMatrix_fecha)
hc_fecha <- hclust(dist_featureMatriz_fecha, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_fecha <- as.dendrogram(hc_fecha)

# Crear un vector de colores para las etiquetas basado en 'fecha'
fecha_factor <- Datos_actualizados$fecha
palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
label_colors <- palette[fecha_factor]           # Asignar colores por fecha

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'fecha'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

# Visualizar el dendrograma
library(RColorBrewer)

# Crear una paleta m√°s contrastante
num_colores <- length(levels(fecha_factor))
palette <- brewer.pal(n = min(num_colores, 12), name = "Paired") # M√°x. 12 colores contrastantes
if (num_colores > 12) {
  palette <- colorRampPalette(brewer.pal(12, "Paired"))(num_colores) # Extender paleta si es necesario
}

# Aplicar los nuevos colores
label_colors <- palette[fecha_factor]

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.6)

png("dendrograma_fecha.png", width = 800, height = 600)
plot(dend_fecha, main = "Clustering Diferenciado por Fecha")
legend(
  "topright",
  legend = levels(fecha_factor),
  col = palette,
  pch = 19,
  title = "Fecha",
  cex = 0.7,
  bty = "n"
)
dev.off()

# Dibujar el dendrograma
plot(dend_fecha, main = "Clustering Diferenciado por Fecha")
legend(
  "topright",
  legend = levels(fecha_factor),
  col = palette,
  pch = 19,
  title = "Fecha",
  cex = 0.7,
  bty = "n"
)


```


 
 
# 18.Correcion efecto batch EQUIPO: Combat

```{r}
# Cargar el paquete sva
library(sva)

```

```{r}
# Ejemplo de datos de entrada
data_matrix <- featureMatrix_num  # Tu matriz de datos
metadata <- Datos_actualizados    # Dataframe de metadatos con informaci√≥n de batch
batch_info <- metadata$equipo      # Vector con la informaci√≥n de batch

```

```{r}
# Verificar si 'batch_info' es un factor o un vector de caracteres
str(batch_info)

# Si es necesario, convertirlo a un factor
batch_info <- factor(batch_info)


```

```{r}
sum(is.na(data_matrix))  # Revisa si hay valores NA en la matriz

```



```{r}

combat_corrected_equipo <- ComBat(
  dat = t(data_matrix),             
  batch = batch_info,            # Informaci√≥n de batch
  par.prior = TRUE,
  prior.plots = FALSE
)



```



```{r}
# Transponer de vuelta los datos corregidos
combat_corrected_equipo <- t(combat_corrected_equipo)

# Guardar la matriz corregida
write.csv(combat_corrected_equipo, "corrected_featureMatrix.csv")

```



```{r}
save(combat_corrected_equipo, file = "correccion_combat_equipo.rda")

```



```{r}
# Asignar colores manualmente en funci√≥n de batch_info
batch_colors <- as.factor(batch_info)   # Convertir batch_info a factor
levels(batch_colors)  # Ver los niveles de batch_info

# Definir colores manualmente (puedes cambiar los nombres de niveles y colores)
col_vector <- batch_colors
levels(col_vector) <- c("red", "blue", "green")  # Asigna colores a cada batch
```

```{r}
equipo_colors <- as.factor(metadata$equipo)  # Convertir 'equipo' a factor

# Asignar colores
palette_colors <- rainbow(length(unique(equipo_colors)))  # Colores √∫nicos
col_vector <- palette_colors[equipo_colors]
```

```{r}
pca_after <- prcomp(combat_corrected_equipo, scale. = TRUE)


png("PCA post COMBAT.png", width = 800, height = 600)
# Plot PCA despu√©s de la correcci√≥n
plot(pca_after$x[,1:2], col = col_vector, main = "PCA base despu√©s de la correcci√≥n")
legend("topright", 
       legend = levels(batch_colors), 
       col = palette_colors, 
       pch = 16, 
       title = "Batch")
dev.off()


# Plot PCA despu√©s de la correcci√≥n
plot(pca_after$x[,1:2], col = col_vector, main = "PCA base despu√©s de la correcci√≥n")
legend("topright", 
       legend = levels(batch_colors), 
       col = palette_colors, 
       pch = 16, 
       title = "Batch")
```


```{r}
# Verifica la consistencia de las dimensiones
stopifnot(nrow(pca_after$x) == nrow(Datos_actualizados))

# Define los colores por equipo
palette_colors <- c("red", "blue", "green")  # Cambia seg√∫n los equipos
col_vector <- palette_colors[as.factor(Datos_actualizados$equipo)]

# Define las formas por resultado COVID
pch_vector <- ifelse(Datos_actualizados$PCR.Cov == "Cov.Pos", 16, 17)


png("PCA_combat.png", width = 1200, height = 800)
plot(pca_after$x[, 1:2], 
     col = col_vector, 
     pch = pch_vector, 
     main = "PCA diferenciado por equipo y resultado COVID",
     xlab = "PC1", 
     ylab = "PC2")

# Leyenda por equipo
legend("topright", 
       legend = levels(as.factor(Datos_actualizados$equipo)), 
       col = palette_colors, 
       pch = 16, 
       title = "Equipo")

# Leyenda por resultado COVID
legend("topleft", 
       legend = c("COVID Positivo", "COVID Negativo"), 
       col = "black", 
       pch = c(16, 17), 
       title = "Resultado COVID")
dev.off()



# Grafica el PCA con diferenciaci√≥n por equipo y COVID
plot(pca_after$x[, 1:2], 
     col = col_vector, 
     pch = pch_vector, 
     main = "PCA diferenciado por equipo y resultado COVID",
     xlab = "PC1", 
     ylab = "PC2")

# Leyenda por equipo
legend("topright", 
       legend = levels(as.factor(Datos_actualizados$equipo)), 
       col = palette_colors, 
       pch = 22, 
       title = "Equipo")

# Leyenda por resultado COVID
legend("topleft", 
       legend = c("COVID Positivo", "COVID Negativo"), 
       col = "black", 
       pch = c(16, 17), 
       title = "Resultado COVID")


```

```{r}
# Verifica la consistencia de las dimensiones
stopifnot(nrow(pca_after$x) == nrow(Datos_actualizados))

# Define los colores por equipo
palette_colors <- c("red", "blue", "green")  # Cambia seg√∫n los equipos
col_vector <- palette_colors[as.factor(Datos_actualizados$equipo)]

# Define las formas por resultado COVID
pch_vector <- ifelse(Datos_actualizados$PCR.Cov == "Cov.Pos", 16, 17)


png("PCA_combat.png", width = 1200, height = 800)
plot(pca_after$x[, 2:3], 
     col = col_vector, 
     pch = pch_vector, 
     main = "PCA diferenciado por equipo y resultado COVID",
     xlab = "PC2", 
     ylab = "PC3")

# Leyenda por equipo
legend("topright", 
       legend = levels(as.factor(Datos_actualizados$equipo)), 
       col = palette_colors, 
       pch = 16, 
       title = "Equipo")

# Leyenda por resultado COVID
legend("topleft", 
       legend = c("COVID Positivo", "COVID Negativo"), 
       col = "black", 
       pch = c(16, 17), 
       title = "Resultado COVID")
dev.off()



# Grafica el PCA con diferenciaci√≥n por equipo y COVID
plot(pca_after$x[, 2:3], 
     col = col_vector, 
     pch = pch_vector, 
     main = "PCA diferenciado por equipo y resultado COVID",
     xlab = "PC2", 
     ylab = "PC3")

# Leyenda por equipo
legend("topright", 
       legend = levels(as.factor(Datos_actualizados$equipo)), 
       col = palette_colors, 
       pch = 22, 
       title = "Equipo")

# Leyenda por resultado COVID
legend("topleft", 
       legend = c("COVID Positivo", "COVID Negativo"), 
       col = "black", 
       pch = c(16, 17), 
       title = "Resultado COVID")


```


```{r}
# Cargar librer√≠as necesarias
library(ggplot2)
library(dplyr)


pca_scores <- pca_after$x

# 3. Agregar los resultados PCA al dataframe de metadatos
metadata_pca <- cbind(Datos_actualizados[,c(4:7)], pca_scores)

# 4. Funci√≥n para realizar Kruskal-Wallis sobre los componentes principales
kruskal_pca <- function(pca_scores, metadata, factor) {
  results <- data.frame()
  for (i in 1:ncol(pca_scores)) {  # Para cada componente principal
    pca_component <- pca_scores[, i]  # Extraer la puntuaci√≥n del componente
    model <- kruskal.test(pca_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
    factor_effect <- model$p.value  # Obtener el p-valor
    results <- rbind(results, data.frame(PC = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
  }
  return(results)
}

# 5. Lista de factores que quieres analizar
factors <- c("PCR.Cov", "fecha", "equipo")

# Ejecutar la funci√≥n para cada factor y combinar los resultados
kruskal_results <- do.call(rbind, lapply(factors, function(f) kruskal_pca(pca_scores, Datos_actualizados, f)))

# 6. Resumir el p-valor medio para cada factor
factor_summary <- kruskal_results %>%
  group_by(Factor) %>%
  summarise(MeanLogPValue = -log10(mean(PValue)))

pca_kruskal_COMBAT<- ggplot(factor_summary, aes(x = reorder(Factor, MeanLogPValue), y = MeanLogPValue, fill = Factor)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Importancia de los Factores PCA",
       x = "Factor",
       y = "-log10(P-valor Medio)",
       fill = "Factor")
    theme(
    plot.title = element_text(size = 35),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 30),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 30),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 18),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 28),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 28)  # Reducir tama√±o del texto de la leyenda
  )
print(pca_kruskal_COMBAT)
```

```{r}

pca_kruskal_COMBAT <- ggplot(factor_summary, aes(x = reorder(Factor, MeanLogPValue), y = MeanLogPValue, fill = Factor)) +
  geom_bar(stat = "identity", width = 0.7) +  # Ajusta el ancho de las barras
  coord_flip() +
  labs(
    title = "Importancia de los Factores PCA",
    x = "Factor",
    y = "-log10(P-valor Medio)",
    fill = "Factor"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  )

# Exportar el gr√°fico con dimensiones ajustadas
ggsave(
  filename = "CombatPCA.png",
  plot = pca_kruskal_COMBAT,
  width = 8,    # Ancho ajustado
  height = 6,   # Altura ajustada
  dpi = 300,
  scale = 1.5,  # Escala para aumentar proporcionalmente todo el dise√±o
  bg = "white"  # Fondo blanco asegurado
)
```




```{r}
library(umap)


# Ajustar par√°metros directamente en la funci√≥n umap
umap_combat <- umap(combat_corrected_equipo, n_neighbors = 10, metric = "euclidean", min_dist = 0.3)

# Verificar la estructura del objeto umap_v2
str(umap_combat) # Esto te mostrar√° la estructura para asegurarte de que layout es un componente v√°lido.

# Si la estructura es correcta, continuar con la conversi√≥n a dataframe
umap_coor_combat <- as.data.frame(umap_combat)

# Asignar nombres de columnas
colnames(umap_coor_combat) <- c("UMAP1", "UMAP2")

# A√±adir las columnas con los metadatos (COVID, equipo, etc.)
umap_coor_combat$covid <- Datos_actualizados$PCR.Cov
umap_coor_combat$equipo <- Datos_actualizados$equipo

# Graficar UMAP con ggplot2
library(ggplot2)
UMAP_postCombat<-ggplot(umap_coor_combat, aes(x = UMAP1, y = UMAP2, color = equipo, shape = covid)) +
  geom_point(size = 3) +
  labs(title = "UMAP post COMBAT",
       x = "UMAP1",
       y = "UMAP2") +
  theme_minimal()   +
  theme(
    plot.title = element_text(size = 14),  # Reducir tama√±o del t√≠tulo
    axis.title.x = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje X
    axis.title.y = element_text(size = 14),  # Reducir tama√±o del t√≠tulo del eje Y
    axis.text = element_text(size = 10),  # Reducir tama√±o de los textos de los ejes
    legend.title = element_text(size = 10),  # Reducir tama√±o del t√≠tulo de la leyenda
    legend.text = element_text(size = 10)  # Reducir tama√±o del texto de la leyenda
  )

print(UMAP_postCombat)
```


```{r}
UMAP_postCombat <- UMAP_postCombat + 
  theme(
    panel.background = element_rect(fill = "white"), # Fondo blanco
    
    panel.grid.minor = element_blank(), # Sin l√≠neas de cuadr√≠cula menores
    plot.background = element_rect(fill = "white") # Fondo del gr√°fico blanco
  )

```



```{r}

umap_scores <- umap_combat  # Tomar el resultado de UMAP directamente

# Luego sigues con el mismo an√°lisis
metadata_umap <- cbind(Datos_actualizados[,c(4,5,7)], umap_scores)

# Funci√≥n para realizar Kruskal-Wallis sobre las dimensiones de UMAP
kruskal_umap <- function(umap_scores, metadata, factor) {
  results <- data.frame()
  for (i in 1:ncol(umap_scores)) {  # Para cada dimensi√≥n de UMAP
    umap_component <- umap_scores[, i]  # Extraer la puntuaci√≥n de la dimensi√≥n
    model <- kruskal.test(umap_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
    factor_effect <- model$p.value  # Obtener el p-valor
    results <- rbind(results, data.frame(UMAP_Dim = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
  }
  return(results)
}

# Lista de factores que quieres analizar
factors <- c("PCR.Cov", "fecha", "equipo")

# Ejecutar la funci√≥n para cada factor y combinar los resultados
kruskal_results_umap <- do.call(rbind, lapply(factors, function(f) kruskal_umap(umap_scores, Datos_actualizados, f)))

# Resumir el p-valor medio para cada factor
factor_summary_umap <- kruskal_results_umap %>%
  group_by(Factor) %>%
  summarise(MeanLogPValue = -log10(mean(PValue)))

# Visualizar los resultados en un gr√°fico de barras
umap_postcombat_var<-ggplot(factor_summary_umap, aes(x = reorder(Factor, MeanLogPValue), y = MeanLogPValue, fill = Factor)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Importancia de componentes UMAP post COMBAT",
       x = "Factor",
       y = "-log10(P-valor Medio)",
       fill = "Factor")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  
  )


print(umap_postcombat_var)


```

```{r}
library(patchwork)

# Primero definimos el layout de los gr√°ficos combinados
combined_var_combat <- (
  pca_kruskal_COMBAT + umap_postcombat_var
)

# Agregamos los t√≠tulos y anotaciones
combined_var_combat <- combined_var_combat + 
  plot_annotation(
    title = "Influencia de los factores en los datos",
    tag_levels = "A"  # Etiquetas A, B, C, ...
  ) + 
  plot_layout(guides = "collect", widths = c(1, 1))  # Para asegurar que ambos gr√°ficos tengan el mismo ancho

# Para ver el gr√°fico
print(combined_var_combat)

# Guardamos con dimensiones optimizadas
ggsave(
  filename = "combined_var_kruskal.png",
  plot = combined_var_combat,
  width = 14,    # Aumentado para dar m√°s espacio
  height = 10,   # Aumentado proporcionalmente
  dpi = 300,
  scale = 1,    # Quitamos el scale para tener m√°s control directo
  bg = "white"
)
```

```{r}
library(patchwork)
combined_var_combat <- (
  pca_kruskal_COMBAT+umap_postcombat_var
)

# Agregar t√≠tulos a cada gr√°fico
combined_var_combat <- combined_plot + 
  plot_annotation(
    title = "Influencia de los factores en los datos",
    tag_levels = "A"  # Etiquetas A, B, C, ...
  ) + 
  plot_layout(guides = "collect")  # Para combinar las leyendas, si hay

# Mostrar el gr√°fico combinado
print(combined_var_combat)
```


```{r}
ggsave(
  filename = "combined_var_kruskal.png",
  plot = combined_var_combat,
  width = 12,    # Ancho ajustado
  height = 8,   # Altura ajustada
  dpi = 300,
  scale = 1.2,  # Escala para aumentar proporcionalmente todo el dise√±o
  bg = "white"  # Fondo blanco asegurado
)


```




```{r}

# umap_scores <- umap_result  # Tomar el resultado de UMAP directamente
# 
# # Luego sigues con el mismo an√°lisis
# metadata_umap <- cbind(Datos_actualizados[,c(4,5,7)], umap_scores)
# 
# # Funci√≥n para realizar Kruskal-Wallis sobre las dimensiones de UMAP
# kruskal_umap <- function(umap_scores, metadata, factor) {
#   results <- data.frame()
#   for (i in 1:ncol(umap_scores)) {  # Para cada dimensi√≥n de UMAP
#     umap_component <- umap_scores[, i]  # Extraer la puntuaci√≥n de la dimensi√≥n
#     model <- kruskal.test(umap_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
#     factor_effect <- model$p.value  # Obtener el p-valor
#     results <- rbind(results, data.frame(UMAP_Dim = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
#   }
#   return(results)
# }
# 
# # Lista de factores que quieres analizar
# factors <- c("PCR.Cov", "fecha", "equipo")
# 
# # Ejecutar la funci√≥n para cada factor y combinar los resultados
# kruskal_results_umap <- do.call(rbind, lapply(factors, function(f) kruskal_umap(umap_scores, Datos_actualizados, f)))
# 
# # Resumir el p-valor medio para cada factor
# factor_summary_umap <- kruskal_results_umap %>%
#   group_by(Factor) %>%
#   summarise(MeanPValue = mean(PValue))
# 
# # Visualizar los resultados en un gr√°fico de barras
# ggplot(factor_summary_umap, aes(x = reorder(Factor, MeanPValue), y = MeanPValue, fill = Factor)) +
#   geom_bar(stat = "identity") +
#   coord_flip() +
#   theme_minimal() +
#   labs(title = "Importancia de los Factores en el Efecto Batch (UMAP) despues de COMBAT",
#        x = "Factor",
#        y = "P-valor Medio",
#        fill = "Factor")
```

# clustering combat_equipo


```{r}
library(dendextend)

distancias <- dist(combat_corrected_equipo)

# Realizar el clustering jer√°rquico
hc <- hclust(distancias, method = "ward.D2")

# Convierte el dendrograma a un objeto de dendextend
dend <- as.dendrogram(hc)

# Crea un vector de colores basado en PCR.cov
# Cambia "PCR.cov" a la columna adecuada de Datos_actualizados
label_colors <- as.factor(Datos_actualizados$PCR.Cov)
palette <- c("red", "blue") # Cambia los colores si hay m√°s de 2 categor√≠as
label_colors <- palette[label_colors]

# Aplica los colores a las etiquetas
dend <- dend %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.5) # Ajusta el tama√±o de las etiquetas

# Dibuja el dendrograma
plot(dend, main = "Dendrograma por resultado COVID")
legend("topright",           # Posici√≥n de la leyenda
       legend = c("COVID Negativo", "COVID Positivo"), # Textos de la leyenda
       fill = c("red", "blue"),                        # Colores de la leyenda
       border = "black",                               # Borde de las cajas de color
       bty = "n",                                      # Sin caja alrededor de la leyenda
       cex = 0.8)    

```


```{r}
table(Datos_actualizados$PCR.Cov, label_colors)

```


 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_pos <- Datos_actualizados$PCR.Cov == "Cov.Pos"
featureMatrix_cov_pos <- combat_corrected_equipo[indices_cov_pos, ]
Datos_actualizados_cov_pos <- Datos_actualizados[indices_cov_pos, ]

# Verificar que los datos est√©n filtrados correctamente
dim(featureMatrix_cov_pos)
table(Datos_actualizados_cov_pos$equipo)


# Realizar el clustering jer√°rquico
dist_featureMatriz_cov_pos <- dist(featureMatrix_cov_pos)
hc_cov_pos <- hclust(dist_featureMatriz_cov_pos, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_pos <- as.dendrogram(hc_cov_pos)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(Datos_actualizados_cov_pos$equipo)
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]

# Personalizar el dendrograma
dend_cov_pos <- dend_cov_pos %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

# Visualizar el dendrograma
plot(dend_cov_pos, main = "Clustering de Positivos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")

```


 
 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_neg <- Datos_actualizados$PCR.Cov == "Cov.Neg"
featureMatrix_cov_neg <- combat_corrected_equipo[indices_cov_neg, ]
Datos_actualizados_cov_neg <- Datos_actualizados[indices_cov_neg, ]

# Verificar que los datos est√©n filtrados correctamente
dim(featureMatrix_cov_neg)
table(Datos_actualizados_cov_neg$equipo)

# Realizar el clustering jer√°rquico
dist_featureMatriz_cov_neg <- dist(featureMatrix_cov_neg)
hc_cov_neg <- hclust(dist_featureMatriz_cov_neg, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_neg <- as.dendrogram(hc_cov_neg)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(Datos_actualizados_cov_neg$equipo)
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]

# Personalizar el dendrograma
dend_cov_neg <- dend_cov_neg %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

# Visualizar el dendrograma
plot(dend_cov_neg, main = "Clustering de Negativos Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")

```
 



 
```{r}

# Extraer solo las filas que corresponden a los equipos en featureMatrix_num
# Aseg√∫rate de que Datos_actualizados$equipo tenga valores v√°lidos para subindexar.
featureMatrix_equipo <- combat_corrected_equipo

# Verificar que los datos est√©n filtrados correctamente
table(Datos_actualizados$equipo)

# Calcular la matriz de distancias y realizar el clustering jer√°rquico
dist_featureMatriz_eq <- dist(featureMatrix_equipo)
hc_eq <- hclust(dist_featureMatriz_eq, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_eq <- as.dendrogram(hc_eq)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(Datos_actualizados$equipo)
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]           # Asignar colores por equipo

# Personalizar el dendrograma
dend_eq <- dend_eq %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas


png("dendrograma_COVID.equipo.png", width = 800, height = 600)
plot(dend_eq, main = "Clustering Diferenciado por Equipo post Combat")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")
dev.off()

# Visualizar el dendrograma
plot(dend_eq, main = "Clustering Diferenciado por Equipo post Combat")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")


```




```{r}


Datos_actualizados$fecha <- as.factor(Datos_actualizados$fecha)

# Matriz de caracter√≠sticas (featureMatrix_num)
featureMatrix_fecha <- combat_corrected_equipo

# Calcular la matriz de distancias y realizar el clustering jer√°rquico
dist_featureMatriz_fecha <- dist(featureMatrix_fecha)
hc_fecha <- hclust(dist_featureMatriz_fecha, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_fecha <- as.dendrogram(hc_fecha)

# Crear un vector de colores para las etiquetas basado en 'fecha'
fecha_factor <- Datos_actualizados$fecha
palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
label_colors <- palette[fecha_factor]           # Asignar colores por fecha

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'fecha'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

# Visualizar el dendrograma
library(RColorBrewer)

# Crear una paleta m√°s contrastante
num_colores <- length(levels(fecha_factor))
palette <- brewer.pal(n = min(num_colores, 12), name = "Paired") # M√°x. 12 colores contrastantes
if (num_colores > 12) {
  palette <- colorRampPalette(brewer.pal(12, "Paired"))(num_colores) # Extender paleta si es necesario
}

# Aplicar los nuevos colores
label_colors <- palette[fecha_factor]

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.6)

# Dibujar el dendrograma
plot(dend_fecha, main = "Clustering Diferenciado por Fecha")
legend(
  "topright",
  legend = levels(fecha_factor),
  col = palette,
  pch = 19,
  title = "Fecha",
  cex = 0.7,
  bty = "n"
)


```

# 
```{r}
# library(lme4)
# library(ggplot2)
# 
# # Funci√≥n para realizar PVCA en los datos corregidos
# perform_pvca <- function(combat_corrected, Datos_actualizados, factors_to_analyze) {
#   print("Starting PVCA analysis...")
# 
#   # Comprobaciones de entrada
#   if (!is.matrix(combat_corrected) || !is.numeric(combat_corrected)) {
#     stop("combat_corrected must be a numeric matrix")
#   }
#   if (!is.data.frame(Datos_actualizados)) {
#     stop("Datos_actualizados must be a data frame")
#   }
#   if (!all(factors_to_analyze %in% names(Datos_actualizados))) {
#     stop("Not all factors_to_analyze are present in Datos_actualizados")
#   }
#   if (nrow(combat_corrected) != nrow(Datos_actualizados)) {
#     stop("Number of rows in combat_corrected and Datos_actualizados must be the same")
#   }
#   
#   # Realizar PCA sobre los datos corregidos por ComBat
#   print("Performing PCA on ComBat corrected data...")
#   pca_result <- prcomp(combat_corrected, scale. = TRUE)
#   
#   # Calcular proporci√≥n de varianza explicada por cada componente
#   var_prop <- pca_result$sdev^2 / sum(pca_result$sdev^2)
#   
#   # Inicializar la matriz de resultados
#   n_factors <- length(factors_to_analyze)
#   n_pcs <- ncol(pca_result$x)
#   vc_matrix <- matrix(0, nrow = n_factors, ncol = n_pcs)
#   
#   # Realizar an√°lisis de componentes de varianza para cada PC
#   print("Performing variance component analysis...")
#   for (i in 1:n_pcs) {
#     pc_data <- data.frame(PC = pca_result$x[, i], Datos_actualizados)
#     
#     # Crear f√≥rmula para el modelo mixto
#     formula <- as.formula(paste("PC ~", paste("(1|", factors_to_analyze, ")", collapse = " + ")))
#     
#     # Ajustar el modelo mixto
#     tryCatch({
#       mixed_model <- lmer(formula, data = pc_data, REML = TRUE)
#       
#       # Extraer componentes de varianza
#       vc <- as.data.frame(VarCorr(mixed_model))
#       vc_matrix[, i] <- vc$vcov[1:n_factors]
#     }, error = function(e) {
#       warning(paste("Error in PC", i, ":", e$message))
#     })
#   }
#   
#   # Ponderar los componentes de varianza por la proporci√≥n de varianza explicada
#   weighted_vc <- vc_matrix %*% diag(var_prop)
#   
#   # Calcular la proporci√≥n de varianza explicada por cada factor
#   pvca_results <- rowSums(weighted_vc) / sum(var_prop)
#   names(pvca_results) <- factors_to_analyze
#   
#   print("PVCA analysis completed.")
#   return(pvca_results)
# }
# 
# # Funci√≥n para graficar los resultados de PVCA
# plot_pvca <- function(pvca_results) {
#   print("Creating PVCA plot...")
#   results_df <- data.frame(
#     Factor = names(pvca_results),
#     Proportion = pvca_results
#   )
#   
#   p <- ggplot(results_df, aes(x = reorder(Factor, -Proportion), y = Proportion)) +
#     geom_bar(stat = "identity", fill = "steelblue") +
#     theme_minimal() +
#     labs(x = "Factors", y = "Proportion of Variance Explained", 
#          title = "Principal Variance Component Analysis After ComBat") +
#     theme(axis.text.x = element_text(angle = 45, hjust = 1))
#   
#   print(p)
#   print("Plot created.")
# }
# 
# # Ejecuci√≥n del PVCA sobre los datos corregidos
# print("Preparing to run PVCA after ComBat correction...")
# 
# # Aseg√∫rate de que `combat_corrected` (matriz corregida) y `Datos_actualizados` est√©n disponibles
# # Los factores a analizar son los mismos que antes
# factors_to_analyze <- c('PCR.Cov', 'equipo', 'fecha')
# 
# print("Running PVCA on ComBat corrected data...")
# combat_pvca_results <- perform_pvca(combat_corrected, Datos_actualizados, factors_to_analyze)
# 
# print("PVCA Results after ComBat:")
# print(combat_pvca_results)
# 
# print("Creating plot for PVCA results after ComBat...")
# plot_pvca(combat_pvca_results)
# 
# print("Script execution completed.")


```






# 18.Correcion efecto batch FECHA: Combat

```{r}
# Ejemplo de datos de entrada
data_matrix <- featureMatrix_num  # Tu matriz de datos
metadata <- Datos_actualizados    # Dataframe de metadatos con informaci√≥n de batch
batch_info <- metadata$fecha      # Vector con la informaci√≥n de batch

```

```{r}
# Verificar si 'batch_info' es un factor o un vector de caracteres
str(batch_info)

# Si es necesario, convertirlo a un factor
batch_info <- factor(batch_info)


```

```{r}
sum(is.na(data_matrix))  # Revisa si hay valores NA en la matriz

```



```{r}

combat_corrected_fecha <- ComBat(
  dat = t(data_matrix),             
  batch = batch_info,            # Informaci√≥n de batch
  par.prior = TRUE,
  prior.plots = FALSE
)



```



```{r}
# Transponer de vuelta los datos corregidos
combat_corrected_fecha <- t(combat_corrected_fecha)

# Guardar la matriz corregida
write.csv(combat_corrected_fecha, "corrected_featureMatrix.csv")

```



```{r}
save(featureMatrix, file = "correccion_combat_fecha.rda")

```

# CLUSTERING COMBAT_FECHA


```{r}
library(dendextend)

distancias <- dist(combat_corrected_fecha)

# Realizar el clustering jer√°rquico
hc <- hclust(distancias, method = "ward.D2")

# Convierte el dendrograma a un objeto de dendextend
dend <- as.dendrogram(hc)

# Crea un vector de colores basado en PCR.cov
# Cambia "PCR.cov" a la columna adecuada de Datos_actualizados
label_colors <- as.factor(Datos_actualizados$PCR.Cov)
palette <- c("red", "blue") # Cambia los colores si hay m√°s de 2 categor√≠as
label_colors <- palette[label_colors]

# Aplica los colores a las etiquetas
dend <- dend %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.5) # Ajusta el tama√±o de las etiquetas




# Dibuja el dendrograma
plot(dend, main = "Dendrograma por resultado COVID")
legend("topright",           # Posici√≥n de la leyenda
       legend = c("COVID Negativo", "COVID Positivo"), # Textos de la leyenda
       fill = c("red", "blue"),                        # Colores de la leyenda
       border = "black",                               # Borde de las cajas de color
       bty = "n",                                      # Sin caja alrededor de la leyenda
       cex = 0.8)    

```


```{r}
table(Datos_actualizados$PCR.Cov, label_colors)

```

 
 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_pos <- Datos_actualizados$PCR.Cov == "Cov.Pos"
featureMatrix_cov_pos <- combat_corrected_fecha[indices_cov_pos, ]
Datos_actualizados_cov_pos <- Datos_actualizados[indices_cov_pos, ]

# Verificar que los datos est√©n filtrados correctamente
dim(featureMatrix_cov_pos)
table(Datos_actualizados_cov_pos$fecha)


# Realizar el clustering jer√°rquico
dist_featureMatriz_cov_pos <- dist(featureMatrix_cov_pos)
hc_cov_pos <- hclust(dist_featureMatriz_cov_pos, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_pos <- as.dendrogram(hc_cov_pos)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(Datos_actualizados_cov_pos$fecha)
palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
label_colors <- palette[fecha_factor]

# Personalizar el dendrograma
dend_cov_pos <- dend_cov_pos %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas






# Visualizar el dendrograma
plot(dend_cov_pos, main = "Clustering de Positivos Diferenciado por fecha")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Fecha")

```


 
 
```{r}
library(dendextend)
library(factoextra)

# Filtrar las muestras positivas (COV.POS)
indices_cov_neg <- Datos_actualizados$PCR.Cov == "Cov.Neg"
featureMatrix_cov_neg <- combat_corrected_fecha[indices_cov_neg, ]
Datos_actualizados_cov_neg <- Datos_actualizados[indices_cov_neg, ]

# Verificar que los datos est√©n filtrados correctamente
dim(featureMatrix_cov_neg)
table(Datos_actualizados_cov_neg$fecha)

# Realizar el clustering jer√°rquico
dist_featureMatriz_cov_neg <- dist(featureMatrix_cov_neg)
hc_cov_neg <- hclust(dist_featureMatriz_cov_neg, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_cov_neg <- as.dendrogram(hc_cov_neg)

# Crear un vector de colores para las etiquetas basado en 'fecha'
equipo_factor <- as.factor(Datos_actualizados_cov_neg$fecha)
palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
label_colors <- palette[fecha_factor]

# Personalizar el dendrograma
dend_cov_neg <- dend_cov_neg %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

# Visualizar el dendrograma
plot(dend_cov_neg, main = "Clustering de Negativos Diferenciado por fecha")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")

```
 



 
```{r}

# Extraer solo las filas que corresponden a los equipos en featureMatrix_num
# Aseg√∫rate de que Datos_actualizados$equipo tenga valores v√°lidos para subindexar.
featureMatrix_equipo <- combat_corrected_fecha

# Verificar que los datos est√©n filtrados correctamente
table(Datos_actualizados$equipo)

# Calcular la matriz de distancias y realizar el clustering jer√°rquico
dist_featureMatriz_eq <- dist(combat_corrected_fecha)
hc_eq <- hclust(dist_featureMatriz_eq, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_eq <- as.dendrogram(hc_eq)

# Crear un vector de colores para las etiquetas basado en 'equipo'
equipo_factor <- as.factor(Datos_actualizados$equipo)
palette <- rainbow(length(levels(equipo_factor))) # Paleta de colores
label_colors <- palette[equipo_factor]           # Asignar colores por equipo

# Personalizar el dendrograma
dend_eq <- dend_eq %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'equipo'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas



# Visualizar el dendrograma
plot(dend_eq, main = "Clustering Diferenciado por Equipo")
legend("topright", legend = levels(equipo_factor), col = palette, pch = 19, title = "Equipo")


```




```{r}


Datos_actualizados$fecha <- as.factor(Datos_actualizados$fecha)

# Matriz de caracter√≠sticas (featureMatrix_num)
featureMatrix_fecha <- combat_corrected_fecha

# Calcular la matriz de distancias y realizar el clustering jer√°rquico
dist_featureMatriz_fecha <- dist(featureMatrix_fecha)
hc_fecha <- hclust(dist_featureMatriz_fecha, method = "ward.D2")

# Convertir a dendrograma para personalizar
dend_fecha <- as.dendrogram(hc_fecha)

# Crear un vector de colores para las etiquetas basado en 'fecha'
fecha_factor <- Datos_actualizados$fecha
palette <- rainbow(length(levels(fecha_factor))) # Paleta de colores
label_colors <- palette[fecha_factor]           # Asignar colores por fecha

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%  # Colorea las etiquetas por 'fecha'
  set("labels_cex", 0.6)               # Ajusta el tama√±o de las etiquetas

# Visualizar el dendrograma
library(RColorBrewer)

# Crear una paleta m√°s contrastante
num_colores <- length(levels(fecha_factor))
palette <- brewer.pal(n = min(num_colores, 12), name = "Paired") # M√°x. 12 colores contrastantes
if (num_colores > 12) {
  palette <- colorRampPalette(brewer.pal(12, "Paired"))(num_colores) # Extender paleta si es necesario
}

# Aplicar los nuevos colores
label_colors <- palette[fecha_factor]

# Personalizar el dendrograma
dend_fecha <- dend_fecha %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.6)




# Dibujar el dendrograma
plot(dend_fecha, main = "Clustering Diferenciado por Fecha")
legend(
  "topright",
  legend = levels(fecha_factor),
  col = palette,
  pch = 19,
  title = "Fecha",
  cex = 0.7,
  bty = "n"
)


png("FECHA_combat.png", width = 800, height = 600)
plot(dend_fecha, main = "Clustering Diferenciado por Fecha")
legend(
  "topright",
  legend = levels(fecha_factor),
  col = palette,
  pch = 19,
  title = "Fecha",
  cex = 0.7,
  bty = "n"
)
dev.off()

```


#En ComBat, el argumento modcombat (o mod) contiene la matriz de dise√±o que representa las variables de inter√©s que deseas preservar durante la correcci√≥n por batch


#####error

```{r}
modcombat <- model.matrix(~ equipo, data = Datos_actualizados)

```

```{r}
# Ejemplo de datos de entrada
data_matrix <- featureMatrix_num  # Tu matriz de datos
metadata <- Datos_actualizados    # Dataframe de metadatos con informaci√≥n de batch
batch_info <- metadata$fecha      # Vector con la informaci√≥n de batch

```

```{r}
# Verificar si 'batch_info' es un factor o un vector de caracteres
str(batch_info)

# Si es necesario, convertirlo a un factor
batch_info <- factor(batch_info)


```


```{r}
combat_corrected_fecha2 <- ComBat(
  dat = t(data_matrix),         # Matriz de intensidades
  batch = batch_info,    # Variable batch (por ejemplo, equipos)
  mod = modcombat,
  par.prior = TRUE,
  prior.plots = FALSE)

```

         
```{r}
# Transponer de vuelta los datos corregidos
combat_corrected_fecha2 <- t(combat_corrected_fecha2)

# Guardar la matriz corregida
write.csv(combat_corrected_fecha2, "corrected_featureMatrix.csv")

```

```{r}
# Asignar colores manualmente en funci√≥n de batch_info
batch_colors <- as.factor(batch_info)   # Convertir batch_info a factor
levels(batch_colors)  # Ver los niveles de batch_info

# Definir colores manualmente (puedes cambiar los nombres de niveles y colores)
col_vector <- batch_colors
levels(col_vector) <- c("red", "blue", "green")  # Asigna colores a cada batch
```

```{r}
fecha_colors <- as.factor(metadata$fecha)  # Convertir 'equipo' a factor

# Asignar colores
palette_colors <- rainbow(length(unique(fecha_colors)))  # Colores √∫nicos
col_vector <- palette_colors[fecha_colors]
```

```{r}
pca_after2 <- prcomp(combat_corrected_fecha2, scale. = TRUE)

# Plot PCA despu√©s de la correcci√≥n
plot(pca_after2$x[,1:2], col = col_vector, main = "PCA despu√©s de la correcci√≥n")
legend("topright", 
       legend = levels(batch_colors), 
       col = palette_colors, 
       pch = 16, 
       title = "Batch")
```


```{r}
library(umap)


# Ajustar par√°metros directamente en la funci√≥n umap
umap_v5 <- umap(combat_corrected2, n_neighbors = 15, metric = "euclidean", min_dist = 0.1)

# Verificar la estructura del objeto umap_v2
str(umap_v5) # Esto te mostrar√° la estructura para asegurarte de que layout es un componente v√°lido.

# Si la estructura es correcta, continuar con la conversi√≥n a dataframe
umap_coor5 <- as.data.frame(umap_v5)

# Asignar nombres de columnas
colnames(umap_coor5) <- c("UMAP1", "UMAP2")

# A√±adir las columnas con los metadatos (COVID, equipo, etc.)
umap_coor5$covid <- Datos_actualizados$PCR.Cov
umap_coor5$equipo <- Datos_actualizados$equipo

# Graficar UMAP con ggplot2
library(ggplot2)
ggplot(umap_coor5, aes(x = UMAP1, y = UMAP2, color = equipo, shape = covid)) +
  geom_point(size = 3) +
  labs(title = "UMAP luego de correcci√≥n por COMBAT",
       x = "UMAP1",
       y = "UMAP2") +
  theme_minimal()
```



```{r}

umap_scores <- umap_v5  # Tomar el resultado de UMAP directamente

# Luego sigues con el mismo an√°lisis
metadata_umap <- cbind(Datos_actualizados[,c(4,5,7)], umap_scores)

# Funci√≥n para realizar Kruskal-Wallis sobre las dimensiones de UMAP
kruskal_umap <- function(umap_scores, metadata, factor) {
  results <- data.frame()
  for (i in 1:ncol(umap_scores)) {  # Para cada dimensi√≥n de UMAP
    umap_component <- umap_scores[, i]  # Extraer la puntuaci√≥n de la dimensi√≥n
    model <- kruskal.test(umap_component ~ metadata[[factor]])  # Realizar la prueba de Kruskal-Wallis
    factor_effect <- model$p.value  # Obtener el p-valor
    results <- rbind(results, data.frame(UMAP_Dim = i, Factor = factor, PValue = factor_effect))  # Guardar resultados
  }
  return(results)
}

# Lista de factores que quieres analizar
factors <- c("PCR.Cov", "fecha", "equipo")

# Ejecutar la funci√≥n para cada factor y combinar los resultados
kruskal_results_umap <- do.call(rbind, lapply(factors, function(f) kruskal_umap(umap_scores, Datos_actualizados, f)))

# Resumir el p-valor medio para cada factor
factor_summary_umap <- kruskal_results_umap %>%
  group_by(Factor) %>%
  summarise(MeanPValue = mean(PValue))

# Visualizar los resultados en un gr√°fico de barras
ggplot(factor_summary_umap, aes(x = reorder(Factor, MeanPValue), y = MeanPValue, fill = Factor)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Importancia de los Factores en el Efecto Batch (UMAP) despues de COMBAT",
       x = "Factor",
       y = "P-valor Medio",
       fill = "Factor")

```
